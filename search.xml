<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>68. Text Justification</title>
      <link href="/2021/06/09/68-Text-Justification/"/>
      <url>/2021/06/09/68-Text-Justification/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of words and a width <em>maxWidth</em>, format the text such that each line has exactly <em>maxWidth</em> characters and is fully (left and right) justified.</p><p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <em>maxWidth</em> characters.</p><p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p><p>For the last line of text, it should be left justified and no <strong>extra</strong> space is inserted between words.</p><p><strong>Note:</strong></p><ul><li>A word is defined as a character sequence consisting of non-space characters only.</li><li>Each word’s length is guaranteed to be greater than 0 and not exceed <em>maxWidth</em>.</li><li>The input array <code>words</code> contains at least one word.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">   &quot;This    is    an&quot;,</span><br><span class="line">   &quot;example  of text&quot;,</span><br><span class="line">   &quot;justification.  &quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;What   must   be&quot;,</span><br><span class="line">  &quot;acknowledgment  &quot;,</span><br><span class="line">  &quot;shall be        &quot;</span><br><span class="line">]</span><br><span class="line">Explanation: Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;, because the last line must be left-justified instead of fully-justified.</span><br><span class="line">Note that the second line is also left-justified becase it contains only one word.</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p><code>(len(word) + chars + len(cur))</code> includes the space that need to add between words.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words: List[str], maxWidth: int)</span> -&gt; List[str]:</span></span><br><span class="line">        ans, cur = [], []</span><br><span class="line">        chars = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="comment"># if cur is empty or the total chars + total needed spaces + next word fit</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur <span class="keyword">or</span> (len(word) + chars + len(cur)) &lt;= maxWidth:</span><br><span class="line">                cur.append(word)</span><br><span class="line">                chars += len(word)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># place spaces, append the line to the ans, and move on</span></span><br><span class="line">                line = self.placeSpacesBetween(cur, maxWidth - chars)</span><br><span class="line">                ans.append(line)</span><br><span class="line">                cur.clear()</span><br><span class="line">                cur.append(word)</span><br><span class="line">                chars = len(word)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># left justify any remaining text, which is easy</span></span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            extra_spaces = maxWidth - chars - len(cur) + <span class="number">1</span></span><br><span class="line">            ans.append(<span class="string">' '</span>.join(cur) + <span class="string">' '</span> * extra_spaces)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">placeSpacesBetween</span><span class="params">(self, words, spaces)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(words) == <span class="number">1</span>: <span class="keyword">return</span> words[<span class="number">0</span>] + <span class="string">' '</span> * spaces</span><br><span class="line">        </span><br><span class="line">        space_groups = len(words)<span class="number">-1</span></span><br><span class="line">        spaces_between_words = spaces // space_groups</span><br><span class="line">        extra_spaces = spaces % space_groups</span><br><span class="line">        </span><br><span class="line">        cur = []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            cur.append(word)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># place the min of remaining spaces or spaces between words plus an extra if available</span></span><br><span class="line">            cur_extra = min(<span class="number">1</span>, extra_spaces)</span><br><span class="line">            spaces_to_place = min(spaces_between_words + cur_extra, spaces)</span><br><span class="line"></span><br><span class="line">            cur.append(<span class="string">' '</span> * spaces_to_place)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> extra_spaces: extra_spaces -= <span class="number">1</span></span><br><span class="line">            spaces -= spaces_to_place</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(cur)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words: List[str], maxWidth: int)</span> -&gt; List[str]:</span></span><br><span class="line">            </span><br><span class="line">        result, current_list, num_of_letters = [],[], <span class="number">0</span></span><br><span class="line">        <span class="comment"># result -&gt; stores final result output</span></span><br><span class="line">        <span class="comment"># current_list -&gt; stores list of words which are traversed but not yet added to result</span></span><br><span class="line">        <span class="comment"># num_of_letters -&gt; stores number of chars corresponding to words in current_list</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># total no. of chars in current_list + total no. of chars in current word</span></span><br><span class="line">            <span class="comment"># + total no. of words ~= min. number of spaces between words</span></span><br><span class="line">            <span class="keyword">if</span> num_of_letters + len(word) + len(current_list) &gt; maxWidth:</span><br><span class="line">                <span class="comment"># size will be used for module "magic" for round robin</span></span><br><span class="line">                <span class="comment"># we use max. 1 because atleast one word would be there and to avoid modulo by 0</span></span><br><span class="line">                size = max(<span class="number">1</span>, len(current_list)<span class="number">-1</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(maxWidth-num_of_letters):</span><br><span class="line">                    <span class="comment"># add space to each word in round robin fashion</span></span><br><span class="line">                    index = i%size</span><br><span class="line">                    current_list[index] += <span class="string">' '</span> </span><br><span class="line">                </span><br><span class="line">                <span class="comment"># add current line of words to the output</span></span><br><span class="line">                result.append(<span class="string">""</span>.join(current_list))</span><br><span class="line">                current_list, num_of_letters = [], <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># add current word to the list and add length to char count</span></span><br><span class="line">            current_list.append(word)</span><br><span class="line">            num_of_letters += len(word)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># form last line by join with space and left justify to maxWidth using ljust (python method)</span></span><br><span class="line">        <span class="comment"># that means pad additional spaces to the right to make string length equal to maxWidth</span></span><br><span class="line">        result.append(<span class="string">" "</span>.join(current_list).ljust(maxWidth))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>611. Valid Triangle Number</title>
      <link href="/2021/06/08/611-Valid-Triangle-Number/"/>
      <url>/2021/06/08/611-Valid-Triangle-Number/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an integer array <code>nums</code>, return <em>the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,2,3,4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Valid combinations are:</span><br><span class="line">2,3,4 (using the first 2)</span><br><span class="line">2,3,4 (using the second 2)</span><br><span class="line">2,2,3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,2,3,4]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Example:</p><p><code>arr = [3, 4, 6, 38, 39 ]</code></p><p>now your low = <code>3</code>, high = <code>38</code>, arr[i] = <code>39</code></p><p>Triangle inequality says that any 2 sides of triangle should be greater than the 3rd side.</p><p>you now know that your array is sorted s<code>o</code>3 + 38 &gt; 39 [3, 38, 39]<code>and the numbers which would come after 3 would be greater than 3 so next possible sides of triangles would include</code>[4, 38, 39] , [6, 38, 39]<code>. That is why you add the difference of</code>high - low` which is in this case 3 - 0 = 3 possible sides of triangles as shown above.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">triangleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">            left, right = <span class="number">0</span>, i<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[left]+ nums[right]:</span><br><span class="line">                    res += right-left</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>254. Factor Combinations</title>
      <link href="/2021/06/08/254-Factor-Combinations/"/>
      <url>/2021/06/08/254-Factor-Combinations/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Numbers can be regarded as the product of their factors.</p><ul><li>For example, <code>8 = 2 x 2 x 2 = 2 x 4</code>.</li></ul><p>Given an integer <code>n</code>, return <em>all possible combinations of its factors</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>Note</strong> that the factors should be in the range <code>[2, n - 1]</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 12</span><br><span class="line">Output: [[2,6],[3,4],[2,2,3]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 37</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 32</span><br><span class="line">Output: [[2,16],[4,8],[2,2,8],[2,4,4],[2,2,2,4],[2,2,2,2,2]]</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Iterative</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFactors</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># factors start from 2, do an iterative function with last combination</span></span><br><span class="line">        <span class="comment"># every time we find a new factor, append the combination for next use</span></span><br><span class="line">        <span class="comment"># also add to result</span></span><br><span class="line">        todo, res = [(n, <span class="number">2</span>, [])], []</span><br><span class="line">        <span class="keyword">while</span> todo:</span><br><span class="line">            n, i, comb = todo.pop()</span><br><span class="line">            <span class="keyword">while</span> i*i &lt;= n:</span><br><span class="line">                <span class="keyword">if</span> n % i == <span class="number">0</span>: <span class="comment"># find a factor i</span></span><br><span class="line">                    res.append(comb + [i, n//i])</span><br><span class="line">                    todo.append((n//i, i, comb+[i]))</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>Recursive</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFactors</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(n, i, combi, res)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> i * i &lt;= n:</span><br><span class="line">                <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                    res += combi + [i, n//i],</span><br><span class="line">                    factor(n//i, i, combi+[i], res)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> factor(n, <span class="number">2</span>, [], [])</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>366. Find Leaves of Binary Tree</title>
      <link href="/2021/06/07/366-Find-Leaves-of-Binary-Tree/"/>
      <url>/2021/06/07/366-Find-Leaves-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the <code>root</code> of a binary tree, collect a tree’s nodes as if you were doing this:</p><ul><li>Collect all the leaf nodes.</li><li>Remove all the leaf nodes.</li><li>Repeat until the tree is empty.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/16/remleaves-tree.jpg" alt="https://assets.leetcode.com/uploads/2021/03/16/remleaves-tree.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5]</span><br><span class="line">Output: [[4,5,3],[2],[1]]</span><br><span class="line">Explanation:</span><br><span class="line">[[3,5,4],[2],[1]] and [[3,4,5],[2],[1]] are also considered correct answers since per each level it does not matter the order on which elements are returned.</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLeaves</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            height = max(left, right) + <span class="number">1</span></span><br><span class="line">            dic[height].append(root.val)</span><br><span class="line">            <span class="keyword">return</span> height</span><br><span class="line">        dic = defaultdict(list)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> dic.values()</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>243. Shortest Word Distance</title>
      <link href="/2021/06/07/243-Shortest-Word-Distance/"/>
      <url>/2021/06/07/243-Shortest-Word-Distance/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of strings <code>wordsDict</code> and two different strings that already exist in the array <code>word1</code> and <code>word2</code>, return <em>the shortest distance between these two words in the list</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: wordsDict = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;], word1 = &quot;coding&quot;, word2 = &quot;practice&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: wordsDict = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;], word1 = &quot;makes&quot;, word2 = &quot;coding&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two variable to track latest index of <code>word1</code> and <code>word2</code>. When encounter different word and the we found the word before, update the <code>res</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestDistance</span><span class="params">(self, words: List[str], word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        res = len(words)</span><br><span class="line">        position1, position2 = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">            <span class="keyword">if</span> words[i] == word1:</span><br><span class="line">                position1 = i</span><br><span class="line">                <span class="keyword">if</span> position2 != <span class="number">-1</span>:</span><br><span class="line">                    res = min(res, abs(position1 - position2))</span><br><span class="line">            <span class="keyword">elif</span> words[i] == word2:</span><br><span class="line">                position2 = i</span><br><span class="line">                <span class="keyword">if</span> position1 != <span class="number">-1</span>:</span><br><span class="line">                    res = min(res, abs(position1 - position2))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>706. Design HashMap</title>
      <link href="/2021/06/02/706-Design-HashMap/"/>
      <url>/2021/06/02/706-Design-HashMap/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a HashMap <strong>without using any built-in hash table libraries</strong>.</p><p>Implement the <code>MyHashMap</code> class:</p><ul><li><code>MyHashMap()</code> initializes the object with an empty map.</li><li><code>void put(int key, int value)</code> inserts a <code>(key, value)</code> pair into the HashMap. If the <code>key</code> already exists in the map, update the corresponding <code>value</code>.</li><li><code>int get(int key)</code> returns the <code>value</code> to which the specified <code>key</code> is mapped, or <code>1</code> if this map contains no mapping for the <code>key</code>.</li><li><code>void remove(key)</code> removes the <code>key</code> and its corresponding <code>value</code> if the map contains the mapping for the <code>key</code>.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Array with list of Node to handle collision</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">        self.pair = (key, val)</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size = <span class="number">1000</span></span><br><span class="line">        self.hash = [<span class="keyword">None</span>]* self.size</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        index = key % self.size</span><br><span class="line">        <span class="keyword">if</span> self.hash[index] == <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># not in map yet</span></span><br><span class="line">            self.hash[index] = ListNode(key, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.hash[index]</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="keyword">if</span> cur.pair[<span class="number">0</span>] == key:</span><br><span class="line">                    cur.pair = (key, value)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> cur.next == <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = ListNode(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        index = key % self.size</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.hash[index] == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.hash[index]</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="keyword">if</span> cur.pair[<span class="number">0</span>] == key:</span><br><span class="line">                    <span class="keyword">return</span> cur.pair[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> cur.next == <span class="keyword">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, key: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        index = key % self.size</span><br><span class="line">        cur = pre = self.hash[index]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> cur.pair[<span class="number">0</span>] == key:</span><br><span class="line">            self.hash[index] = self.hash[index].next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="keyword">if</span> cur.pair[<span class="number">0</span>] == key:</span><br><span class="line">                    pre.next = cur.next</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur, pre = cur.next, pre.next</span><br><span class="line"><span class="comment"># Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyHashMap()</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.remove(key)</span></span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> design </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>218. The Skyline Problem</title>
      <link href="/2021/06/01/218-The-Skyline-Problem/"/>
      <url>/2021/06/01/218-The-Skyline-Problem/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A city’s <strong>skyline</strong> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return <em>the <strong>skyline</strong> formed by these buildings collectively</em>.</p><p>The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [lefti, righti, heighti]</code>:</p><ul><li><code>lefti</code> is the x coordinate of the left edge of the <code>ith</code> building.</li><li><code>righti</code> is the x coordinate of the right edge of the <code>ith</code> building.</li><li><code>heighti</code> is the height of the <code>ith</code> building.</li></ul><p>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.</p><p>The <strong>skyline</strong> should be represented as a list of “key points” <strong>sorted by their x-coordinate</strong> in the form <code>[[x1,y1],[x2,y2],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline’s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline’s contour.</p><p><strong>Note:</strong> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...,[2 3],[4 5],[12 7],...]</code></p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" alt="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</span><br><span class="line">Output: [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]</span><br><span class="line">Explanation:</span><br><span class="line">Figure A shows the buildings of the input.</span><br><span class="line">Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: buildings = [[0,2,3],[2,5,3]]</span><br><span class="line">Output: [[0,3],[5,0]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= buildings.length &lt;= 104</code></li><li><code>0 &lt;= lefti &lt; righti &lt;= 231 - 1</code></li><li><code>1 &lt;= heighti &lt;= 231 - 1</code></li><li><code>buildings</code> is sorted by <code>lefti</code> in non-decreasing order.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p><code>for each critical point c    c.y gets the height of the tallest rectangle over c</code></p><p>This is no longer obviously <code>O(n^2)</code>. If we can somehow calculate the height of the tallest rectangle over c in faster than <code>O(n)</code> time, we have beaten our <code>O(n^2)</code> algorithm. Fortunately, we know about a data structure which can keep track of an active set of integer-keyed objects and return the highest one in <code>O(log⁡n)</code> time: a (max) heap.</p><p>Our final solution, then, in <code>O(nlog⁡n)</code> time, is as follows. First, sort the critical points. Then scan across the critical points from left to right. When we encounter the left edge of a rectangle, we add that rectangle to the heap with its height as the key. When we encounter the right edge of a rectangle, we remove that rectangle from the heap. (This requires keeping external pointers into the heap.) Finally, any time we encounter a critical point, after updating the heap we set the height of that critical point to the value peeked from the top of the heap.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSkyline</span><span class="params">(self, buildings: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        events = []</span><br><span class="line">        <span class="keyword">for</span> L, R, H <span class="keyword">in</span> buildings:</span><br><span class="line">            events.append((L, -H, R)) </span><br><span class="line">            <span class="comment"># start event, using min heap so append -H</span></span><br><span class="line">            <span class="comment"># need that -H in the list, not just for the heap. Because, when you sort events, you want to make sure for given x an event with max H is processed first. ex: height 14 vs 15, after negative, -15 event would come before -14 event</span></span><br><span class="line">            events.append((R, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        events.sort()</span><br><span class="line">        </span><br><span class="line">        res = [(<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">        heap = [(<span class="number">0</span>, float(<span class="string">'inf'</span>))]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> pos, negH, R <span class="keyword">in</span> events:</span><br><span class="line">            <span class="comment"># processing events</span></span><br><span class="line">            <span class="comment"># 1. cleanout old events by pop out those right ends before new event</span></span><br><span class="line">            <span class="comment"># 2. push the new events to the queue</span></span><br><span class="line">            <span class="comment"># 3. check if new largest height affect result skyline</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># pop out building which is end</span></span><br><span class="line">            <span class="keyword">while</span> heap[<span class="number">0</span>][<span class="number">1</span>] &lt;= pos:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># if it is a start of building, push it into heap as current building</span></span><br><span class="line">            <span class="keyword">if</span> negH != <span class="number">0</span>:</span><br><span class="line">                heapq.heappush(heap, (negH, R))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># if change in height with previous key point, append to result</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>][<span class="number">1</span>] != -heap[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                res.append([pos, -heap[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://briangordon.github.io/2014/08/the-skyline-problem.html" target="_blank" rel="noopener">https://briangordon.github.io/2014/08/the-skyline-problem.html</a><br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1248. Count Number of Nice Subarrays</title>
      <link href="/2021/05/31/1248-Count-Number-of-Nice-Subarrays/"/>
      <url>/2021/05/31/1248-Count-Number-of-Nice-Subarrays/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of integers <code>nums</code> and an integer <code>k</code>. A continuous subarray is called <strong>nice</strong> if there are <code>k</code> odd numbers on it.</p><p>Return <em>the number of <strong>nice</strong> sub-arrays</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,2,1,1], k = 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,4,6], k = 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no odd numbers in the array.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Sliding window</p><ol><li>left right boundary to count if <code>nums[i:j]</code> have <code>k</code> odd numbers</li><li>start to count the number of subarray and moving left pointer <code>i</code></li><li>notice we end the while loop and move <code>i</code> to the next number. The count would rollover to next round when <code>j</code> increase because if <code>nums[j]</code> is even, then it would create more combinations based on previous.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nums: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>] - i move to nums[<span class="number">1</span>], exiting <span class="keyword">while</span> loop, count = <span class="number">2</span></span><br><span class="line">then we start to move j</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>] </span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfSubarrays</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># sliding window</span></span><br><span class="line">        <span class="comment"># start to count when having k odd numbers in subarray</span></span><br><span class="line">        i = res = count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &amp; <span class="number">1</span>:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> k == <span class="number">0</span>:</span><br><span class="line">                k += nums[i] &amp; <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            res += count</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>Replace even elements with 0 and odd elements with 1.</p><p>The problem is then reduced to the <code>number of subarrays with sum k</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfSubarrays</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># mod number to 2, change the question to subarray sum to k</span></span><br><span class="line">        cur_sum = res = <span class="number">0</span></span><br><span class="line">        dic = defaultdict(int)</span><br><span class="line">        dic[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            cur_sum += nums[i] % <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum - k <span class="keyword">in</span> dic:</span><br><span class="line">                res += dic[cur_sum-k]</span><br><span class="line">            dic[cur_sum] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> two pointers </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1312. Minimum Insertion Steps to Make a String Palindrome</title>
      <link href="/2021/05/27/1312-Minimum-Insertion-Steps-to-Make-a-String-Palindrome/"/>
      <url>/2021/05/27/1312-Minimum-Insertion-Steps-to-Make-a-String-Palindrome/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string <code>s</code>. In one step you can insert any character at any index of the string.</p><p>Return <em>the minimum number of steps</em> to make <code>s</code> palindrome.</p><p>A <strong>Palindrome String</strong> is one that reads the same backward as well as forward.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;zzazz&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The string &quot;zzazz&quot; is already palindrome we don&apos;t need any insertions.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;mbadm&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: String can be &quot;mbdadbm&quot; or &quot;mdbabdm&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Inserting 5 characters the string becomes &quot;leetcodocteel&quot;.</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Let’s imagine matching the characters of the string like a palindrome, from the begining and the end with 2 pointers <code>i</code> and <code>j</code>.We may encounter 2 scenarios:</p><ol><li>The character at <code>i</code> matches character at <code>j</code>.</li><li>The characters don’t match each other</li></ol><p>In case of 1 we just increase the pointer <code>i</code> and decrease the pointer <code>j</code>, <code>i++</code> and <code>j--</code> respectively.</p><p>In the second case we have 2 options:</p><ol><li>Insert one character at <code>j</code> to match the character at <code>i</code>.</li></ol><p>Or</p><ol><li>Insert one character at <code>i</code> to match the character at <code>j</code>.</li></ol><p>Since we are not actually adding the characters in the string but just calculating the cost,In case 1 we increase the pointer <code>i</code> by <code>1</code> and <code>j</code> stays as it is, as we still need a character to match at <code>j</code>and in case 2 we decrease the pointer <code>j</code> by <code>1</code> and <code>i</code> stays as it is, as we still need a character to match at <code>i</code>.both the cases adds cost <code>1</code> since we are inserting a letter.</p><p>We can then use these two different pairs of new <code>i</code> and <code>j</code> values (<code>i+1, j</code> and <code>i, j-1</code>) to again repeat the process and use the <strong>minimum</strong> result of these as our result for current pair of <code>i, j</code>.We can see that this is recursive and thus we can use recursion with caching to store the repeated values.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minInsertions</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># find longest common sequence for s and reversed(s)</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span> <span class="keyword">if</span> s[i] == s[~j] <span class="keyword">else</span> max(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> n - dp[n][n]</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>310. Minimum Height Trees</title>
      <link href="/2021/05/26/310-Minimum-Height-Trees/"/>
      <url>/2021/05/26/310-Minimum-Height-Trees/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.</p><p>Given a tree of <code>n</code> nodes labelled from <code>0</code> to <code>n - 1</code>, and an array of <code>n - 1</code> <code>edges</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an undirected edge between the two nodes <code>ai</code> and <code>bi</code> in the tree, you can choose any node of the tree as the root. When you select a node <code>x</code> as the root, the result tree has height <code>h</code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)</code>)  are called <strong>minimum height trees</strong> (MHTs).</p><p>Return <em>a list of all <strong>MHTs’</strong> root labels</em>. You can return the answer in <strong>any order</strong>.</p><p>The <strong>height</strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg" alt="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, edges = [[1,0],[1,2],[1,3]]</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/01/e2.jpg" alt="https://assets.leetcode.com/uploads/2020/09/01/e2.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinHeightTrees</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># build graph</span></span><br><span class="line">        <span class="comment"># start from leaves, remove those leaves from graph</span></span><br><span class="line">        <span class="comment"># keep searching when we have more than 2 nodes remaining in the graph</span></span><br><span class="line">        <span class="comment"># it's because for binary tree, we have two scenario, either single node is the MHT</span></span><br><span class="line">        <span class="comment"># OR someone's child are MHT, and that could only be two nodes</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">        graph = [set() <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> edges:</span><br><span class="line">            graph[x].add(y)</span><br><span class="line">            graph[y].add(x)</span><br><span class="line">        </span><br><span class="line">        leaves = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">if</span> len(graph[i]) == <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">2</span>:</span><br><span class="line">            n -= len(leaves)</span><br><span class="line">            newLeaves = []</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> leaves:</span><br><span class="line">                y = graph[x].pop()</span><br><span class="line">                graph[y].remove(x)</span><br><span class="line">                <span class="keyword">if</span> len(graph[y]) == <span class="number">1</span>:</span><br><span class="line">                    newLeaves.append(y)</span><br><span class="line">            leaves = newLeaves</span><br><span class="line">        <span class="keyword">return</span> leaves</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>261. Graph Valid Tree</title>
      <link href="/2021/05/25/261-Graph-Valid-Tree/"/>
      <url>/2021/05/25/261-Graph-Valid-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You have a graph of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given an integer n and a list of <code>edges</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an undirected edge between nodes <code>ai</code> and <code>bi</code> in the graph.</p><p>Return <code>true</code> <em>if the edges of the given graph make up a valid tree, and</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/12/tree1-graph.jpg" alt="https://assets.leetcode.com/uploads/2021/03/12/tree1-graph.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/12/tree2-graph.jpg" alt="https://assets.leetcode.com/uploads/2021/03/12/tree2-graph.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>If a graph does not have loop, the edge would be <code>number_of_vertex-1</code></p><p>DFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTree</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(edges) != n<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        graph = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            graph[edge[<span class="number">0</span>]].append(edge[<span class="number">1</span>])</span><br><span class="line">            graph[edge[<span class="number">1</span>]].append(edge[<span class="number">0</span>])</span><br><span class="line">        visited = set([])</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> graph[node]:</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    dfs(n)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> len(visited) == n</span><br></pre></td></tr></table></figure><p>Union Find</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTree</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(i, vertex)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i == vertex[i]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> find(vertex[i], vertex)</span><br><span class="line">        <span class="comment"># union find to check if cycle exist</span></span><br><span class="line">        vertex = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            u, v = edge[<span class="number">0</span>], edge[<span class="number">1</span>]</span><br><span class="line">            parent_u, parent_v = find(u, vertex), find(v, vertex)</span><br><span class="line">            <span class="keyword">if</span> parent_u == parent_v:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vertex[parent_u] = parent_v</span><br><span class="line">        <span class="keyword">return</span> len(edges) == n<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(V+E)$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> union find </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1804. Implement Trie II (Prefix Tree)</title>
      <link href="/2021/05/24/1804-Implement-Trie-II-Prefix-Tree/"/>
      <url>/2021/05/24/1804-Implement-Trie-II-Prefix-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A <strong><a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="noopener">trie</a></strong> (pronounced as “try”) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p><p>Implement the Trie class:</p><ul><li><code>Trie()</code> Initializes the trie object.</li><li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li><li><code>int countWordsEqualTo(String word)</code> Returns the number of instances of the string <code>word</code> in the trie.</li><li><code>int countWordsStartingWith(String prefix)</code> Returns the number of strings in the trie that have the string <code>prefix</code> as a prefix.</li><li><code>void erase(String word)</code> Erases the string <code>word</code> from the trie.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.child = defaultdict(TrieNode)</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            p = p.child[c]</span><br><span class="line">            p.count += <span class="number">1</span></span><br><span class="line">        p.tail += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countWordsEqualTo</span><span class="params">(self, word: str)</span> -&gt; int:</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> p.child:</span><br><span class="line">                p = p.child[c]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> p.tail</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countWordsStartingWith</span><span class="params">(self, prefix: str)</span> -&gt; int:</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> p.child:</span><br><span class="line">                p = p.child[c]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> p.count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">erase</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> p.child:</span><br><span class="line">                p = p.child[c]</span><br><span class="line">                p.count -= <span class="number">1</span></span><br><span class="line">        p.tail -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Trie()</span></span><br><span class="line"><span class="comment"># obj.insert(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.countWordsEqualTo(word)</span></span><br><span class="line"><span class="comment"># param_3 = obj.countWordsStartingWith(prefix)</span></span><br><span class="line"><span class="comment"># obj.erase(word)</span></span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> design </tag>
            
            <tag> trie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1871. Jump Game VII</title>
      <link href="/2021/05/23/1871-Jump-Game-VII/"/>
      <url>/2021/05/23/1871-Jump-Game-VII/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given a <strong>0-indexed</strong> binary string <code>s</code> and two integers <code>minJump</code> and <code>maxJump</code>. In the beginning, you are standing at index <code>0</code>, which is equal to <code>&#39;0&#39;</code>. You can move from index <code>i</code> to index <code>j</code> if the following conditions are fulfilled:</p><ul><li><code>i + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1)</code>, and</li><li><code>s[j] == &#39;0&#39;</code>.</li></ul><p>Return <code>true</code> if you can reach index <code>s.length - 1</code> in <code>s</code><em>, or</em> <code>false</code> <em>otherwise.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;011010&quot;, minJump = 2, maxJump = 3</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">In the first step, move from index 0 to index 3.</span><br><span class="line">In the second step, move from index 3 to index 5.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;01101110&quot;, minJump = 2, maxJump = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li><li><code>s[0] == &#39;0&#39;</code></li><li><code>1 &lt;= minJump &lt;= maxJump &lt; s.length</code></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Initial thought: brute force and do exactly what the problem says:</p><ol><li>Create a queue of reachable indices starting with 0</li><li>While the queue is not empty, pull from front of queue, call this i</li><li>Let x go from i + minJumps to i + maxJumps, if s== ‘0’, add to queue</li><li>Repeat till queue is empty or reached end</li><li>If reached end return true, if queue empty, return false</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canReach</span><span class="params">(self, s: str, minJump: int, maxJump: int)</span> -&gt; bool:</span></span><br><span class="line">        q = deque([<span class="number">0</span>])</span><br><span class="line">        max_reach = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur_idx = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur_idx == len(s)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            start = max(cur_idx + minJump, max_reach)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, min(cur_idx+ maxJump+<span class="number">1</span>, len(s))):</span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">'0'</span>:</span><br><span class="line">                    q.append(i)</span><br><span class="line">            max_reach = cur_idx + maxJump</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>398. Random Pick Index</title>
      <link href="/2021/05/19/398-Random-Pick-Index/"/>
      <url>/2021/05/19/398-Random-Pick-Index/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an integer array <code>nums</code> with possible <strong>duplicates</strong>, randomly output the index of a given <code>target</code> number. You can assume that the given target number must exist in the array.</p><p>Implement the <code>Solution</code> class:</p><ul><li><code>Solution(int[] nums)</code> Initializes the object with the array <code>nums</code>.</li><li><code>int pick(int target)</code> Picks a random index <code>i</code> from <code>nums</code> where <code>nums[i] == target</code>. If there are multiple valid i’s, then each index should have an equal probability of returning.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]</span><br><span class="line">[[[1, 2, 3, 3, 3]], [3], [1], [3]]</span><br><span class="line">Output</span><br><span class="line">[null, 4, 0, 2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Solution solution = new Solution([1, 2, 3, 3, 3]);</span><br><span class="line">solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.</span><br><span class="line">solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.</span><br><span class="line">solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>target</code> is an integer from <code>nums</code>.</li><li>At most <code>104</code> calls will be made to <code>pick</code>.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Store all the index of the numbers in dictionary</p><p>randomly choose one of the index in <code>pick()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.dic = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            self.dic[n].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, target: int)</span> -&gt; int:</span></span><br><span class="line">        l = len(self.dic[target])</span><br><span class="line">        <span class="comment"># return self.dic[target][random.randint(0,len(self.dic[target])-1)]</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(self.dic[target])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Solution(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.pick(target)</span></span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> random </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>528. Random Pick with Weight</title>
      <link href="/2021/05/19/528-Random-Pick-with-Weight/"/>
      <url>/2021/05/19/528-Random-Pick-with-Weight/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given an array of positive integers <code>w</code> where <code>w[i]</code> describes the weight of <code>ith</code> index (0-indexed).</p><p>We need to call the function <code>pickIndex()</code> which <strong>randomly</strong> returns an integer in the range <code>[0, w.length - 1]</code>. <code>pickIndex()</code> should return the integer proportional to its weight in the <code>w</code> array. For example, for <code>w = [1, 3]</code>, the probability of picking the index <code>0</code> is <code>1 / (1 + 3) = 0.25</code> (i.e 25%) while the probability of picking the index <code>1</code> is <code>3 / (1 + 3) = 0.75</code> (i.e 75%).</p><p>More formally, the probability of picking index <code>i</code> is <code>w[i] / sum(w)</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;,&quot;pickIndex&quot;]</span><br><span class="line">[[[1]],[]]</span><br><span class="line">Output</span><br><span class="line">[null,0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Solution solution = new Solution([1]);</span><br><span class="line">solution.pickIndex(); // return 0. Since there is only one single element on the array the only option is to return the first element.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]</span><br><span class="line">[[[1,3]],[],[],[],[],[]]</span><br><span class="line">Output</span><br><span class="line">[null,1,1,1,1,0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Solution solution = new Solution([1, 3]);</span><br><span class="line">solution.pickIndex(); // return 1. It&apos;s returning the second element (index = 1) that has probability of 3/4.</span><br><span class="line">solution.pickIndex(); // return 1</span><br><span class="line">solution.pickIndex(); // return 1</span><br><span class="line">solution.pickIndex(); // return 1</span><br><span class="line">solution.pickIndex(); // return 0. It&apos;s returning the first element (index = 0) that has probability of 1/4.</span><br><span class="line"></span><br><span class="line">Since this is a randomization problem, multiple answers are allowed so the following outputs can be considered correct :</span><br><span class="line">[null,1,1,1,1,0]</span><br><span class="line">[null,1,1,1,1,1]</span><br><span class="line">[null,1,1,1,0,0]</span><br><span class="line">[null,1,1,1,0,1]</span><br><span class="line">[null,1,0,1,0,0]</span><br><span class="line">......</span><br><span class="line">and so on.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= w.length &lt;= 10000</code></li><li><code>1 &lt;= w[i] &lt;= 10^5</code></li><li><code>pickIndex</code> will be called at most <code>10000</code> times.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to create a <code>prefix_sum</code> array and have a <code>sum</code> for the total weight. </p><p>Then multiply the <code>sum</code> with <code>random</code> when picking a number. Do a binary search to find which index has the number that is smaller but closest to the <code>random*sum</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weight: List[int])</span>:</span></span><br><span class="line">        self.prefix_sum = []</span><br><span class="line">        prefix = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> weight:</span><br><span class="line">            prefix += w</span><br><span class="line">            self.prefix_sum.append(prefix)</span><br><span class="line">        self.total_sum = prefix</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickIndex</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        rand = self.total_sum* random.random()</span><br><span class="line">        i = bisect_left(self.prefix_sum, rand)</span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$ in <code>init</code>, $O(logn)$ when pickIndex<br>space complexity: $O(n)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1570. Dot Product of Two Sparse Vectors</title>
      <link href="/2021/05/17/1570-Dot-Product-of-Two-Sparse-Vectors/"/>
      <url>/2021/05/17/1570-Dot-Product-of-Two-Sparse-Vectors/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two sparse vectors, compute their dot product.</p><p>Implement class <code>SparseVector</code>:</p><ul><li><code>SparseVector(nums)</code> Initializes the object with the vector <code>nums</code></li><li><code>dotProduct(vec)</code> Compute the dot product between the instance of <em>SparseVector</em> and <code>vec</code></li></ul><p>A <strong>sparse vector</strong> is a vector that has mostly zero values, you should store the sparse vector <strong>efficiently</strong> and compute the dot product between two <em>SparseVector</em>.</p><p><strong>Follow up:</strong> What if only one of the vectors is sparse?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,0,0,2,3], nums2 = [0,3,0,4,0]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)</span><br><span class="line">v1.dotProduct(v2) = 1*0 + 0*3 + 0*0 + 2*4 + 3*0 = 8</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [0,1,0,0,0], nums2 = [0,0,0,0,2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: v1 = SparseVector(nums1) , v2 = SparseVector(nums2)</span><br><span class="line">v1.dotProduct(v2) = 0*0 + 1*0 + 0*0 + 0*0 + 0*2 = 0</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [0,1,0,0,2,0,0], nums2 = [1,0,0,0,3,0,4]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums1.length == nums2.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Since the vector is sparse, we only store indices with values that are nonzero.</p><p>A trick in <code>dotProduct</code> is to use the more sparse array as base to do less calculation.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseVector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums: List[int])</span>:</span></span><br><span class="line">        self.dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> n != <span class="number">0</span>:</span><br><span class="line">                self.dic[i] = n</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the dotProduct of two sparse vectors</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dotProduct</span><span class="params">(self, vec: <span class="string">'SparseVector'</span>)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(self.dic) &gt; len(vec.dic):</span><br><span class="line">            <span class="keyword">for</span> j, n <span class="keyword">in</span> vec.dic.items():</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">in</span> self.dic:</span><br><span class="line">                    res += self.dic[j]* n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i, n <span class="keyword">in</span> self.dic.items():</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> vec.dic:</span><br><span class="line">                    res += n*vec.dic[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># Your SparseVector object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># v1 = SparseVector(nums1)</span></span><br><span class="line"><span class="comment"># v2 = SparseVector(nums2)</span></span><br><span class="line"><span class="comment"># ans = v1.dotProduct(v2)</span></span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1249. Minimum Remove to Make Valid Parentheses</title>
      <link href="/2021/05/16/1249-Minimum-Remove-to-Make-Valid-Parentheses/"/>
      <url>/2021/05/16/1249-Minimum-Remove-to-Make-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string s of <code>&#39;(&#39;</code> , <code>&#39;)&#39;</code> and lowercase English characters.</p><p>Your task is to remove the minimum number of parentheses ( <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>, in any positions ) so that the resulting <em>parentheses string</em> is valid and return <strong>any</strong> valid string.</p><p>Formally, a <em>parentheses string</em> is valid if and only if:</p><ul><li>It is the empty string, contains only lowercase characters, or</li><li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or</li><li>It can be written as <code>(A)</code>, where <code>A</code> is a valid string.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;lee(t(c)o)de)&quot;</span><br><span class="line">Output: &quot;lee(t(c)o)de&quot;</span><br><span class="line">Explanation: &quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; would also be accepted.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;a)b(c)d&quot;</span><br><span class="line">Output: &quot;ab(c)d&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;))((&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: An empty string is also valid.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;(a(b(c)d)&quot;</span><br><span class="line">Output: &quot;a(b(c)d)&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s[i]</code> is one of <code>&#39;(&#39;</code> , <code>&#39;)&#39;</code> and lowercase English letters<code>.</code></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>Convert string to list, because String is an immutable data structure in Python and it’s much easier and memory-efficient to deal with a list for this task.</li><li>Iterate through list</li><li>Keep track of indices with open parentheses in the stack. In other words, when we come across open parenthesis we add an index to the stack.</li><li>When we come across close parenthesis we pop an element from the stack. If the stack is empty we replace current list element with an empty string</li><li>After iteration, we replace all indices we have in the stack with empty strings, because we don’t have close parentheses for them.</li><li>Convert list to string and return</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># stack to keep parentheses</span></span><br><span class="line">        s = list(s)</span><br><span class="line">        stk = deque()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">'('</span>:</span><br><span class="line">                stk.append(i)</span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> stk:</span><br><span class="line">                    stk.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s[i] = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> stk:</span><br><span class="line">            s[stk.pop()] = <span class="string">''</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1428. Leftmost Column with at Least a One</title>
      <link href="/2021/05/13/1428-Leftmost-Column-with-at-Least-a-One/"/>
      <url>/2021/05/13/1428-Leftmost-Column-with-at-Least-a-One/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p><em>(This problem is an <strong>interactive problem</strong>.)</em></p><p>A <strong>row-sorted binary matrix</strong> means that all elements are <code>0</code> or <code>1</code> and each row of the matrix is sorted in non-decreasing order.</p><p>Given a <strong>row-sorted binary matrix</strong> <code>binaryMatrix</code>, return <em>the index (0-indexed) of the <strong>leftmost column</strong> with a 1 in it</em>. If such an index does not exist, return <code>-1</code>.</p><p><strong>You can’t access the Binary Matrix directly.</strong> You may only access the matrix using a <code>BinaryMatrix</code> interface:</p><ul><li><code>BinaryMatrix.get(row, col)</code> returns the element of the matrix at index <code>(row, col)</code> (0-indexed).</li><li><code>BinaryMatrix.dimensions()</code> returns the dimensions of the matrix as a list of 2 elements <code>[rows, cols]</code>, which means the matrix is <code>rows x cols</code>.</li></ul><p>Submissions making more than <code>1000</code> calls to <code>BinaryMatrix.get</code> will be judged <em>Wrong Answer</em>. Also, any solutions that attempt to circumvent the judge will result in disqualification.</p><p>For custom testing purposes, the input will be the entire binary matrix <code>mat</code>. You will not have access to the binary matrix directly.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-5.jpg" alt="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-5.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = [[0,0],[1,1]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-4.jpg" alt="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-4.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = [[0,0],[0,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-3.jpg" alt="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-3.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = [[0,0],[0,0]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-6.jpg" alt="https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-6.jpg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = [[0,0,0,1],[0,0,1,1],[0,1,1,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>rows == mat.length</code></li><li><code>cols == mat[i].length</code></li><li><code>1 &lt;= rows, cols &lt;= 100</code></li><li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li><li><code>mat[i]</code> is sorted in non-decreasing order.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Linear search</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/782eb2ba-5324-4c42-83bc-8b90b5b1cf39/Untitled.png" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/782eb2ba-5324-4c42-83bc-8b90b5b1cf39/Untitled.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment"># This is BinaryMatrix's API interface.</span></span><br><span class="line"><span class="comment"># You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment">#class BinaryMatrix(object):</span></span><br><span class="line"><span class="comment">#    def get(self, row: int, col: int) -&gt; int:</span></span><br><span class="line"><span class="comment">#    def dimensions(self) -&gt; list[]:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leftMostColumnWithOne</span><span class="params">(self, binaryMatrix: <span class="string">'BinaryMatrix'</span>)</span> -&gt; int:</span></span><br><span class="line">        grid = binaryMatrix.dimensions()</span><br><span class="line">        m, n = grid[<span class="number">0</span>], grid[<span class="number">1</span>]</span><br><span class="line">        res = <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        r, c = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; m <span class="keyword">and</span> c &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> binaryMatrix.get(r,c) == <span class="number">1</span>:</span><br><span class="line">                res = c</span><br><span class="line">                c -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O(M+N)$<br>space complexity: $O(1)$</p><h3 id="Solution-Binary-search"><a href="#Solution-Binary-search" class="headerlink" title="Solution: Binary search"></a>Solution: Binary search</h3><p>Binary search:</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6317458e-79c3-47ae-9137-2bc40826fcb7/IMG_9488.heic" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6317458e-79c3-47ae-9137-2bc40826fcb7/IMG_9488.heic"></p><p>Use binary search to find the mid column </p><p>Find if there’s 1 in the column by walking through rows.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leftMostColumnWithOne</span><span class="params">(self, binaryMatrix: <span class="string">'BinaryMatrix'</span>)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># binary search</span></span><br><span class="line">        <span class="comment"># locate a row using binary search</span></span><br><span class="line">        <span class="comment"># check if there's 1 in the column </span></span><br><span class="line">        grid = binaryMatrix.dimensions()</span><br><span class="line">        m, n = grid[<span class="number">0</span>], grid[<span class="number">1</span>]</span><br><span class="line">        res = <span class="number">-1</span></span><br><span class="line">        left, right = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid_col = left + (right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.existOneInColumn(binaryMatrix, m, mid_col):</span><br><span class="line">                res = mid_col</span><br><span class="line">                right = mid_col<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid_col+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">existOneInColumn</span><span class="params">(self, binaryMatrix, m, c)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">0</span>, m):</span><br><span class="line">            <span class="keyword">if</span> binaryMatrix.get(r, c):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(MlogN)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1396. Design Underground System</title>
      <link href="/2021/05/11/1396-Design-Underground-System/"/>
      <url>/2021/05/11/1396-Design-Underground-System/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.</p><p>Implement the <code>UndergroundSystem</code> class:</p><ul><li><code>void checkIn(int id, string stationName, int t)</code><ul><li>A customer with a card ID equal to <code>id</code>, checks in at the station <code>stationName</code> at time <code>t</code>.</li><li>A customer can only be checked into one place at a time.</li></ul></li><li><code>void checkOut(int id, string stationName, int t)</code><ul><li>A customer with a card ID equal to <code>id</code>, checks out from the station <code>stationName</code> at time <code>t</code>.</li></ul></li><li><code>double getAverageTime(string startStation, string endStation)</code><ul><li>Returns the average time it takes to travel from <code>startStation</code> to <code>endStation</code>.</li><li>The average time is computed from all the previous traveling times from <code>startStation</code> to <code>endStation</code> that happened <strong>directly</strong>, meaning a check in at <code>startStation</code> followed by a check out from <code>endStation</code>.</li><li>The time it takes to travel from <code>startStation</code> to <code>endStation</code> <strong>may be different</strong> from the time it takes to travel from <code>endStation</code> to <code>startStation</code>.</li><li>There will be at least one customer that has traveled from <code>startStation</code> to <code>endStation</code> before <code>getAverageTime</code> is called.</li></ul></li></ul><p>You may assume all calls to the <code>checkIn</code> and <code>checkOut</code> methods are consistent. If a customer checks in at time <code>t1</code> then checks out at time <code>t2</code>, then <code>t1 &lt; t2</code>. All events happen in chronological order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;UndergroundSystem&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;getAverageTime&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;]</span><br><span class="line">[[],[45,&quot;Leyton&quot;,3],[32,&quot;Paradise&quot;,8],[27,&quot;Leyton&quot;,10],[45,&quot;Waterloo&quot;,15],[27,&quot;Waterloo&quot;,20],[32,&quot;Cambridge&quot;,22],[&quot;Paradise&quot;,&quot;Cambridge&quot;],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Leyton&quot;,24],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Waterloo&quot;,38],[&quot;Leyton&quot;,&quot;Waterloo&quot;]]</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">UndergroundSystem undergroundSystem = new UndergroundSystem();</span><br><span class="line">undergroundSystem.checkIn(45, &quot;Leyton&quot;, 3);</span><br><span class="line">undergroundSystem.checkIn(32, &quot;Paradise&quot;, 8);</span><br><span class="line">undergroundSystem.checkIn(27, &quot;Leyton&quot;, 10);</span><br><span class="line">undergroundSystem.checkOut(45, &quot;Waterloo&quot;, 15);  // Customer 45 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 15-3 = 12</span><br><span class="line">undergroundSystem.checkOut(27, &quot;Waterloo&quot;, 20);  // Customer 27 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 20-10 = 10</span><br><span class="line">undergroundSystem.checkOut(32, &quot;Cambridge&quot;, 22); // Customer 32 &quot;Paradise&quot; -&gt; &quot;Cambridge&quot; in 22-8 = 14</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Paradise&quot;, &quot;Cambridge&quot;); // return 14.00000. One trip &quot;Paradise&quot; -&gt; &quot;Cambridge&quot;, (14) / 1 = 14</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);    // return 11.00000. Two trips &quot;Leyton&quot; -&gt; &quot;Waterloo&quot;, (10 + 12) / 2 = 11</span><br><span class="line">undergroundSystem.checkIn(10, &quot;Leyton&quot;, 24);</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);    // return 11.00000</span><br><span class="line">undergroundSystem.checkOut(10, &quot;Waterloo&quot;, 38);  // Customer 10 &quot;Leyton&quot; -&gt; &quot;Waterloo&quot; in 38-24 = 14</span><br><span class="line">undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;);    // return 12.00000. Three trips &quot;Leyton&quot; -&gt; &quot;Waterloo&quot;, (10 + 12 + 14) / 3 = 12</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We have several persons, defined by <code>id</code>, which Check In at some <code>station</code> and some <code>time</code> and then Check Out from some other station at another time. We need to calculate times this person spend to go from one station to another and then calculate average time for all persons. Let us keep 3 pieces of information:</p><ol><li><code>self.ids</code> is dictionary, where for each person(id) we will keep pair <code>(station, time)</code> if the last action this person did is check In and empty if it was check OUt</li><li><code>self.pairs</code> is counter, where for each pair of stations we keep total time spend between two stations.</li><li><code>self.freqs</code> is counter, where for each pair of stations we keep how many trips we have between these two stations.</li></ol><p>Now, let us discuss, what our functions will do:</p><ol><li><code>checkIn(self, id, stationName, t)</code>: we just put pair <code>(stationName, t)</code> into <code>self.ids[id]</code>.</li><li><code>checkOut(self, id, stationName, t)</code>. Here we look at person <code>id</code>, extract information about his last station visited (pop it from <code>self.ids[id]</code> and update <code>self.pairs</code>, <code>self.freqs</code> for these pairs of stations.</li><li><code>getAverageTime(self, startStation, endStation)</code>: here we just look at dictionaries <code>self.pairs</code> and <code>self.freqs</code> and directly return result.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ids = &#123;&#125;</span><br><span class="line">        self.route = Counter()</span><br><span class="line">        self.freqs = Counter()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIn</span><span class="params">(self, id, startStation, t)</span>:</span></span><br><span class="line">        self.ids[id] = (startStation, t)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkOut</span><span class="params">(self, id, endStation, t)</span>:</span></span><br><span class="line">        startStation, t1 = self.ids.pop(id)</span><br><span class="line">        self.route[(startStation, endStation)] += t-t1</span><br><span class="line">        self.freqs[(startStation, endStation)] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAverageTime</span><span class="params">(self, startStation, endStation)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.route[startStation, endStation]/self.freqs[startStation, endStation]</span><br></pre></td></tr></table></figure><p>time complexity: $O(1)$ for all operation<br>space complexity: $O(Q)$, Q is total number of queries<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>953. Verifying an Alien Dictionary</title>
      <link href="/2021/05/11/953-Verifying-an-Alien-Dictionary/"/>
      <url>/2021/05/11/953-Verifying-an-Alien-Dictionary/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>In an alien language, surprisingly they also use english lowercase letters, but possibly in a different <code>order</code>. The <code>order</code> of the alphabet is some permutation of lowercase letters.</p><p>Given a sequence of <code>words</code> written in the alien language, and the <code>order</code> of the alphabet, return <code>true</code> if and only if the given <code>words</code> are sorted lexicographicaly in this alien language.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation:As &apos;h&apos; comes before &apos;l&apos; in this language, then the sequence is sorted.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation:As &apos;d&apos; comes after &apos;l&apos; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation:The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &apos;l&apos; &gt; &apos;∅&apos;, where &apos;∅&apos; is defined as the blank character which is less than any other character (More info).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 20</code></li><li><code>order.length == 26</code></li><li>All characters in <code>words[i]</code> and <code>order</code> are English lowercase letters.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Build a transform mapping from <code>order</code>,Find all alien words with letters in normal order.</p><p>For example, if we have <code>order = &quot;xyz...&quot;</code>We can map the word <code>&quot;xyz&quot;</code> to <code>&quot;abc&quot;</code> or <code>&quot;123&quot;</code></p><p>Then we check if all words are in sorted order.</p><p>For example,words = [“hello”,”leetcode”]order = “hlabcdefgijkmnopqrstuvwxyz”</p><ol><li>Create a dic, key is each word in new order, value is its index, which means its new position in the new order.</li><li>Transform the list of words into its index in new order.words = <code>[&quot;hello&quot;,&quot;leetcode&quot;] -&gt; [[0, 6, 1, 1, 14], [1, 6, 6, 19, 4, 14, 5, 6]]</code></li><li><code>zip()</code> will zip 2 element one by one,<code>zip(words, words[1:])</code> here will combine first element(words[0]) in words with words[1], so we can compare current element with next element: word[0]-&gt;word[1], word[1]-&gt;word[2]</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span><span class="params">(self, words: List[str], order: str)</span> -&gt; bool:</span></span><br><span class="line">        dic = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(order)&#125;</span><br><span class="line">        new_words = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            new = []</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> w:</span><br><span class="line">                new.append(dic[c])</span><br><span class="line">            new_words.append(new)</span><br><span class="line">        <span class="keyword">for</span> w1, w2 <span class="keyword">in</span> zip(new_words, new_words[<span class="number">1</span>:]):</span><br><span class="line">            <span class="keyword">if</span> w1 &gt; w2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(NS)$, N words, length = S<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>117. Populating Next Right Pointers in Each Node II</title>
      <link href="/2021/05/11/117-Populating-Next-Right-Pointers-in-Each-Node-II/"/>
      <url>/2021/05/11/117-Populating-Next-Right-Pointers-in-Each-Node-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Follow up:</strong></p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,null,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,7,#]</span><br><span class="line">Explanation:Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &apos;#&apos; signifying the end of each level.</span><br></pre></td></tr></table></figure><h3 id="Solution-BFS"><a href="#Solution-BFS" class="headerlink" title="Solution BFS:"></a>Solution BFS:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            next_level = deque([])</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> queue:</span><br><span class="line">                    node.next = queue[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> node.left: next_level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: next_level.append(node.right)</span><br><span class="line">            queue = next_level</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>116. Populating Next Right Pointers in Each Node</title>
      <link href="/2021/05/11/116-Populating-Next-Right-Pointers-in-Each-Node/"/>
      <url>/2021/05/11/116-Populating-Next-Right-Pointers-in-Each-Node/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Follow up:</strong></p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation:Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &apos;#&apos; signifying the end of each level.</span><br></pre></td></tr></table></figure><h3 id="Solution-BFS"><a href="#Solution-BFS" class="headerlink" title="Solution BFS:"></a>Solution BFS:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        res, queue = [], deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = len(queue)</span><br><span class="line">            next_level = deque([])</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(size):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> queue: </span><br><span class="line">                    node.next = queue[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> node.left: next_level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: next_level.append(node.right)</span><br><span class="line">            queue = next_level</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">```        </span><br><span class="line">        </span><br><span class="line"><span class="comment">## Solution DFS:</span></span><br><span class="line">We have `root.next` setup <span class="keyword">for</span> root node, so the `root.right.next` would be `root.next.left`.</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                root.left.next = root.right</span><br><span class="line">                <span class="keyword">if</span> root.next:</span><br><span class="line">                    root.right.next = root.next.left</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>122. Best Time to Buy and Sell Stock II</title>
      <link href="/2021/05/06/122-Best-Time-to-Buy-and-Sell-Stock-II/"/>
      <url>/2021/05/06/122-Best-Time-to-Buy-and-Sell-Stock-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p><p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class="line">Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e., max profit = 0.</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The profit is the sum of sub-profits. Each sub-profit is the difference between selling at day <code>j</code>, and buying at day <code>i</code> (with <code>j &gt; i</code>). The range <code>[i, j]</code> should be chosen so that the sub-profit is <strong>maximum</strong>:</p><p><code>sub-profit = prices[j] - prices[i]</code></p><p>We should choose <code>j</code> that <code>prices[j]</code> is as <strong>big</strong> as possible, and choose <code>i</code> that <code>prices[i]</code> is as <strong>small</strong> as possible (of course in their local range).</p><p>Let’s say, we have a range <code>[3, 2, 5]</code>, we will choose <code>(2,5)</code> instead of <code>(3,5)</code>, because <code>2&lt;3</code>.Now, if we add <code>8</code> into this range: <code>[3, 2, 5, 8]</code>, we will choose <code>(2, 8)</code> instead of <code>(2,5)</code> because <code>8&gt;5</code>.</p><p>From this observation, from day <code>X</code>, the buying day will be the last <strong>continuous</strong> day that the price is smallest. Then, the selling day will be the last <strong>continuous</strong> day that the price is biggest.</p><p>Take another range <code>[3, 2, 5, 8, 1, 9]</code>, though <code>1</code> is the smallest, but <code>2</code> is chosen, because <code>2</code> is the smallest in a consecutive decreasing prices starting from <code>3</code>.Similarly, <code>9</code> is the biggest, but <code>8</code> is chosen, because <code>8</code> is the biggest in a consecutive increasing prices starting from <code>2</code> (the buying price).Actually, the range <code>[3, 2, 5, 8, 1, 9]</code> will be splitted into 2 sub-ranges <code>[3, 2, 5, 8]</code> and <code>[1, 9]</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        buy, sell = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        i, N = <span class="number">0</span>, len(prices)<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; N:</span><br><span class="line">            <span class="keyword">while</span> i &lt; N <span class="keyword">and</span> prices[i+<span class="number">1</span>] &lt;= prices[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            buy = prices[i]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> i &lt; N <span class="keyword">and</span> prices[i+<span class="number">1</span>] &gt; prices[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            sell = prices[i]</span><br><span class="line">            res += sell-buy</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> array </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>863. All Nodes Distance K in Binary Tree</title>
      <link href="/2021/05/04/863-All-Nodes-Distance-K-in-Binary-Tree/"/>
      <url>/2021/05/04/863-All-Nodes-Distance-K-in-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>We are given a binary tree (with root node <code>root</code>), a <code>target</code> node, and an integer value <code>K</code>.</p><p>Return a list of the values of all nodes that have a distance <code>K</code> from the <code>target</code> node.  The answer can be returned in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2</span><br><span class="line"></span><br><span class="line">Output:[7,4,1]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The nodes that are a distance 2 from the target node (with value 5)</span><br><span class="line">have values 7, 4, and 1.</span><br><span class="line"></span><br><span class="line">Note that the inputs &quot;root&quot; and &quot;target&quot; are actually TreeNodes.</span><br><span class="line">The descriptions of the inputs above are just serializations of these objects.</span><br></pre></td></tr></table></figure><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png"></p><p><strong>Note:</strong></p><ol><li>The given tree is non-empty.</li><li>Each node in the tree has unique values <code>0 &lt;= node.val &lt;= 500</code>.</li><li>The <code>target</code> node is a node in the tree.</li><li><code>0 &lt;= K &lt;= 1000</code>.</li></ol><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We don’t know the relation from <code>target</code> to node on top of it or on the other side of tree. So we construct a new graph from tree. </p><ol><li>DFS, Build graph that each node knows its parent and child</li><li>BFS, find level by level</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distanceK</span><span class="params">(self, root: TreeNode, target: TreeNode, K: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># build graph from tree</span></span><br><span class="line">        graph = defaultdict(list)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">buildGraph</span><span class="params">(parent, child)</span>:</span>     </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> child:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> parent: graph[child].append(parent)</span><br><span class="line">            <span class="keyword">if</span> child.left: </span><br><span class="line">                graph[child].append(child.left)</span><br><span class="line">                buildGraph(child, child.left)</span><br><span class="line">            <span class="keyword">if</span> child.right: </span><br><span class="line">                graph[child].append(child.right)</span><br><span class="line">                buildGraph(child, child.right)</span><br><span class="line">        </span><br><span class="line">        buildGraph(<span class="keyword">None</span>, root)</span><br><span class="line">        </span><br><span class="line">        res, queue, visited = [], deque(), set()</span><br><span class="line">        queue.append((target, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># BFS, find distant K nodes</span></span><br><span class="line">            node, dis = queue.popleft()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># base case, if this node visited, skip</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="keyword">if</span> dis == K:</span><br><span class="line">                res.append(node.val)   </span><br><span class="line">            <span class="keyword">elif</span> dis &lt; K: <span class="comment"># keep finding distance longer nodes</span></span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">                    queue.append((neighbor, dis+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1448. Count Good Nodes in Binary Tree</title>
      <link href="/2021/05/03/1448-Count-Good-Nodes-in-Binary-Tree/"/>
      <url>/2021/05/03/1448-Count-Good-Nodes-in-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.</p><p>Return the number of good nodes in the binary tree.</p><p>Example 1:</p><p><img src="1.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,1,4,3,null,1,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Nodes in blue are good.</span><br><span class="line">Root Node (3) is always a good node.</span><br><span class="line">Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.</span><br><span class="line">Node 5 -&gt; (3,4,5) is the maximum value in the path</span><br><span class="line">Node 3 -&gt; (3,1,3) is the maximum value in the path.</span><br></pre></td></tr></table></figure></p><p>Example 2:</p><p><img src="2.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,3,null,4,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Node 2 -&gt; (3, 3, 2) is not good, because &quot;3&quot; is higher than it.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: Root is considered as good.</span><br></pre></td></tr></table></figure></p><p>Constraints:</p><p>The number of nodes in the binary tree is in the range <code>[1, 10^5]</code>.<br>Each node’s value is between <code>[-10^4, 10^4]</code>.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Update the maximum value found while recursive down to the paths from root to leaves;<br>If node <code>value &gt;= current maximum</code>, count it in.<br>return the total number after the completion of all recursions.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(root, cur_max)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            mx = max(cur_max, root.val)</span><br><span class="line">            <span class="keyword">return</span> (root.val &gt;= cur_max) + count(root.left, mx) + count(root.right, mx)</span><br><span class="line">        <span class="keyword">return</span> count(root, <span class="number">-10000</span>)</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(height)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>394. Decode String</title>
      <link href="/2021/04/30/394-Decode-String/"/>
      <url>/2021/04/30/394-Decode-String/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an encoded string, return its decoded string.</p><p>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p><p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>. </p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;3[a2[c]]&quot;</span><br><span class="line">Output: &quot;accaccacc&quot;</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">Output: &quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure></p><p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abc3[cd]xyz&quot;</span><br><span class="line">Output: &quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Stack:<br>Thought process is to divide the case into <code>digit</code>, <code>character</code>, <code>[</code>, <code>]</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># stack</span></span><br><span class="line">        <span class="comment"># 4 cases in the string</span></span><br><span class="line">        <span class="comment"># digit, character, '[', ']'</span></span><br><span class="line">        stack, cur_string, cur_num = [], <span class="string">""</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                cur_num = cur_num*<span class="number">10</span> + int(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'['</span>:</span><br><span class="line">                <span class="comment"># means we have cur_num and cur_string exist </span></span><br><span class="line">                <span class="comment"># put them into stack </span></span><br><span class="line">                stack.append(cur_string)</span><br><span class="line">                stack.append(cur_num)</span><br><span class="line">                cur_string, cur_num = <span class="string">""</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">']'</span>:</span><br><span class="line">                repeat = stack.pop()</span><br><span class="line">                prev_string = stack.pop()</span><br><span class="line">                cur_string = prev_string + repeat*cur_string</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                cur_string += c</span><br><span class="line">        <span class="keyword">return</span> cur_string</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p><h2 id="Solution-DFS"><a href="#Solution-DFS" class="headerlink" title="Solution DFS:"></a>Solution DFS:</h2><ol><li>The dfs should return a string</li><li>Since the format is always valid, we expect the brackets always comes after numbers</li><li>if <code>s[i]</code> is not number, then just append character to current level result</li><li>if <code>s[i]</code> is number, calculate the number first. Then get the string inside bracket.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(s, i)</span>:</span></span><br><span class="line">            res = <span class="string">""</span></span><br><span class="line">            <span class="keyword">while</span> self.i &lt; len(s) <span class="keyword">and</span> s[self.i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> s[self.i].isdigit():</span><br><span class="line">                    res += s[self.i]</span><br><span class="line">                    self.i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># is digit, so find out number of repeat first</span></span><br><span class="line">                    n = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> s[self.i].isdigit():</span><br><span class="line">                        n = n*<span class="number">10</span> + int(s[self.i])</span><br><span class="line">                        self.i += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># the format is always valid</span></span><br><span class="line">                    <span class="comment"># ie: brackets would always come after numbers</span></span><br><span class="line">                    self.i += <span class="number">1</span> <span class="comment"># '['</span></span><br><span class="line">                    tmp = dfs(s, self.i)</span><br><span class="line">                    self.i += <span class="number">1</span> <span class="comment"># ']'</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">while</span> n:</span><br><span class="line">                        res += tmp</span><br><span class="line">                        n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(s, self.i)</span><br></pre></td></tr></table></figure><p>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>695. Max Area of Island</title>
      <link href="/2021/04/30/695-Max-Area-of-Island/"/>
      <url>/2021/04/30/695-Max-Area-of-Island/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p><p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure></p><p>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.<br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br></pre></td></tr></table></figure></p><p>Given the above grid, return 0.<br>Note: The length of each dimension in the given grid does not exceed 50.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Regular DFS. We return the area for each dfs rotation</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># DFS to find the area of each island</span></span><br><span class="line">        <span class="comment"># global variable to find max area across the grid</span></span><br><span class="line">        row, col, res = len(grid), len(grid[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; row <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; col <span class="keyword">and</span> grid[i][j]:</span><br><span class="line">                grid[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + dfs(i+<span class="number">1</span>, j) + dfs(i<span class="number">-1</span>, j) + dfs(i, j+<span class="number">1</span>) + dfs(i, j<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    res = max(res, dfs(i, j))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>BFS<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        row, col, res = len(grid), len(grid[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">        direction = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># use queue to BFS</span></span><br><span class="line">                    queue = collections.deque([])</span><br><span class="line">                    queue.append((i, j))</span><br><span class="line">                    grid[i][j] = <span class="number">0</span></span><br><span class="line">                    area = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> queue:</span><br><span class="line">                        r, c = queue.popleft()</span><br><span class="line">                        <span class="keyword">for</span> d <span class="keyword">in</span> direction:</span><br><span class="line">                            dr, dc = r+ d[<span class="number">0</span>], c + d[<span class="number">1</span>]</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span> &lt;= dr &lt; row <span class="keyword">and</span> <span class="number">0</span> &lt;= dc &lt; col <span class="keyword">and</span> grid[dr][dc]:</span><br><span class="line">                                area += <span class="number">1</span></span><br><span class="line">                                grid[dr][dc] = <span class="number">0</span></span><br><span class="line">                                queue.append((dr, dc))</span><br><span class="line">                    res = max(res, area)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>981. Time Based Key-Value Store</title>
      <link href="/2021/04/28/981-Time-Based-Key-Value-Store/"/>
      <url>/2021/04/28/981-Time-Based-Key-Value-Store/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Create a timebased key-value store class <code>TimeMap</code>, that supports two operations.</p><ol><li><code>set(string key, string value, int timestamp)</code></li></ol><ul><li>Stores the <code>key</code> and <code>value</code>, along with the given <code>timestamp</code>.</li></ul><ol start="2"><li><code>get(string key, int timestamp)</code></li></ol><ul><li>Returns a value such that <code>set(key, value, timestamp_prev)</code> was called previously, with <code>timestamp_prev &lt;= timestamp</code>.</li><li>If there are multiple such values, it returns the one with the largest <code>timestamp_prev</code>.</li><li>If there are no values, it returns the empty string (<code>&quot;&quot;</code>).</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]</span><br><span class="line">Output:[null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]</span><br><span class="line">Explanation:</span><br><span class="line">TimeMap kv;</span><br><span class="line">kv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // store the key &quot;foo&quot; and value &quot;bar&quot; along with timestamp = 1</span><br><span class="line">kv.get(&quot;foo&quot;, 1);  // output &quot;bar&quot;</span><br><span class="line">kv.get(&quot;foo&quot;, 3); // output &quot;bar&quot; since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie &quot;bar&quot;</span><br><span class="line">kv.set(&quot;foo&quot;, &quot;bar2&quot;, 4);</span><br><span class="line">kv.get(&quot;foo&quot;, 4); // output &quot;bar2&quot;</span><br><span class="line">kv.get(&quot;foo&quot;, 5); //output &quot;bar2&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;love&quot;,&quot;high&quot;,10],[&quot;love&quot;,&quot;low&quot;,20],[&quot;love&quot;,5],[&quot;love&quot;,10],[&quot;love&quot;,15],[&quot;love&quot;,20],[&quot;love&quot;,25]]</span><br><span class="line">Output:[null,null,null,&quot;&quot;,&quot;high&quot;,&quot;high&quot;,&quot;low&quot;,&quot;low&quot;]</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>All key/value strings are lowercase.</li><li>All key/value strings have length in the range <code>[1, 100]</code></li><li>The <code>timestamps</code> for all <code>TimeMap.set</code> operations are strictly increasing.</li><li><code>1 &lt;= timestamp &lt;= 10^7</code></li><li><code>TimeMap.set</code> and <code>TimeMap.get</code> functions will be called a total of <code>120000</code> times (combined) per test case.</li></ol><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>For this kind of key-value pair, using dictionary would help us find item in shortest time.<br>However, this question have several timestamp we need to consider. We could use a list to store all the <code>timestamp-value</code>. </p><ul><li>Notice in Note 3, the timestamp is strictly increasing. So we don’t have to sort the element in list before searching</li></ul><p>In <code>get()</code>, we could use <code>bisect_right</code> or write own binary search to find the value that is greater than <code>timestamp</code>. The reason we’re finding <code>greater</code> than <code>timestamp</code> is because we use <code>right</code> as boundary, then we could return <code>nums[right-1]</code> as it’s the value that smaller than <code>timestamp</code> but closest to <code>timestamp</code>.</p><p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums: [5,10,15,20,25], timestamp: 8</span><br><span class="line">at the last round, right would be idx:1, nums[1] = 10</span><br><span class="line">then we return nums[right-1] = nums[0], as it&apos;s the one smaller than 8 but fulfilled timestamp_prev &lt;= timestamp.</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.dic = defaultdict(list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key: str, value: str, timestamp: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.dic[key].append([timestamp, value])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: str, timestamp: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.dic:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        arr = self.dic[key]</span><br><span class="line">        left, right = <span class="number">0</span>, len(arr)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left+ right) //<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> arr[mid][<span class="number">0</span>] &gt; timestamp:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> right == <span class="number">0</span> <span class="keyword">else</span> arr[right<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your TimeMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = TimeMap()</span></span><br><span class="line"><span class="comment"># obj.set(key,value,timestamp)</span></span><br><span class="line"><span class="comment"># param_2 = obj.get(key,timestamp)</span></span><br></pre></td></tr></table></figure><p>time complexity: </p><ul><li>set(): $O(1)$ for single operation, $O(n)$ for total. Note: assuming timestamps are only increasing. If not, it’s $O(n log n)$.</li><li>get(): $O(logn)$, <code>n</code> is length of list in <code>nums[key]</code>, and total O(m log n), <code>m</code> is number of <code>get()</code> request.<br>space complexity: $O(n)$<br>reference:<br>related problem:</li></ul>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>973. K Closest Points to Origin</title>
      <link href="/2021/04/27/973-K-Closest-Points-to-Origin/"/>
      <url>/2021/04/27/973-K-Closest-Points-to-Origin/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of <code>points</code> where <code>points[i] = [xi, yi]</code> represents a point on the <strong>X-Y</strong> plane and an integer <code>k</code>, return the <code>k</code> closest points to the origin <code>(0, 0)</code>.</p><p>The distance between two points on the <strong>X-Y</strong> plane is the Euclidean distance (i.e., $√(x1 - x2)^2 + (y1 - y2)^2$).</p><p>You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).</p><p>Example 1:<br><img src="1.jpeg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[1,3],[-2,2]], k = 1</span><br><span class="line">Output: [[-2,2]]</span><br><span class="line">Explanation:</span><br><span class="line">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class="line">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class="line">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class="line">We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[3,3],[5,-1],[-2,4]], k = 2</span><br><span class="line">Output: [[3,3],[-2,4]]</span><br><span class="line">Explanation: The answer [[-2,4],[3,3]] would also be accepted.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a heap to solve it.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span><span class="params">(self, points: List[List[int]], k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        hq = []</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">            dis = point[<span class="number">0</span>] **<span class="number">2</span> + point[<span class="number">1</span>]**<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> len(hq) &lt; k:</span><br><span class="line">                <span class="comment"># Since python is min-heap, pop() would return the smallest element</span></span><br><span class="line">                <span class="comment"># if pointA distance to origin is 10, pointB distance to origin is 8</span></span><br><span class="line">                <span class="comment"># -10 would be pop out </span></span><br><span class="line">                heapq.heappush(hq, (-dis, point))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappushpop(hq, (-dis, point))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [point <span class="keyword">for</span> (dist, point) <span class="keyword">in</span> hq]</span><br></pre></td></tr></table></figure></p><p>time complexity: $O(nlogk)$, only k element in heap, push n times<br>space complexity: $O(n)$, heap size<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> sort </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note-System design</title>
      <link href="/2021/04/26/note-System-design/"/>
      <url>/2021/04/26/note-System-design/</url>
      <content type="html"><![CDATA[<p>CAP:</p><ul><li><code>Consistency</code>: Assuming you have a storage system which has more than one machine, consistency implies that the data is same across the cluster, so you can read or write to/from any node and get the same data.<ul><li>Eventual consistency : Exactly what the name suggests. In a cluster, if multiple machines store the same data, an eventual consistent model implies that all machines will have the same data eventually. Its possible that at a given instance, those machines have different versions of the same data ( temporarily inconsistent ) but they will eventually reach a state where they have the same data.</li></ul></li><li><code>Availability</code>: In the context of a database cluster, Availability refers to the ability to always respond to queries ( read or write ) irrespective of nodes going down.</li><li><code>Partition Tolerance</code>: In the context of a database cluster, cluster continues to function even if there is a “partition” (communications break) between two nodes (both nodes are up, but can’t communicate).</li></ul><p><a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem" target="_blank" rel="noopener">http://ksat.me/a-plain-english-introduction-to-cap-theorem</a></p><p>Scaling:</p><ul><li><code>Vertical scaling</code>:<br>Improving the capabilities of a node/server. Gives greater capacity to the node but does not decrease the overall load on existing members of the cluster. That is, the ability for the improved node to handle existing load is increased, but the load itself is unchanged. Reasons to scale vertically include increasing IOPS, increasing CPU/RAM capacity, and increasing disk capacity.</li><li><code>Horizontal Scaling</code><br>Increasing the number of nodes in the cluster. reduces the responsibilities of each member node by spreading the keyspace wider and providing additional endpoints for client connections. That is, the capacity of each individual node does not change, but its load is decreased. Reasons to scale horizontally include increasing I/O concurrency, reducing the load on existing nodes, and increasing disk capacity.</li></ul><p><code>Sharding</code>: With most huge systems, data does not fit on a single machine. In such cases, sharding refers to splitting the very large database into smaller, faster and more manageable parts called data shards.</p><p>Questions:<br>Since we will be storing a massive amount of data, how should we partition our data to distribute it to multiple databases? Should we try to store all the data of a user on the same database? What issue could it cause?<br>How will we handle hot users who tweet a lot or follow lots of people?<br>Since users’ timeline will contain the most recent (and relevant) tweets, should we try to store our data so that it is optimized for scanning the latest tweets?<br>How much and at which layer should we introduce cache to speed things up?<br>What components need better load balancing?<br>Is there any single point of failure in our system? What are we doing to mitigate it?<br>Do we have enough replicas of the data so that we can still serve our users if we lose a few servers?<br>Similarly, do we have enough copies of different services running such that a few failures will not cause a total system shutdown?<br>How are we monitoring the performance of our service? Do we get alerts whenever critical components fail or their performance degrades?</p><p>Estimation on Capacity:<br>Our system will be read-heavy. There will be lots of redirection requests compared to new URL shortenings. Let’s assume a 100:1 ratio between read and write.</p><p><strong>Traffic estimates</strong>: Assuming, we will have 500M new URL shortenings per month, with 100:1 read/write ratio, we can expect 50B redirections during the same period:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 * 500M =&gt; 50B</span><br></pre></td></tr></table></figure><p>What would be Queries Per Second (QPS) for our system? New URLs shortenings per second:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500 million / (30 days * 24 hours * 3600 seconds) = ~200 URLs/s</span><br></pre></td></tr></table></figure></p><p>Considering 100:1 read/write ratio, URLs redirections per second will be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 * 200 URLs/s = 20K/s</span><br></pre></td></tr></table></figure><p><strong>Storage estimates</strong>: Let’s assume we store every URL shortening request (and associated shortened link) for 5 years. Since we expect to have 500M new URLs every month, the total number of objects we expect to store will be 30 billion:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500 million * 5 years * 12 months = 30 billion</span><br></pre></td></tr></table></figure></p><p>Let’s assume that each stored object will be approximately 500 bytes (just a ballpark estimate–we will dig into it later). We will need 15TB of total storage:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 billion * 500 bytes = 15 TB</span><br></pre></td></tr></table></figure></p><p><strong>Bandwidth estimates</strong>: For write requests, since we expect 200 new URLs every second, total incoming data for our service will be 100KB per second:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 * 500 bytes = 100 KB/s</span><br></pre></td></tr></table></figure></p><p>For read requests, since every second we expect ~20K URLs redirections, total outgoing data for our service would be 10MB per second:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20K * 500 bytes = ~10 MB/s</span><br></pre></td></tr></table></figure></p><p><strong>Memory estimates</strong>: If we want to cache some of the hot URLs that are frequently accessed, how much memory will we need to store them? If we follow the 80-20 rule, meaning 20% of URLs generate 80% of traffic, we would like to cache these 20% hot URLs.</p><p>Since we have 20K requests per second, we will be getting 1.7 billion requests per day:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20K * 3600 seconds * 24 hours = ~1.7 billion</span><br></pre></td></tr></table></figure></p><p>To cache 20% of these requests, we will need 170GB of memory.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.2 * 1.7 billion * 500 bytes = ~170GB</span><br></pre></td></tr></table></figure></p><p>One thing to note here is that since there will be many duplicate requests (of the same URL), our actual memory usage will be less than 170GB.</p><h2 id="Redis-vs-Memchached"><a href="#Redis-vs-Memchached" class="headerlink" title="Redis vs Memchached"></a>Redis vs Memchached</h2><p>Memchached: </p><ul><li>preferable when caching relatively small and static data</li><li>Easy to scale, it’s multi-threaded. While Redis is single-threaded, could horizontally via clustering, but clustering relatively hard to setup.</li></ul><p>Redis<br><a href="https://www.linkedin.com/pulse/memcached-vs-redis-which-one-pick-ranjeet-vimal/" target="_blank" rel="noopener">https://www.linkedin.com/pulse/memcached-vs-redis-which-one-pick-ranjeet-vimal/</a></p><h2 id="General-solution-for-design-quesions"><a href="#General-solution-for-design-quesions" class="headerlink" title="General solution for design quesions:"></a>General solution for design quesions:</h2><p><a href="https://github.com/linlaw0229/system-design-primer/blob/master/README.md#system-design-interview-questions-with-solutions" target="_blank" rel="noopener">https://github.com/linlaw0229/system-design-primer/blob/master/README.md#system-design-interview-questions-with-solutions</a></p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> system design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>355. Design Twitter</title>
      <link href="/2021/04/24/355-Design-Twitter/"/>
      <url>/2021/04/24/355-Design-Twitter/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user’s news feed.</p><p>Implement the Twitter class:</p><ul><li>Twitter() Initializes your twitter object.</li><li><code>void postTweet(int userId, int tweetId)</code> Composes a new tweet with ID <code>tweetId</code> by the user userId. Each call to this function will be made with a unique <code>tweetId</code>.</li><li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code> Retrieves the 10 most recent tweet IDs in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.</li><li><code>void follow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started following the user with ID <code>followeeId</code>.</li><li><code>void unfollow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started unfollowing the user with ID <code>followeeId</code>.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>I use a dict of (int, deque) to save tweets each user has posted and another dict to point to the users he’s following. Deque can be used because only the most recent tweets matter to us in this system.  </p><p>I use a post counter as a time stamp to track most recent.<br>When getNewsFeed is called, I build a min heap of all the tweets of the user first. Then iterate over all the users he follows.<br>For each other user a user follows, I iterate over all of his tweets from last to first since tweets array will be sorted by default, and if current element if greater than root of min heap, then I do a push if heap’s not full or if it’s full, I do a pushpop.<br>Since, we only need 10 tweets and each person can at max have only 10 tweets. All the heap operatons can be considered constant.<br>Hence, the time complexity is O(Number of people a user follows).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># use a map to store the follower, set as container because follower shouldn't duplicate</span></span><br><span class="line">        self.following = defaultdict(set)</span><br><span class="line">        self.user_tweets = defaultdict(deque)</span><br><span class="line">        self.post = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postTweet</span><span class="params">(self, userId: int, tweetId: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Compose a new tweet.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.post += <span class="number">1</span></span><br><span class="line">        tweets = self.user_tweets[userId]</span><br><span class="line">        tweets.append(((self.post), tweetId))</span><br><span class="line">        <span class="keyword">if</span> len(tweets) &gt; <span class="number">10</span>:</span><br><span class="line">            tweets.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNewsFeed</span><span class="params">(self, userId: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        h = []</span><br><span class="line">        u = self.user_tweets[userId]</span><br><span class="line">        h.extend(u)</span><br><span class="line">        heapify(h)</span><br><span class="line">        <span class="keyword">for</span> user <span class="keyword">in</span> self.following[userId]:</span><br><span class="line">            tweets = self.user_tweets[user]</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(len(tweets) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> len(h) &lt; <span class="number">10</span>:</span><br><span class="line">                    heappush(h, tweets[x])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> h[<span class="number">0</span>][<span class="number">0</span>] &lt; tweets[x][<span class="number">0</span>]:</span><br><span class="line">                        heappushpop(h, tweets[x])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> [heappop(h)[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> range(len(h))][::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">follow</span><span class="params">(self, followerId, followeeId)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Follower follows a followee. If the operation is invalid, it should be a no-op.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> followerId != followeeId:</span><br><span class="line">            self.following[followerId].add(followeeId)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unfollow</span><span class="params">(self, followerId, followeeId)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Follower unfollows a followee. If the operation is invalid, it should be a no-op.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> followerId != followeeId:</span><br><span class="line">                self.following[followerId].discard(followeeId)</span><br><span class="line"><span class="comment"># Your Twitter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Twitter()</span></span><br><span class="line"><span class="comment"># obj.postTweet(userId,tweetId)</span></span><br><span class="line"><span class="comment"># param_2 = obj.getNewsFeed(userId)</span></span><br><span class="line"><span class="comment"># obj.follow(followerId,followeeId)</span></span><br><span class="line"><span class="comment"># obj.unfollow(followerId,followeeId)</span></span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> design </tag>
            
            <tag> heap </tag>
            
            <tag> has table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note-Python</title>
      <link href="/2021/04/24/note-Python/"/>
      <url>/2021/04/24/note-Python/</url>
      <content type="html"><![CDATA[<ul><li><p>extend vs append<br>We see that extend is semantically clearer, and that it can run much faster than append, when you intend to append each element in an iterable to a list.</p><p>If you only have a single element (not in an iterable) to add to the list, use append.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(timeit.repeat(<span class="keyword">lambda</span>: append([], <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>)))</span><br><span class="line"><span class="number">2.867846965789795</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(timeit.repeat(<span class="keyword">lambda</span>: extend([], <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>)))</span><br><span class="line"><span class="number">0.8060121536254883</span></span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/a/28119966/5133816" target="_blank" rel="noopener">https://stackoverflow.com/a/28119966/5133816</a></p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>145. Binary Tree Postorder Traversal</title>
      <link href="/2021/04/21/145-Binary-Tree-Postorder-Traversal/"/>
      <url>/2021/04/21/145-Binary-Tree-Postorder-Traversal/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the root of a binary tree, return the postorder traversal of its nodes’ values.</p><p>Input: root = [1,null,2,3]<br>Output: [3,2,1]</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We could use iterative and recursive to solve this question. Recursive it straight-forward, so I’ll just write the iterative one.</p><p>The idea is to notice each node would be visit twice when it needs to be print out. First time when the node is pass by parent, second time is when the node passing it’s child into stack. When the node got visited twice(marked as <code>True</code>), we could print it out. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stk, res = deque([(root, <span class="keyword">False</span>)]), []</span><br><span class="line">        <span class="keyword">while</span> stk:</span><br><span class="line">            node, visited = stk.pop()</span><br><span class="line">            <span class="keyword">if</span> visited:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># LIFO so append left last</span></span><br><span class="line">                stk.append((node, <span class="keyword">True</span>))</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stk.append((node.right, <span class="keyword">False</span>))</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stk.append((node.left, <span class="keyword">False</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy medium hard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>144. Binary Tree Preorder Traversal</title>
      <link href="/2021/04/21/144-Binary-Tree-Preorder-Traversal/"/>
      <url>/2021/04/21/144-Binary-Tree-Preorder-Traversal/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy medium hard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>47. Permutations II</title>
      <link href="/2021/04/15/47-Permutations-II/"/>
      <url>/2021/04/15/47-Permutations-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. </p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_permute</span><span class="params">(self, nums, s, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == k:</span><br><span class="line">            print(<span class="string">"---"</span>)</span><br><span class="line">            self.permutations.append(s[:])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            s.append(nums[i])</span><br><span class="line">            print(s)</span><br><span class="line">            self._permute(nums[:i] + nums[i+<span class="number">1</span>:], s, k) <span class="comment"># remove nums[i] from nums</span></span><br><span class="line">            s.pop()</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        self.permutations = []</span><br><span class="line">        self._permute(sorted(nums), [], len(nums))</span><br><span class="line">        <span class="keyword">return</span> self.permutations</span><br></pre></td></tr></table></figure><p>output of the code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[1]</span><br><span class="line">[1, 1]</span><br><span class="line">[1, 1, 1]</span><br><span class="line">[1, 1, 1, 2]</span><br><span class="line">---</span><br><span class="line">[1, 1, 2]</span><br><span class="line">[1, 1, 2, 1]</span><br><span class="line">---</span><br><span class="line">[1, 2]</span><br><span class="line">[1, 2, 1]</span><br><span class="line">[1, 2, 1, 1]</span><br><span class="line">---</span><br><span class="line">[2]</span><br><span class="line">[2, 1]</span><br><span class="line">[2, 1, 1]</span><br><span class="line">[2, 1, 1, 1]</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>141. Linked List Cycle</title>
      <link href="/2021/04/09/141-Linked-List-Cycle/"/>
      <url>/2021/04/09/141-Linked-List-Cycle/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p><p>Return true if there is a cycle in the linked list. Otherwise, return false.</p><p>Example 1:<br><img src="1.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><img src="2.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><img src="3.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1], pos = -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two pointers, <code>slow</code> walk one step each time, <code>fast</code> walk 2 steps each time. If there’s a cycle, then they’ll meet somewhere.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> two pointers </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>94. Binary Tree Inorder Traversal</title>
      <link href="/2021/04/08/94-Binary-Tree-Inorder-Traversal/"/>
      <url>/2021/04/08/94-Binary-Tree-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the root of a binary tree, return the inorder traversal of its nodes’ values.<br>Example 1:</p><p><img src="1.jpeg" alt=""><br>Input: root = [1,null,2,3]<br>Output: [1,3,2]</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stk = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stk.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stk:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            top = stk.pop()</span><br><span class="line">            res.append(top.val)</span><br><span class="line">            root = top.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        if not root:</span></span><br><span class="line"><span class="string">            return []</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        def traverse(root, res):</span></span><br><span class="line"><span class="string">            if not root:</span></span><br><span class="line"><span class="string">                return None</span></span><br><span class="line"><span class="string">            traverse(root.left, res)</span></span><br><span class="line"><span class="string">            res.append(root.val)</span></span><br><span class="line"><span class="string">            traverse(root.right, res)</span></span><br><span class="line"><span class="string">        res = []</span></span><br><span class="line"><span class="string">        traverse(root, res)</span></span><br><span class="line"><span class="string">        return res</span></span><br><span class="line"><span class="string">        '''</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>142. Linked List Cycle II</title>
      <link href="/2021/04/06/142-Linked-List-Cycle-II/"/>
      <url>/2021/04/06/142-Linked-List-Cycle-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p><p>Notice that you should not modify the linked list.</p><p>Example 1:<br><img src="1.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure></p><p>Example 2:</p><p><img src="2.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2], pos = 0</span><br><span class="line">Output: tail connects to node index 0</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the first node.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>Check if there’s a cycle. If no, return None. If yes, step 2</li><li></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L1: distance between the head point and entry point, H</span><br><span class="line">L2: distance from E to X</span><br><span class="line">C: cycle length</span><br><span class="line">                  _____</span><br><span class="line">                 /     \</span><br><span class="line">head_____H______E       \</span><br><span class="line">                \       /</span><br><span class="line">                 X_____/</span><br></pre></td></tr></table></figure><p>Since <code>fast = 2 * slow</code>. When they first meet at <code>X</code>.</p><p>slow pointer traveled when encounter is <code>L1 + L2</code></p><p>fast pointer traveled when encounter is <code>L1 + L2 + n * C</code></p><p>Because the total distance the fast pointer traveled is twice as the slow pointer, Thus:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 * (L1+L2) = L1 + L2 + n * C =&gt; L1 + L2 = n * C =&gt; L1 = (n - 1) C + (C - L2)*</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                slow = head</span><br><span class="line">                <span class="keyword">while</span> fast != slow:</span><br><span class="line">                    fast = fast.next</span><br><span class="line">                    slow = slow.next</span><br><span class="line">                <span class="keyword">return</span> fast</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://leetcode.com/problems/linked-list-cycle-ii/discuss/44781/Concise-O(n)-solution-by-using-C%2B%2B-with-Detailed-Alogrithm-Description" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/discuss/44781/Concise-O(n)-solution-by-using-C%2B%2B-with-Detailed-Alogrithm-Description</a><br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy medium hard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>92. Reverse Linked List II</title>
      <link href="/2021/04/04/92-Reverse-Linked-List-II/"/>
      <url>/2021/04/04/92-Reverse-Linked-List-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.</p><p>Example 1:<br><img src="1.jpeg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">Output: [1,4,3,2,5]</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [5], left = 1, right = 1</span><br><span class="line">Output: [5]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p><img src="2.jpeg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, left: int, right: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy, dummy.next = ListNode(<span class="number">0</span>), head</span><br><span class="line">        p = dummy</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(left<span class="number">-1</span>):</span><br><span class="line">            p = p.next</span><br><span class="line">        tail = p.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(right-left):</span><br><span class="line">            tmp = p.next                  <span class="comment"># a)</span></span><br><span class="line">            p.next = tail.next            <span class="comment"># b)</span></span><br><span class="line">            tail.next = tail.next.next    <span class="comment"># c)</span></span><br><span class="line">            p.next.next = tmp             <span class="comment"># d)</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
          <category> linked list </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>86. Partition List</title>
      <link href="/2021/04/04/86-Partition-List/"/>
      <url>/2021/04/04/86-Partition-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p>Example 1:<br><img src="1.jpeg" alt=""></p><p>Input: head = [1,4,3,2,5,2], x = 3<br>Output: [1,2,2,4,3,5]<br>Example 2:</p><p>Input: head = [2,1], x = 2<br>Output: [1,2]</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        l1 = h1 = ListNode(<span class="number">0</span>)</span><br><span class="line">        l2 = h2 = ListNode(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                l1.next = head</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l2.next = head</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            head = head.next</span><br><span class="line">        l1.next = h2.next</span><br><span class="line">        l2.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> h1.next</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy medium hard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>82. Remove Duplicates from Sorted List II</title>
      <link href="/2021/04/03/82-Remove-Duplicates-from-Sorted-List-II/"/>
      <url>/2021/04/03/82-Remove-Duplicates-from-Sorted-List-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.</p><p>Example 1:<br><img src="1.jpeg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,3,3,4,4,5]</span><br><span class="line">Output: [1,2,5]</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><img src="2.jpeg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,1,1,2,3]</span><br><span class="line">Output: [2,3]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        fast, slow = head, dummy</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            <span class="keyword">if</span> fast.val == fast.next.val:</span><br><span class="line">                <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next <span class="keyword">and</span> slow.next.val == fast.next.val:</span><br><span class="line">                    fast = fast.next</span><br><span class="line">            </span><br><span class="line">                slow.next = fast.next</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow = slow.next</span><br><span class="line">            fast = fast.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>61. Rotate List</title>
      <link href="/2021/04/02/61-Rotate-List/"/>
      <url>/2021/04/02/61-Rotate-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the head of a linked list, rotate the list to the right by k places.</p><p>Example 1:</p><p><img src="1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], k = 2</span><br><span class="line">Output: [4,5,1,2,3]</span><br></pre></td></tr></table></figure><p>Example 2:</p><p><img src="2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [0,1,2], k = 4</span><br><span class="line">Output: [2,0,1]</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Identify that <code>k</code> might be greater than list size. We need to <code>%</code> to get how many rotation we should do.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        size = <span class="number">0</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next, p = head, dummy</span><br><span class="line">        <span class="keyword">while</span> p.next:</span><br><span class="line">            p, size = p.next, size+<span class="number">1</span></span><br><span class="line">        k %= size</span><br><span class="line">        step, mid = size - k, dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(step):</span><br><span class="line">            mid = mid.next</span><br><span class="line">        p.next = dummy.next</span><br><span class="line">        dummy.next = mid.next</span><br><span class="line">        mid.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy medium hard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/2021/04/01/234-Palindrome-Linked-List/"/>
      <url>/2021/04/01/234-Palindrome-Linked-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the head of a singly linked list, return true if it is a palindrome.</p><p>Example 1:</p><p><img src="1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Example 2:</p><p><img src="2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="comment"># rev records the first half, need to set the same structure as fast, slow, hence later we have rev.next</span></span><br><span class="line">    rev = <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># initially slow and fast are the same, starting from head</span></span><br><span class="line">    slow = fast = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        <span class="comment"># fast traverses faster and moves to the end of the list if the length is odd</span></span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># take it as a tuple being assigned (rev, rev.next, slow) = (slow, rev, slow.next), hence the re-assignment of slow would not affect rev (rev = slow)</span></span><br><span class="line">        rev, rev.next, slow = slow, rev, slow.next</span><br><span class="line">    <span class="keyword">if</span> fast:</span><br><span class="line">       <span class="comment"># fast is at the end, move slow one step further for comparison(cross middle one)</span></span><br><span class="line">        slow = slow.next</span><br><span class="line">    <span class="comment"># compare the reversed first half with the second half</span></span><br><span class="line">    <span class="keyword">while</span> rev <span class="keyword">and</span> rev.val == slow.val:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        rev = rev.next</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># if equivalent then rev become None, return True; otherwise return False </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> rev</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> linked list </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>235. Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="/2021/03/31/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"/>
      <url>/2021/03/31/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p>Example 1:<br><img src="1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p>Explanation: The LCA of nodes 2 and 8 is 6.<br>Example 2:<br><img src="2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.<br>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [2,1], p = 2, q = 1</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Since BST is sorted, we can check if both p, q value is greater/smaller than root.val. If one of p, q is greater but the other one is smaller, then current root must be the LCA. Because p, q would be in its left and right subtree.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>time complexity: $O(logn)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy medium hard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>70. Climbing Stairs</title>
      <link href="/2021/03/24/70-Climbing-Stairs/"/>
      <url>/2021/03/24/70-Climbing-Stairs/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are climbing a staircase. It takes n steps to reach the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure></p><p>Constraints:</p><p><code>1 &lt;= n &lt;= 45</code></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Top-down<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>)+self.climbStairs(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure></p><p>Bottom-up<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span>]* (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>], dp[<span class="number">2</span>] = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, len(dp)):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]+ dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        a = b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1801. Number of Orders in the Backlog</title>
      <link href="/2021/03/21/1801-Number-of-Orders-in-the-Backlog/"/>
      <url>/2021/03/21/1801-Number-of-Orders-in-the-Backlog/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given a 2D integer array orders, where each <code>orders[i]</code> = <code>[pricei, amounti, orderTypei]</code> denotes that $amount_i$ orders have been placed of type $orderType_i$ at the price $price_i$. The $orderType_i$ is:</p><p><code>0</code> if it is a batch of buy orders, or<br><code>1</code> if it is a batch of sell orders.<br>Note that <code>orders[i]</code> represents a batch of $amount_i$ independent orders with the same price and order type. All orders represented by <code>orders[i]</code> will be placed before all orders represented by <code>orders[i+1]</code> for all valid <code>i</code>.</p><p>There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:</p><p>If the order is a buy order, you look at the sell order with the smallest price in the backlog. If that sell order’s price is smaller than or equal to the current buy order’s price, they will match and be executed, and that sell order will be removed from the backlog. Else, the buy order is added to the backlog.<br>Vice versa, if the order is a sell order, you look at the buy order with the largest price in the backlog. If that buy order’s price is larger than or equal to the current sell order’s price, they will match and be executed, and that buy order will be removed from the backlog. Else, the sell order is added to the backlog.<br>Return the total amount of orders in the backlog after placing all the orders from the input. Since this number can be large, return it modulo $10^9 + 7$.</p><p>Example 1:<br><img src="1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Here is what happens with the orders:</span><br><span class="line">- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.</span><br><span class="line">- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.</span><br><span class="line">- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.</span><br><span class="line">- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.</span><br><span class="line">Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.</span><br></pre></td></tr></table></figure><p>Example 2:<br><img src="2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]</span><br><span class="line">Output: 999999984</span><br><span class="line">Explanation: Here is what happens with the orders:</span><br><span class="line">- 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.</span><br><span class="line">- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.</span><br><span class="line">- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.</span><br><span class="line">- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.</span><br><span class="line">Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (10^9 + 7).</span><br></pre></td></tr></table></figure><p>Constraints:</p><ul><li><code>1 &lt;= orders.length &lt;= 105</code></li><li><code>orders[i].length == 3</code></li><li><code>1 &lt;= price_i, amount_i &lt;= 109</code></li><li><code>orderType_i is either 0 or 1.</code></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNumberOfBacklogOrders</span><span class="params">(self, orders: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 1. want to maximize profit, ie. largest buy price - smallest sell price</span></span><br><span class="line">        <span class="comment"># 2. walk through orders in time order</span></span><br><span class="line">        </span><br><span class="line">        sell, buy = [], []</span><br><span class="line">        <span class="keyword">for</span> p, a, t <span class="keyword">in</span> orders:</span><br><span class="line">            <span class="comment"># this is in time order</span></span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">                heapq.heappush(buy, [-p, a])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(sell, [p, a])</span><br><span class="line">            <span class="keyword">while</span> sell <span class="keyword">and</span> buy <span class="keyword">and</span> sell[<span class="number">0</span>][<span class="number">0</span>] &lt;= -buy[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># find amount of orders could achieve</span></span><br><span class="line">                k = min(sell[<span class="number">0</span>][<span class="number">1</span>], buy[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">                sell[<span class="number">0</span>][<span class="number">1</span>] -= k</span><br><span class="line">                buy[<span class="number">0</span>][<span class="number">1</span>] -= k</span><br><span class="line">                <span class="keyword">if</span> sell[<span class="number">0</span>][<span class="number">1</span>] == <span class="number">0</span>: heapq.heappop(sell)</span><br><span class="line">                <span class="keyword">if</span> buy[<span class="number">0</span>][<span class="number">1</span>] == <span class="number">0</span>: heapq.heappop(buy)</span><br><span class="line">        <span class="keyword">return</span> sum(a <span class="keyword">for</span> p, a <span class="keyword">in</span> buy+sell) % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> greedy </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>824. Goat Latin</title>
      <link href="/2020/08/19/824-Goat-Latin/"/>
      <url>/2020/08/19/824-Goat-Latin/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.</p><p>We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.)</p><p>The rules of Goat Latin are as follows:</p><p>If a word begins with a vowel <code>(a, e, i, o, or u)</code>, append “ma” to the end of the word.<br>For example, the word ‘apple’ becomes ‘applema’.</p><p>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.<br>For example, the word “goat” becomes “oatgma”.</p><p>Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.<br>For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.<br>Return the final sentence representing the conversion from S to Goat Latin. </p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;I speak Goat Latin&quot;</span><br><span class="line">Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;The quick brown fox jumped over the lazy dog&quot;</span><br><span class="line">Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Notes:</span><br><span class="line"></span><br><span class="line">S contains only uppercase, lowercase and spaces. Exactly one space between each word.</span><br><span class="line">1 &lt;= S.length &lt;= 150.</span><br><span class="line"></span><br><span class="line">### Solution:</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class Solution:</span><br><span class="line">    def toGoatLatin(self, S: str) -&gt; str:</span><br><span class="line">        words = S.split()</span><br><span class="line">        vowels = set(&quot;AEIOUaeiou&quot;)</span><br><span class="line">        for i in range(len(words)):</span><br><span class="line">            if words[i][0] in vowels:</span><br><span class="line">                words[i] = words[i] + &quot;ma&quot; + &quot;a&quot;*(i+1)</span><br><span class="line">            else:</span><br><span class="line">                words[i] = words[i][1:] + words[i][0] + &quot;ma&quot; + &quot;a&quot;*(i+1)</span><br><span class="line">                </span><br><span class="line">        return &quot; &quot;.join(words)</span><br></pre></td></tr></table></figure></p><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1103. Distribute Candies to People</title>
      <link href="/2020/08/17/1103-Distribute-Candies-to-People/"/>
      <url>/2020/08/17/1103-Distribute-Candies-to-People/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>We distribute some number of candies, to a row of n = num_people people in the following way:</p><p>We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.</p><p>Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.</p><p>This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift).</p><p>Return an array (of length num_people and sum candies) that represents the final distribution of candies.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = 7, num_people = 4</span><br><span class="line">Output: [1,2,3,1]</span><br><span class="line">Explanation:</span><br><span class="line">On the first turn, ans[0] += 1, and the array is [1,0,0,0].</span><br><span class="line">On the second turn, ans[1] += 2, and the array is [1,2,0,0].</span><br><span class="line">On the third turn, ans[2] += 3, and the array is [1,2,3,0].</span><br><span class="line">On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = 10, num_people = 3</span><br><span class="line">Output: [5,2,3]</span><br><span class="line">Explanation: </span><br><span class="line">On the first turn, ans[0] += 1, and the array is [1,0,0].</span><br><span class="line">On the second turn, ans[1] += 2, and the array is [1,2,0].</span><br><span class="line">On the third turn, ans[2] += 3, and the array is [1,2,3].</span><br><span class="line">On the fourth turn, ans[0] += 4, and the final array is [5,2,3].</span><br></pre></td></tr></table></figure></p><p>Constraints:</p><p><code>1 &lt;= candies &lt;= 10^9</code><br><code>1 &lt;= num_people &lt;= 1000</code></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>Use <code>i % num_people</code> to determine the current index of the people, where i is the i-th giving of candy;</li><li>Increase each amount by 1 till run out of candies.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies: int, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = [<span class="number">0</span>]* n</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> candies &gt; <span class="number">0</span>:</span><br><span class="line">            res[i % n] += min(i+<span class="number">1</span>, candies)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            candies -= i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>435. Non-overlapping Intervals</title>
      <link href="/2020/08/15/435-Non-overlapping-Intervals/"/>
      <url>/2020/08/15/435-Non-overlapping-Intervals/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[1,2],[1,2]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.</span><br></pre></td></tr></table></figure></p><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">nput: [[1,2],[2,3]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: You don&apos;t need to remove any of the intervals since they&apos;re already non-overlapping.</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">You may assume the interval&apos;s end point is always bigger than its start point.</span><br><span class="line">Intervals like `[1,2]` and `[2,3]` have borders &quot;touching&quot; but they don&apos;t overlap each other.</span><br><span class="line"></span><br><span class="line">### Solution:</span><br><span class="line"></span><br><span class="line">The idea is to pick the interval with the earliest end time. Then we can get the maximal number of non-overlapping intervals. (or minimal number to remove).</span><br><span class="line">This is because, the interval with the earliest end time produces the maximal capacity to hold rest intervals.</span><br><span class="line">E.g. Suppose current earliest end time of the rest intervals is x. Then available time slot left for other intervals is `[x:]`. If we choose another interval with end time y, then available time slot would be `[y:]`. Since `x ≤ y`, there is no way `[y:]` can hold more intervals then `[x:]`. Thus, the heuristic holds.</span><br><span class="line"></span><br><span class="line">Therefore, we can sort interval by ending time and key track of current earliest end time. Once next interval&apos;s start time is earlier than current end time, then we have to remove one interval. Otherwise, we update earliest end time.</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class Solution:</span><br><span class="line">    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:</span><br><span class="line">        end, res = float(&apos;-inf&apos;), 0</span><br><span class="line">        </span><br><span class="line">        for x in sorted(intervals, key= lambda x: x[1]):</span><br><span class="line">            if x[0] &gt;= end:</span><br><span class="line">                end = x[1]</span><br><span class="line">            else:</span><br><span class="line">                res += 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$, sorting<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>409. Longest Palindrome</title>
      <link href="/2020/08/14/409-Longest-Palindrome/"/>
      <url>/2020/08/14/409-Longest-Palindrome/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p><p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p><p>Note:<br>Assume the length of given string will not exceed 1,010.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br></pre></td></tr></table></figure></p><p>Explanation:<br>One longest palindrome that can be built is “dccaccd”, whose length is 7.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>First, count all characters in the string. <code>Even</code> occurring characters (v[i]%2 == 0) can always be used to build a palindrome. For every <code>odd</code> occurring character (v[i]%2 == 1), v[i]-1 characters can be used. Result is incremented if there is at least one character with odd occurrence number.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> count:</span><br><span class="line">                count[c] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count[c] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        haveOdd = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> count:</span><br><span class="line">            <span class="keyword">if</span> count[x]%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                haveOdd = <span class="number">1</span></span><br><span class="line">                res += count[x]<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += count[x]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res + haveOdd</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy medium hard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1286. Iterator for Combination</title>
      <link href="/2020/08/13/1286-Iterator-for-Combination/"/>
      <url>/2020/08/13/1286-Iterator-for-Combination/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design an Iterator class, which has:</p><p>A constructor that takes a string <code>characters</code> of sorted distinct lowercase English letters and a number <code>combinationLength</code> as arguments.<br>A function <code>next()</code> that returns the next combination of length <code>combinationLength</code> in lexicographical order.<br>A function <code>hasNext()</code> that returns True if and only if there exists a next combination.</p><p>Example:</p><p>CombinationIterator iterator = new CombinationIterator(“abc”, 2); // creates the iterator.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iterator.next(); // returns &quot;ab&quot;</span><br><span class="line">iterator.hasNext(); // returns true</span><br><span class="line">iterator.next(); // returns &quot;ac&quot;</span><br><span class="line">iterator.hasNext(); // returns true</span><br><span class="line">iterator.next(); // returns &quot;bc&quot;</span><br><span class="line">iterator.hasNext(); // returns false</span><br></pre></td></tr></table></figure></p><p>Constraints:</p><p><code>1 &lt;= combinationLength &lt;= characters.length &lt;= 15</code><br>There will be at most $10^4$ function calls per test.<br>It’s guaranteed that all calls of the function <code>next</code> are valid.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombinationIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, characters: str, combinationLength: int)</span>:</span></span><br><span class="line">        self.characters = characters</span><br><span class="line">        self.n = len(characters)</span><br><span class="line">        self.combinations = gen_combinations(self.n, combinationLength)</span><br><span class="line">        self.ind = len(self.combinations) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n):</span><br><span class="line">            <span class="keyword">if</span> self.combinations[self.ind][i] != <span class="string">"0"</span>:</span><br><span class="line">                s += self.characters[i]</span><br><span class="line">        self.ind -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.ind &gt; <span class="number">-1</span> </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_combinations</span><span class="params">(l, n)</span>:</span></span><br><span class="line">    end = int(<span class="string">"1"</span> * l, <span class="number">2</span>)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(end + <span class="number">1</span>):</span><br><span class="line">        b = bin(i)[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">if</span> b.count(<span class="string">'1'</span>) == n:</span><br><span class="line">            ans.append(b.zfill(l))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CombinationIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CombinationIterator(characters, combinationLength)</span></span><br><span class="line"><span class="comment"># param_1 = obj.next()</span></span><br><span class="line"><span class="comment"># param_2 = obj.hasNext()</span></span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>274. H-Index</title>
      <link href="/2020/08/11/274-H-Index/"/>
      <url>/2020/08/11/274-H-Index/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: citations = [3,0,6,1,5]</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had </span><br><span class="line">             received 3, 0, 6, 1, 5 citations respectively. </span><br><span class="line">             Since the researcher has 3 papers with at least 3 citations each and the remaining </span><br><span class="line">             two with no more than 3 citations each, her h-index is 3.</span><br></pre></td></tr></table></figure></p><p>Note: If there are several possible values for h, the maximum one is taken as the h-index.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span></span><br><span class="line">        citations.sort()</span><br><span class="line">        n = len(citations)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> citations[i] &gt;= (n-i):</span><br><span class="line">                <span class="keyword">return</span> n-i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>space complexity: $O(1)$</p><p>Another thought is to use bucker sort. The idea is to see that the result can only range from <code>0 to the length of the array</code> (because we can’t have h-index <code>greater</code> than the total papers published). So we create an array “arr” which acts like a HashMap (using pigeon hole principle) and loop backwards from the highest element, then we find <code>total</code> which is the total number of papers that has more than i citations, and we stop when total&gt;=i (total number of papers with <code>more than</code> i citations &gt;= i). We don’t need to keep going because we are trying the biggest i possible, we we stop and return the result.</p><pre><code class="python"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">hIndex</span><span class="params">(self, citations: List[int])</span> -&gt; int:</span>        n = len(citations)        bucket = [<span class="number">0</span>]*(n+<span class="number">1</span>)        <span class="keyword">for</span> cite <span class="keyword">in</span> citations:            <span class="keyword">if</span> cite &gt;= n:                bucket[n] += <span class="number">1</span>            <span class="keyword">else</span>:                bucket[cite] += <span class="number">1</span>        total = <span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(bucket))):            total += bucket[i]            <span class="keyword">if</span> total &gt;= i:                <span class="keyword">return</span> i</code></pre><p>time complexity: $O(n)$<br>space complexity: $O(n)$        </p><p>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>171. Excel Sheet Column Number</title>
      <link href="/2020/08/10/171-Excel-Sheet-Column-Number/"/>
      <url>/2020/08/10/171-Excel-Sheet-Column-Number/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p><p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure></p><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">`1 &lt;= s.length &lt;= 7`</span><br><span class="line">`s` consists only of uppercase English letters.</span><br><span class="line">`s` is between &quot;A&quot; and &quot;FXSHRXW&quot;.### Solution:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Solution:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class Solution:</span><br><span class="line">    def titleToNumber(self, s: str) -&gt; int:</span><br><span class="line">        s = s[::-1]</span><br><span class="line">        res = 0</span><br><span class="line">        for exp, char in enumerate(s):</span><br><span class="line">            res += 26**exp * (ord(char)-ord(&apos;A&apos;)+1)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy medium hard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>994. Rotting Oranges</title>
      <link href="/2020/08/09/994-Rotting-Oranges/"/>
      <url>/2020/08/09/994-Rotting-Oranges/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>In a given grid, each cell can have one of three values:</p><p>the value <code>0</code> representing an empty cell;<br>the value <code>1</code> representing a fresh orange;<br>the value <code>2</code> representing a rotten orange.<br>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p><p>Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return <code>-1</code> instead.</p><p>Example 1:<br><img src="oranges.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:  The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,2]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:  Since there are already no fresh oranges at minute 0, the answer is just 0.</span><br></pre></td></tr></table></figure></p><p>Note:</p><ol><li><code>1 &lt;= grid.length &lt;= 10</code></li><li><code>1 &lt;= grid[0].length &lt;= 10</code></li><li><code>grid[i][j]</code> is only <code>0</code>, <code>1</code>, or <code>2</code>.</li></ol><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orangesRotting</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 1. find all rotten orange</span></span><br><span class="line">        <span class="comment"># 2. for each rotten orange, do bfs</span></span><br><span class="line">          <span class="comment"># 2.1 the rotten orange is added based on level</span></span><br><span class="line">          <span class="comment"># ex: at first, there're only 3 rotten orange, then just do 3 times BFS</span></span><br><span class="line">          <span class="comment"># 2.2 add new rotten orange to queue</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        queue = deque()</span><br><span class="line">        fresh_orange = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">2</span>:</span><br><span class="line">                    queue.append((i, j))</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    fresh_orange += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        minute_passed = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue <span class="keyword">and</span> fresh_orange &gt; <span class="number">0</span>:</span><br><span class="line">            minute_passed += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                x, y = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> ((<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)):</span><br><span class="line">                    xx, yy = x + dx, y + dy</span><br><span class="line">                    <span class="keyword">if</span> xx &lt; <span class="number">0</span> <span class="keyword">or</span> yy &lt; <span class="number">0</span> <span class="keyword">or</span> xx == m <span class="keyword">or</span> yy == n:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[xx][yy] == <span class="number">0</span> <span class="keyword">or</span> grid[xx][yy] == <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                    grid[xx][yy] = <span class="number">2</span></span><br><span class="line">                    fresh_orange -= <span class="number">1</span></span><br><span class="line">                    queue.append((xx, yy))</span><br><span class="line">        <span class="keyword">return</span> minute_passed <span class="keyword">if</span> fresh_orange == <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(mn)$, each cell is visited at least once</p><p>space complexity: $O(mn)$, in the worst case if all the oranges are rotten they will be added to the queue</p><p>reference:<br><a href="https://leetcode.com/problems/rotting-oranges/discuss/563686/Python-Clean-and-Well-Explained-(faster-than-greater-90)" target="_blank" rel="noopener">https://leetcode.com/problems/rotting-oranges/discuss/563686/Python-Clean-and-Well-Explained-(faster-than-greater-90)</a></p><p>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>987. Vertical Order Traversal of a Binary Tree</title>
      <link href="/2020/08/07/987-Vertical-Order-Traversal-of-a-Binary-Tree/"/>
      <url>/2020/08/07/987-Vertical-Order-Traversal-of-a-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, return the vertical order traversal of its nodes values.</p><p>For each node at position <code>(X, Y)</code>, its left and right children respectively will be at positions <code>(X-1, Y-1)</code> and <code>(X+1, Y-1)</code>.</p><p>Running a vertical line from <code>X = -infinity</code> to <code>X = +infinity</code>, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).</p><p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p><p>Return a list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.</p><p>Example 1:<br><img src="1236_example_1.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure></p><p><img src="tree2.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = collections.defaultdict(list)</span><br><span class="line">        queue = [(root, <span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            nextLevelQueue = []</span><br><span class="line">            curLevelRes = collections.defaultdict(list)</span><br><span class="line">            <span class="keyword">for</span> node, level <span class="keyword">in</span> queue:</span><br><span class="line">                curLevelRes[level].append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: </span><br><span class="line">                    nextLevelQueue += (node.left, level<span class="number">-1</span>),</span><br><span class="line">                <span class="keyword">if</span> node.right: </span><br><span class="line">                    nextLevelQueue += (node.right, level+<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">for</span> level <span class="keyword">in</span> curLevelRes: res[level].extend(sorted(curLevelRes[level]))</span><br><span class="line">            queue = nextLevelQueue</span><br><span class="line">        <span class="keyword">return</span> [res[level] <span class="keyword">for</span> level <span class="keyword">in</span> sorted(res)]</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>342. Power of Four</title>
      <link href="/2020/08/04/342-Power-of-Four/"/>
      <url>/2020/08/04/342-Power-of-Four/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span> <span class="keyword">and</span> num%<span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">            num/= <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br>related problem:<br><br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> bit manipulation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>705. Design HashSet</title>
      <link href="/2020/08/02/705-Design-HashSet/"/>
      <url>/2020/08/02/705-Design-HashSet/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a HashSet without using any built-in hash table libraries.</p><p>To be specific, your design should include these functions:</p><p><code>add(value)</code>: Insert a value into the HashSet.<br><code>contains(value)</code> : Return whether the value exists in the HashSet or not.<br><code>remove(value)</code>: Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyHashSet hashSet = new MyHashSet();</span><br><span class="line">hashSet.add(1);         </span><br><span class="line">hashSet.add(2);         </span><br><span class="line">hashSet.contains(1);    // returns true</span><br><span class="line">hashSet.contains(3);    // returns false (not found)</span><br><span class="line">hashSet.add(2);          </span><br><span class="line">hashSet.contains(2);    // returns true</span><br><span class="line">hashSet.remove(2);          </span><br><span class="line">hashSet.contains(2);    // returns false (already removed)</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>All values will be in the range of <code>[0, 1000000]</code>.<br>The number of operations will be in the range of <code>[1, 10000]</code>.<br>Please do not use the built-in HashSet library.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>I divide this problem into two part:</p><ul><li>hash function</li><li>handle conflict</li></ul><p>I use an intuitive way to implement hash function, find a prime number to be the seed and mod the value to get the key where to store it.<br>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash seed = 13, this means we have 13 buckets.</span><br><span class="line">val = 40</span><br><span class="line">40 % 13 = 1</span><br><span class="line">so we&apos;ll store 40 in bucket[1]</span><br></pre></td></tr></table></figure></p><p>Then I use linked list to store the nodes in the same buckets. </p><p>Improvement:<br>We should use a bigger prime number, something like <a href="https://www.tutorialspoint.com/c-program-for-find-the-largest-prime-factor-of-a-number" target="_blank" rel="noopener">this</a>. By using a large prime number, the conflict would be lower down. This would make time complexity close to $O(logn)$ by reducing the probability to search node in linked list. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, next)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.size = <span class="number">13</span> <span class="comment"># prime number </span></span><br><span class="line">        self.h = [Node(<span class="keyword">None</span>, <span class="keyword">None</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, key: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        p = self.h[key % self.size]</span><br><span class="line">        node = p.next</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> node.val == key:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p = node</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.next = Node(key, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, key: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        p = self.h[key % self.size]</span><br><span class="line">        node = p.next</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> node.val == key:</span><br><span class="line">                p.next = node.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p = node</span><br><span class="line">            node = node.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contains</span><span class="params">(self, key: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns true if this set contains the specified element</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.h[key % self.size]</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> node.val == key:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$, if use a large prime number, could close to $O(logn)$<br>space complexity: $O(n)$<br>reference:<br>related problem:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
          <category> hash table </category>
          
          <category> design </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>520. Detect Capital</title>
      <link href="/2020/08/01/520-Detect-Capital/"/>
      <url>/2020/08/01/520-Detect-Capital/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p><p>We define the usage of capitals in a word to be right when one of the following cases holds:</p><ol><li>All letters in this word are capitals, like “USA”.</li><li>All letters in this word are not capitals, like “leetcode”.</li><li>Only the first letter in this word is capital, like “Google”.<br>Otherwise, we define that this word doesn’t use capitals in a right way.</li></ol><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;USA&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;FlaG&quot;</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The question mentioned given a word, so during the interview, we should starting from clarifying the input. </p><ul><li>Does the word contains numbers or symbols?</li></ul><p>In the description, there’re three conditions to return True. So we could count the number of capital characters to verify.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCapitalUse</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># Only first word be capital || All words are capital || no capital</span></span><br><span class="line">        <span class="comment"># number of capital words</span></span><br><span class="line">        num_Cap, n = <span class="number">0</span>, len(word)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> word:</span><br><span class="line">            num_Cap += x.isupper()</span><br><span class="line">        <span class="keyword">if</span> num_Cap == n <span class="keyword">or</span> num_Cap == <span class="number">1</span> <span class="keyword">and</span> word[<span class="number">0</span>].isupper() <span class="keyword">or</span> num_Cap == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>Another thought is to check the condition of <code>1~n</code>. That is to say, character <code>1~n</code> should be all lower case or upper case. But an exception is the first character <code>word[0]</code> is lower case but <code>word[1~n]</code> is upper case.<br>Another thought is to check the condition of <code>1~n</code>. We should only return <code>True</code> if the whole string is lower/upper case, or only first character is upper case and <code>word[1:]</code> is lower case.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCapitalUse</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> word.lower() == word <span class="keyword">or</span> word.upper() == word:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> word[<span class="number">0</span>].isupper() <span class="keyword">and</span> word[<span class="number">1</span>:].lower() == word[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p><p>reference:<br>related problem:<br></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>24. Swap Nodes in Pairs</title>
      <link href="/2020/05/18/24-Swap-Nodes-in-Pairs/"/>
      <url>/2020/05/18/24-Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Create a dummy node and use slow, fast to do swap.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode fast, slow, dummy;</span><br><span class="line">        slow = <span class="keyword">new</span> ListNode(); slow.next = head; dummy = slow;</span><br><span class="line">        fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow.next = fast.next;</span><br><span class="line">            fast.next = slow.next.next;</span><br><span class="line">            slow.next.next = fast;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p><p>related problem:<br><a href="/2018/12/29/25-Reverse-Nodes-in-k-Group/" title="25. Reverse Nodes in k-Group">25. Reverse Nodes in k-Group</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/2020/05/16/2-Add-Two-Numbers/"/>
      <url>/2020/05/16/2-Add-Two-Numbers/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode dummy = head;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry != <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                carry += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                carry += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dummy.next = <span class="keyword">new</span> ListNode(carry % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$, if not consider result space.<br>reference:</p><p>related question:<br><a href="/2019/01/02/43-Multiply-Strings/" title="43. Multiply Strings">43. Multiply Strings</a><br><a href="/2018/05/19/445-Add-Two-Numbers-II/" title="445. Add Two Numbers II">445. Add Two Numbers II</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Poor Economics</title>
      <link href="/2020/05/02/Poor-Economics/"/>
      <url>/2020/05/02/Poor-Economics/</url>
      <content type="html"><![CDATA[<h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3."></a>Chapter 3.</h2><p>人天生會把小成本往後延, 這樣就不必在今天付出代價, 而是延到明天才負擔. 因此可善用小獎勵補償付出的成本. 如果此推論正確, 則以往補貼式的政策就是合理的. 並且, 介入選擇的其中一個方法就是提供default option. 若有預設選擇, 那人們跳出預設選擇就須相當費力. <br>很多情況下, 時間不一致性阻礙我們把意願化為行動. 因為如果充分認識當下行動的好處, 那很難相信時間不一致性足以讓他們繼續拖延. 更合理的解釋為不但拖延<code>並且</code>低估行動帶來的好處. </p><h2 id="chap-4"><a href="#chap-4" class="headerlink" title="chap 4"></a>chap 4</h2><p>p.99<br>如果要提升教育的吸引力, 就投資需要高素質勞工的產業. UCLA實驗, 隨機到以往不會去的村莊舉辦招募會, 顯著結果為年輕女性就業人數上升. 而在三年後, 5~11歲的女孩就學率上升, 體重也增加. 此可顯示父母認為教育女兒有經濟價值, 因此願意投資. </p>]]></content>
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> economics </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Amazon behavioral prepare</title>
      <link href="/2019/06/29/Amazon-behavioral-prepare/"/>
      <url>/2019/06/29/Amazon-behavioral-prepare/</url>
      <content type="html"><![CDATA[<p>While interviewing with Amazon, the interviewers would ask you lots of behavioral questions based on Amazon leadership principles. The best way to prepare for your interview is to consider how you’ve applied the Leadership Principles in your previous professional experience.</p><p><img src="IMG_5900.JPG" alt=""></p><h3 id="Customer-Obsession"><a href="#Customer-Obsession" class="headerlink" title="Customer Obsession"></a>Customer Obsession</h3><p><code>Leaders start with the customer and work backwards. They work vigorously to earn and keep customer trust. Although leaders pay attention to competitors, they obsess over customers.</code></p><p>Who was your most difficult customer?<br>Give me an example of a time when you did not meet a client’s expectation. What happened, and how did you attempt to rectify the situation?<br>When you’re working with a large number of customers, it’s tricky to deliver excellent service to them all. How do you go about prioritizing your customers’ needs?<br>Tell the story of the last time you had to apologize to someone.</p><h3 id="Ownership"><a href="#Ownership" class="headerlink" title="Ownership"></a>Ownership</h3><p><code>Leaders are owners. They think long term and don’t sacrifice long-term value for short-term results. They act on behalf of the entire company, beyond just their own team. They never say “that’s not my job&quot;.</code><br>Tell me about a time when you had to leave a task unfinished.<br>Tell me about a time when you had to work on a project with unclear responsibilities. (discuss the spec)<br>Provide an example of when you personally demonstrated ownership. (show the design document, demo, suggest feature)<br>Tell me about a time you went above and beyond.(above and beyond, means do more than you need to)<br>Tell me about a time when you took on something significant outside your area of responsibility. Why was it important? What was the outcome?<br>Describe a project or idea (not necessarily your own) that was implemented primarily because of your efforts. What was your role? What was the outcome? (auth function)<br>Give an example of when you saw a peer struggling and decided to step in and help. What was the situation and what actions did you take? What was the outcome? (lead junior engineer)</p><h3 id="Invent-and-Simplify"><a href="#Invent-and-Simplify" class="headerlink" title="Invent and Simplify"></a>Invent and Simplify</h3><p><code>Leaders expect and require innovation and invention from their teams and always find ways to simplify. They are externally aware, look for new ideas from everywhere, and are not limited by “not invented here&quot;. As we do new things, we accept that we may be misunderstood for long periods of time.</code><br>Tell me about a time when you gave a simple solution to a complex problem.<br>Tell me about a time when you invented something.<br>What improvements have you made at your current company?<br>Tell me about a time you had to think outside the box (think creatively) to close a sale or sell your product.<br>What is the most innovative project you’ve worked on?</p><p>###Leaders are Right A Lot###<br><code>Leaders are right a lot. They have strong judgment and good instincts. They seek diverse perspectives and work to disconfirm their beliefs. We should be willing to look for better ways to do something, even if it’s something that we already handle well. Smart people is flexible and open minded.</code><br>tell me about a time when you are wrong<br>tell me about a time when you had to work with incomplete data or information(PCS init)<br>make a decision, but also consider the opinions of the other people(PCS init)</p><h3 id="Learn-and-Be-Curious"><a href="#Learn-and-Be-Curious" class="headerlink" title="Learn and Be Curious"></a>Learn and Be Curious</h3><p><code>Leaders are never done learning and always seek to improve themselves. They are curious about new possibilities and act to explore them.</code><br>How do you find the time to stay inspired, acquire new knowledge, innovate in your work?(seminar)<br>Tell me about a time when you influenced a change by only asking questions. (ImageMaker console format)<br>Tell me about a time when you solved a problem through just superior knowledge or observation. (MD5 tool)<br>How do you stay inspired, acquire new knowledge, or innovate in your work?(seminar)<br>What can you teach me in 5 minutes that I don’t already know?(ImageMaker console)<br>Tell me about a time you hired someone smarter than you.<br>Tell me something interesting you’ve learned recently.(seminar)</p><h3 id="Hire-and-Develop-the-best"><a href="#Hire-and-Develop-the-best" class="headerlink" title="Hire and Develop the best"></a>Hire and Develop the best</h3><p><code>Leaders raise the performance bar with every hire and promotion. They recognize exceptional talent, and willingly move them throughout the organization. Leaders develop leaders and take seriously their role in coaching others. We work on behalf of our people to invent mechanisms for development like Career Choice.</code><br>Tell me about a time when you had to deal with a poor performer on your team.(junior engineer)<br>What is your experience with hiring people?<br>How do you ensure you hire the best people?<br>Give me an example of one of the best hires of your career. How did this person grow throughout their career? What did you identify during the hiring process that drove her success?<br>How do you help your employees grow?(junior engineer)<br>Tell me how you help your team members develop their careers. Can you give me two to three examples of a specific person in whom you invested and how you helped them develop their careers, including one who wasn’t being successful but in whom you saw potential and chose to invest?(junior engineer)<br>Give me an example of a time you provided feedback to develop and leverage the strengths of someone on your team. Were you able to positively impact that person’s performance? What were your most effective methods?(junior engineer)<br>How do you manage your top performers differently?<br>Give me an example of someone who was promoted one or two levels up in the organization, not just because they were a star who would naturally rise, but due to your coaching efforts. (junior engineer)<br>What is the composition of your current team, and how is your team organized?</p><h3 id="Insist-on-highest-standard"><a href="#Insist-on-highest-standard" class="headerlink" title="Insist on highest standard"></a>Insist on highest standard</h3><p><code>Leaders have relentlessly high standards - many people may think these standards are unreasonably high. Leaders are continually raising the bar and driving their teams to deliver high quality products, services and processes. Leaders ensure that defects do not get sent down the line and that problems are fixed so they stay fixed.</code><br>Tell me about a time when you could have stopped working but persisted.(PCS latency improvement)<br>Tell me about a time when you mentored someone.(junior engineer)<br>Tell me when you need to sacrifice short-term benefit for long-term goal(PCS latency improvement)<br>Tell me about a time when you’ve been unsatisfied with the status quo. What did you do to change it? Were you successful? (short development cycle)<br>Tell me about a time you wouldn’t compromise on achieving a great outcome when others felt something was already good enough. What was the situation? (PCS)<br>What measures have you personally put in place to ensure performance improvement targets and standards are achieved? (short development cycle)<br>Describe the most significant, continuous improvement project that you’ve led. What was the catalyst for this change and how did you go about it?(PCS load balance)<br>Give me an example of a goal you’ve had where you wish you had done better. What was the goal and how could you have improved on it?<br>Tell me about a time when you worked to improve the quality of a product / service / solution that was already getting good customer feedback? Why did you think it needed more improvement?<br>Give an example where you refused to compromise your standards around quality/customer service, etc. Why did you feel so strongly about the situation? What were the consequences? The result?(PCS load balance)</p><h3 id="Bias-for-action"><a href="#Bias-for-action" class="headerlink" title="Bias for action"></a>Bias for action</h3><p><code>Speed matters in business. Many decisions and actions are reversible and do not need extensive study. We value calculated risk taking.</code><br>Describe how you would handle a busy situation where three people are waiting for help from you<br>Describe a time when you saw some problem and took the initiative to correct it rather than waiting for someone else to do it.(FW auth function)<br>Tell me about a time when you took a calculated risk.(prototype, with fixed port, change it to automate method)<br>Tell me about a time you needed to get information from someone who wasn’t very responsive. What did you do?(field engineer, wrong issue report on ImageMaker)<br>Tell me about a time you took a risk. What kind of risk was it?<br>Give me an example of a calculated risk that you have taken where speed was critical. What was the situation and how did you handle it? What steps did you take to mitigate the risk? What was the outcome?<br>Tell me about a time you had to make a decision with incomplete information. How did you make it and what was the outcome?(PCS)<br>Describe a situation where you made an important business decision without consulting your manager. What was the situation and how did it turn out?<br>Tell me about a time when you had to analyze facts quickly, define key issues, and respond immediately to a situation. What was the outcome?<br>Tell me about a time when you have worked against tight deadlines and didn’t have the time to consider all options before making a decision. How much time did you have? What approach did you take?<br>Give an example of when you had to make an important decision and had to decide between moving forward or gathering more information. What did you do? What information is necessary for you to have before acting?<br>Describe a time when you saw some problem and took the initiative to correct it rather than waiting for someone else to do it.</p><h3 id="Frugality"><a href="#Frugality" class="headerlink" title="Frugality"></a>Frugality</h3><p><code>Accomplish more with less. Constraints breed resourcefulness, self-sufficiency and invention. There are no extra points for growing headcount, budget size or fixed expense.</code><br>Instead of investing time to develop new tools, use existed and verified tools to accomplish tasks.<br>Tell me about a time where you thought of a clever new way to save money for the company.<br>Tell me about a time when you had to work with limited time or resources.</p><h3 id="Dive-Deep"><a href="#Dive-Deep" class="headerlink" title="Dive Deep"></a>Dive Deep</h3><p><code>Leaders operate at all levels, stay connected to the details, audit frequently, and are skeptical when metrics and anecdote differ. No task is beneath them.</code><br>Tell me about a time when you had to dive deep into the data and the results you achieved.<br>tell me about a time when you dived deep/drilled down to find the root issue.</p><h3 id="Earn-Trust"><a href="#Earn-Trust" class="headerlink" title="Earn Trust"></a>Earn Trust</h3><p><code>Leaders listen attentively, speak candidly, and treat others respectfully. They are vocally self-critical, even when doing so is awkward or embarrassing. Leaders do not believe their or their team’s body odor smells of perfume. They benchmark themselves and their teams against the best.</code><br>Tell me about a time you made a serious mistake at work.<br>Tell me how that project you were leading failed.</p><h3 id="Have-backbone-disagree-and-commit"><a href="#Have-backbone-disagree-and-commit" class="headerlink" title="Have backbone disagree and commit"></a>Have backbone disagree and commit</h3><p><code>Leaders are obligated to respectfully challenge decisions when they disagree, even when doing so is uncomfortable or exhausting. Leaders have conviction and are tenacious. They do not compromise for the sake of social cohesion. Once a decision is determined, they commit wholly.</code><br>Tell me about a time when you did not accept the status quo.<br>Tell me about an unpopular decision of yours.<br>Tell me about a time when you had to step up and disagree with a team members approach.<br>If your direct manager was instructing you to do something you disagreed with, how would you handle it?</p><h3 id="Deliver-Result"><a href="#Deliver-Result" class="headerlink" title="Deliver Result"></a>Deliver Result</h3><p><code>Leaders focus on the key inputs for their business and deliver them with the right quality and in a timely fashion. Despite setbacks, they rise to the occasion and never settle.</code></p><h3 id="Think-Big"><a href="#Think-Big" class="headerlink" title="Think Big"></a>Think Big</h3><p><code>Thinking small is a self-fulfilling prophecy. Leaders create and communicate a bold direction that inspires results. They think differently and look around corners for ways to serve customers.</code><br>Tell me about a time when you proposed a new business<br>Tell me about a time you took a calculated risk in order to achieve a professional goal. What were the tradeoffs? What was the outcome?<br>Tell me about a time you took a big risk and it failed. What did you learn? What would you do differently?<br>Tell me about a time you went way beyond the scope of the project and delivered.<br>Tell me about your proudest professional achievement.<br>Give me an example of a radical approach to a problem you proposed. What was the problem and why did you feel it required a completely different way of thinking about it? Was your approach successful?<br>How do you drive adoption for your vision/ideas? How do you know how well your idea or vision has been adopted by other teams or partners? Give a specific example highlighting one of your ideas.<br>Tell me about time you were working on an initiative or goal and saw an opportunity to do something much bigger than the initial focus.<br>Tell me about a time you looked at a key process that was working well and questioned whether it was still the right one. What assumptions were you questioning and why? Did you end up making a change to the process? </p><p>reference:<br><a href="https://www.amazon.jobs/en/landing_pages/in-person-interview" target="_blank" rel="noopener">https://www.amazon.jobs/en/landing_pages/in-person-interview</a></p>]]></content>
      
      <categories>
          
          <category> behavioral question </category>
          
          <category> amazon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java-Spring</title>
      <link href="/2019/05/08/Java-Spring/"/>
      <url>/2019/05/08/Java-Spring/</url>
      <content type="html"><![CDATA[<p>Spring boot:<br><a href="https://github.com/springframeworkguru/spring5webapp.git" target="_blank" rel="noopener">https://github.com/springframeworkguru/spring5webapp.git</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mvnw spring-boot:run</span><br></pre></td></tr></table></figure><p>download lots of stuff</p><p>JPA: Java Persistence API, working with relational data. It’s a specification, not an implementation.</p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>find max path</title>
      <link href="/2019/03/26/find-max-path/"/>
      <url>/2019/03/26/find-max-path/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Give N*N matrix with random amount of money. can only go left-right, top-bottom. Find the path with max amount of money in its way.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxMoney(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; moneys) &#123;</span><br><span class="line">// assume: moneys is <span class="keyword">not</span> null, width <span class="keyword">and</span> length are equal</span><br><span class="line"><span class="keyword">int</span> n = moneys.size();</span><br><span class="line"><span class="keyword">if</span> (n == 0)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">// base <span class="keyword">case</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = 1; j &lt; n; j++) &#123;</span><br><span class="line">moneys[0][j] = -(Math.<span class="built_in">abs</span>(moneys[0][j-1]) + moneys[0][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = 1 ; i &lt; n ; i++) &#123;</span><br><span class="line">moneys[i][0] = moneys[i-1][0] + moneys[i][0];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = 1; i &lt; n ; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = 1; j &lt; n ; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> top = Math.<span class="built_in">abs</span>(moneys[i-1][j]) + moneys[i][j];</span><br><span class="line"><span class="keyword">int</span> left = Math.<span class="built_in">abs</span>(moneys[i][j-1]) + moneys[i][j];</span><br><span class="line"><span class="keyword">if</span>(top &gt;= left) moneys[i][j] = top;</span><br><span class="line"><span class="keyword">else</span> moneys[i][j] = -left;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">System.out.println("Max path sum = " + Math.<span class="built_in">abs</span>(moneys[n - 1][n - 1]));</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> curri = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> currj = n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (curri &gt; <span class="number">0</span> || currj &gt; <span class="number">0</span>) &#123;</span><br><span class="line">path.add(Arrays.asList(curri, currj));</span><br><span class="line"><span class="keyword">if</span>(moneys[curri][currj] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">currj -= <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curri -=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">path.add(Arrays.asList(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>947. Most Stones Removed with Same Row or Column</title>
      <link href="/2019/03/25/947-Most-Stones-Removed-with-Same-Row-or-Column/"/>
      <url>/2019/03/25/947-Most-Stones-Removed-with-Same-Row-or-Column/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>On a 2D plane, we place stones at some integer coordinate points.  Each coordinate point may have at most one stone.</p><p>Now, a move consists of removing a stone that shares a column or row with another stone on the grid.</p><p>What is the largest possible number of moves we can make?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: stones = [[0,0]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p>Note:</p><p>1 &lt;= stones.length &lt;= 1000<br>0 &lt;= stones[i][j] &lt; 10000</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ul><li>Union find</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sroot;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n= stones.size();</span><br><span class="line">        sroot= <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n; i++)</span><br><span class="line">            sroot[i]= i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stones[i][<span class="number">0</span>] == stones[j][<span class="number">0</span>] || stones[i][<span class="number">1</span>] == stones[j][<span class="number">1</span>])</span><br><span class="line">                    Union(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> connected= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sroot[i] == i)</span><br><span class="line">                connected++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n-connected;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        sroot[find(i)]= find(j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sroot[i] == i? sroot[i]: find(sroot[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>DFS</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visited;</span><br><span class="line">        <span class="keyword">int</span> count= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> stone: stones)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.count(stone))&#123;</span><br><span class="line">                dfs(stones, visited, stone);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones.size()-count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s1)</span></span>&#123;</span><br><span class="line">        visited.insert(s1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s2: stones)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.count(s2))&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[<span class="number">0</span>] == s2[<span class="number">0</span>] || s1[<span class="number">1</span>] == s2[<span class="number">1</span>])</span><br><span class="line">                    dfs(stones, visited, s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> dfs </tag>
            
            <tag> union find </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>688. Knight Probability in Chessboard</title>
      <link href="/2019/03/25/688-Knight-Probability-in-Chessboard/"/>
      <url>/2019/03/25/688-Knight-Probability-in-Chessboard/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1).</p><p>A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.</p><p><img src="688-Knight-Probability-in-Chessboard/knight.png" alt=""></p><p>Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.</p><p>The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3, 2, 0, 0</span><br><span class="line">Output: 0.0625</span><br><span class="line">Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.</span><br><span class="line">From each of those positions, there are also two moves that will keep the knight on the board.</span><br><span class="line">The total probability the knight stays on the board is 0.0625.</span><br></pre></td></tr></table></figure><p>Note:</p><p>N will be between 1 and 25.<br>K will be between 0 and 100.<br>The knight always initially starts on the board.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>First of all, the probability of staying in the board after <code>k</code> turns is $something/8^k$<br>We create a 2D dp board to calculate the times that knight can move to <code>position[i][j]</code>.<br>The idea is to think of it as 2D dp, but do the transfer multiple times.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;, &#123;<span class="number">-2</span>,<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">1</span>,<span class="number">-2</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; dp(N, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(N, <span class="number">0.0</span>));</span><br><span class="line">        dp[row][col]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k= <span class="number">0</span>; k&lt; K; k++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; tmpDP(N, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(N, <span class="number">0.0</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x= <span class="number">0</span>; x&lt; dp.size(); x++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> y= <span class="number">0</span>; y&lt; dp[<span class="number">0</span>].size(); y++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> d= <span class="number">0</span>; d&lt; dirs.size(); d++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> r= x+ dirs[d][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> c= y+ dirs[d][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(r&lt; <span class="number">0</span> || c&lt; <span class="number">0</span> || r&gt;= dp.size() || c&gt;= dp[<span class="number">0</span>].size())</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        tmpDP[r][c]+= dp[x][y];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(dp, tmpDP);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">0</span>; r&lt; N; r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">0</span>; c&lt; N; c++)&#123;</span><br><span class="line">                res+= dp[r][c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res/<span class="built_in">pow</span>(<span class="number">8</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(kn^2)$<br>space complexity: $O(n^2)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>unique paths</title>
      <link href="/2019/03/23/unique-paths/"/>
      <url>/2019/03/23/unique-paths/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> google </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> google </tag>
            
            <tag> high freq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>685. Redundant Connection II</title>
      <link href="/2019/03/19/685-Redundant-Connection-II/"/>
      <url>/2019/03/19/685-Redundant-Connection-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p><p>The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, …, N), with one additional directed edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p><p>The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.</p><p>Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [1,3], [2,3]]</span><br><span class="line">Output: [2,3]</span><br><span class="line">Explanation: The given directed graph will be like this:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">v   v</span><br><span class="line">2--&gt;3</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]</span><br><span class="line">Output: [4,1]</span><br><span class="line">Explanation: The given directed graph will be like this:</span><br><span class="line">5 &lt;- 1 -&gt; 2</span><br><span class="line">     ^    |</span><br><span class="line">     |    v</span><br><span class="line">     4 &lt;- 3</span><br></pre></td></tr></table></figure></p><p>Note:<br>The size of the input 2D-array will be between 3 and 1000.<br>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li><p>no cycle, but there’s a node have two parents</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[1,2], [1,3], [2,3]]</span><br><span class="line"></span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">v   v</span><br><span class="line">2--&gt;3</span><br></pre></td></tr></table></figure></li><li><p>have cycle, every node only have one parent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[1,2], [2,3], [3,4], [4,1], [1,5]]</span><br><span class="line"></span><br><span class="line">5 &lt;- 1 -&gt; 2</span><br><span class="line">     ^    |</span><br><span class="line">     |    v</span><br><span class="line">     4 &lt;- 3</span><br></pre></td></tr></table></figure></li><li><p>have cycle, there’s one node have two parents</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[1,2],[2,3],[3,1],[1,4]]</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">    /</span><br><span class="line">   v</span><br><span class="line">   1</span><br><span class="line"> /  ^</span><br><span class="line">v    \</span><br><span class="line">2 --&gt;3</span><br></pre></td></tr></table></figure></li></ol><p>1) Check whether there is a node having two parents.<br>    If so, store them as candidates A and B, and set the second edge invalid.<br>2) Perform normal union find.<br>    If the tree is now valid<br>           simply return candidate B<br>    else if candidates not existing<br>           we find a circle, return current edge;<br>    else<br>           remove candidate A instead of B.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findRedundantDirectedConnection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent(n+<span class="number">1</span>, <span class="number">0</span>), candA, candB;</span><br><span class="line">        <span class="comment">// step 1, check whether there is a node with two parents</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[edge[<span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">                parent[edge[<span class="number">1</span>]] = edge[<span class="number">0</span>]; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                candA = &#123;parent[edge[<span class="number">1</span>]], edge[<span class="number">1</span>]&#125;;</span><br><span class="line">                candB = edge;</span><br><span class="line">                edge[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// step 2, union find</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) parent[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge[<span class="number">1</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> u = edge[<span class="number">0</span>], v = edge[<span class="number">1</span>], pu = root(parent, u);</span><br><span class="line">            <span class="comment">// Now every node only has 1 parent, so root of v is implicitly v</span></span><br><span class="line">            <span class="keyword">if</span> (pu == v) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candA.empty()) <span class="keyword">return</span> edge;</span><br><span class="line">                <span class="keyword">return</span> candA;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[v] = pu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candB;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[k] != k) </span><br><span class="line">            parent[k] = root(parent, parent[k]);</span><br><span class="line">        <span class="keyword">return</span> parent[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> hard </tag>
            
            <tag> google </tag>
            
            <tag> dfs </tag>
            
            <tag> union find </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>find max sibling layer</title>
      <link href="/2019/03/18/find-max-sibling-layer/"/>
      <url>/2019/03/18/find-max-sibling-layer/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>pair bike and pedestrian</title>
      <link href="/2019/03/14/pair-bike-and-pedestrian/"/>
      <url>/2019/03/14/pair-bike-and-pedestrian/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>In 2D space, <code>m</code> people, <code>n</code> bikes, with the following conditions</p><ol><li><code>m&lt; n</code></li><li>does not exist two people that have same distance, <code>abs(x1-x2)+abs(y1-y2)</code>, between a bike.</li><li>everyone would find the bike that is the most closest to himself. If a bike is occupied, others can not use it.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OPOBOOP</span><br><span class="line">OOOOOOO</span><br><span class="line">OOOOOOO</span><br><span class="line">OOOOOOO</span><br><span class="line">BOOBOOB</span><br></pre></td></tr></table></figure></li></ol><h3 id="Solution-guidline"><a href="#Solution-guidline" class="headerlink" title="Solution guidline:"></a>Solution guidline:</h3><ol><li>需要跟面试官讨论清楚他需要的最佳匹配是什么</li><li><p>如果是要求全局人车距离最短</p><ol><li>二分图的最佳匹配问题，使用匈牙利算法，参考题目<a href="https://blog.csdn.net/u011721440/article/details/38169201" target="_blank" rel="noopener">https://blog.csdn.net/u011721440/article/details/38169201</a></li><li>发现这里不能使用max flow， 因为这个bipartite is a weighted graph. 参考 <a href="https://www.topcoder.com/community/competitive-programming/tutorials/assignment-problem-and-hungarian-algorithm/" target="_blank" rel="noopener">https://www.topcoder.com/community/competitive-programming/tutorials/assignment-problem-and-hungarian-algorithm/</a></li></ol></li><li><p>如果是要求最佳匹配只是给每个人匹配到车，可以用PQ+Map</p></li></ol><h3 id="PQ"><a href="#PQ" class="headerlink" title="PQ"></a>PQ</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BikeMatching</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BikeMatching(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; graph);</span><br><span class="line">    <span class="comment">//void init();</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">matching</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; people;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; bikes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited_man, visited_bike;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BikeMatching::BikeMatching(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; graph)&#123;</span><br><span class="line">    <span class="keyword">if</span>(graph.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j] == <span class="string">'O'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(graph[i][j] == <span class="string">'P'</span>)</span><br><span class="line">                people.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, j&#125;);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(graph[i][j] == <span class="string">'B'</span>)</span><br><span class="line">                bikes.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, j&#125;);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"incorrect input\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bikes.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> dis = <span class="built_in">abs</span>(people[i][<span class="number">0</span>]- bikes[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(people[i][<span class="number">1</span>] - bikes[j][<span class="number">1</span>]);</span><br><span class="line">            pq.push(make_pair(-dis, make_pair(i, j)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BikeMatching::matching()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(visited_man.size() != people.size())&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = pq.top(); pq.pop();</span><br><span class="line">        <span class="keyword">if</span>(visited_man.count(tmp.second.first) || visited_bike.count(tmp.second.second))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        visited_man.insert(tmp.second.first);</span><br><span class="line">        visited_bike.insert(tmp.second.second);</span><br><span class="line">        res.push_back(tmp.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> r: res)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"people at (%d, %d), pairs with (%d, %d)\n"</span>, people[r.first][<span class="number">0</span>], people[r.first][<span class="number">1</span>], bikes[r.second][<span class="number">0</span>], bikes[r.second][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; graph&#123;</span><br><span class="line">        &#123;<span class="string">'O'</span>, <span class="string">'P'</span>, <span class="string">'O'</span>, <span class="string">'B'</span>, <span class="string">'P'</span>, <span class="string">'O'</span>, <span class="string">'P'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'O'</span>, <span class="string">'O'</span>, <span class="string">'O'</span>, <span class="string">'O'</span>, <span class="string">'O'</span>, <span class="string">'O'</span>, <span class="string">'O'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'B'</span>, <span class="string">'O'</span>, <span class="string">'O'</span>, <span class="string">'B'</span>, <span class="string">'O'</span>, <span class="string">'O'</span>, <span class="string">'B'</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">BikeMatching <span class="title">ins</span><span class="params">(graph)</span></span>;</span><br><span class="line">    ins.matching();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br><a href="http://www.cnblogs.com/jackge/archive/2013/05/03/3057028.html" target="_blank" rel="noopener">http://www.cnblogs.com/jackge/archive/2013/05/03/3057028.html</a><br><a href="https://www.careercup.com/question?id=5687196447670272" target="_blank" rel="noopener">https://www.careercup.com/question?id=5687196447670272</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>log start</title>
      <link href="/2019/03/13/log-start/"/>
      <url>/2019/03/13/log-start/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>log timestamp. implement <code>start(id, timestamp)</code>, <code>end(id, timestamp)</code>, print the log in ascending time order.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use map to store the location of the node.<br>Double linked list to fast insert and delete</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    LogNode* prev, *next;</span><br><span class="line">    LogNode(<span class="built_in">string</span> _id, <span class="keyword">int</span> _start)&#123;</span><br><span class="line">        id= _id;</span><br><span class="line">        start = _start;</span><br><span class="line">        end = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Log()&#123;</span><br><span class="line">        head = <span class="keyword">new</span> LogNode(<span class="string">""</span>, <span class="number">-1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> LogNode(<span class="string">""</span>, <span class="number">-1</span>);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;;</span><br><span class="line">    LogNode *head, *tail;</span><br><span class="line">    <span class="comment">//list&lt;LogNode&gt; l;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, LogNode*&gt; <span class="built_in">map</span>; <span class="comment">//id, timestamp</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> id, <span class="keyword">int</span> timestamp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">(<span class="built_in">string</span> id, <span class="keyword">int</span> timestamp)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Log::add(<span class="built_in">string</span> id, <span class="keyword">int</span> timestamp)&#123;</span><br><span class="line">    LogNode *newNode= <span class="keyword">new</span> LogNode(id, timestamp);</span><br><span class="line">    <span class="built_in">map</span>[id] = newNode;</span><br><span class="line">    <span class="keyword">auto</span> tmp = tail-&gt;prev;</span><br><span class="line">    tmp-&gt;next = newNode;</span><br><span class="line">    newNode-&gt;prev = tmp;</span><br><span class="line">    newNode-&gt;next = tail;</span><br><span class="line">    tail-&gt;prev = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Log::end(<span class="built_in">string</span> id, <span class="keyword">int</span> timestamp)&#123;</span><br><span class="line">    <span class="keyword">auto</span> cur = <span class="built_in">map</span>.find(id);</span><br><span class="line">    <span class="keyword">if</span>(cur != <span class="built_in">map</span>.end() &amp;&amp; cur-&gt;second-&gt;end == <span class="number">-1</span>)&#123;</span><br><span class="line">        cur-&gt;second-&gt;end = timestamp;</span><br><span class="line">        <span class="built_in">map</span>.erase(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Log::print()&#123;</span><br><span class="line">    LogNode *cur = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur != tail)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;end != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s, start at %d, end at %d\n"</span>, cur-&gt;id.c_str(), cur-&gt;start, cur-&gt;end);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Log CLog;</span><br><span class="line">    CLog.add(<span class="string">"1"</span>, <span class="number">100</span>);</span><br><span class="line">    CLog.add(<span class="string">"2"</span>, <span class="number">101</span>);</span><br><span class="line">    CLog.end(<span class="string">"2"</span>, <span class="number">102</span>);</span><br><span class="line">    CLog.end(<span class="string">"1"</span>, <span class="number">202</span>);</span><br><span class="line">    CLog.print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note Union Find</title>
      <link href="/2019/03/12/note-Union-Find/"/>
      <url>/2019/03/12/note-Union-Find/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Union find is frequently used in graph problem. Pretty useful in cycle detection.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>reference:<br><a href="https://www.geeksforgeeks.org/union-find/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/union-find/</a><br><a href="https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf" target="_blank" rel="noopener">https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf</a></p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> union find </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>803. Bricks Falling When Hit</title>
      <link href="/2019/03/10/803-Bricks-Falling-When-Hit/"/>
      <url>/2019/03/10/803-Bricks-Falling-When-Hit/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.</p><p>We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.</p><p>Return an array representing the number of bricks that will drop after each erasure in sequence.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: </span><br><span class="line">grid = [[1,0,0,0],[1,1,1,0]]</span><br><span class="line">hits = [[1,0]]</span><br><span class="line">Output: [2]</span><br><span class="line">Explanation: </span><br><span class="line">If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input: </span><br><span class="line">grid = [[1,0,0,0],[1,1,0,0]]</span><br><span class="line">hits = [[1,1],[1,0]]</span><br><span class="line">Output: [0,0]</span><br><span class="line">Explanation: </span><br><span class="line">When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.</span><br></pre></td></tr></table></figure><p>Note:</p><p>The number of rows and columns in the grid will be in the range [1, 200].<br>The number of erasures will not exceed the area of the grid.<br>It is guaranteed that each erasure will be different from any other erasure, and located inside the grid.<br>An erasure may refer to a location with no brick - if it does, no bricks drop.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ul><li>DFS with memorization<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hitBricks(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; hits) &#123;</span><br><span class="line">        <span class="keyword">int</span> m= grid.size(), n= grid[<span class="number">0</span>].size(), k= hits.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(k);</span><br><span class="line">        <span class="comment">//unordered_set&lt;int&gt; noDrop;</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; noDrop;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; k; i++) grid[hits[i][<span class="number">0</span>]][hits[i][<span class="number">1</span>]]-= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(grid[<span class="number">0</span>][i] == <span class="number">1</span>) check(grid, <span class="number">0</span>, i, noDrop);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= k<span class="number">-1</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> oldSize= noDrop.size(), x= hits[i][<span class="number">0</span>], y= hits[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(++grid[x][y]!= <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//was empty-&gt; 0, not falling-&gt; 2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( x<span class="number">-1</span>&gt;= <span class="number">0</span> &amp;&amp; noDrop.count(to_string(x<span class="number">-1</span>)+ <span class="string">","</span>+to_string(y))</span><br><span class="line">              || x+<span class="number">1</span>&lt; m &amp;&amp; noDrop.count(to_string(x+<span class="number">1</span>)+ <span class="string">","</span>+to_string(y))</span><br><span class="line">               || y<span class="number">-1</span>&gt;= <span class="number">0</span> &amp;&amp; noDrop.count(to_string(x)+ <span class="string">","</span>+to_string(y<span class="number">-1</span>))</span><br><span class="line">               || y+<span class="number">1</span>&lt; n &amp;&amp; noDrop.count(to_string(x)+ <span class="string">","</span>+to_string(y+<span class="number">1</span>))</span><br><span class="line">               || x == <span class="number">0</span>)&#123;</span><br><span class="line">                check(grid, x, y, noDrop);</span><br><span class="line">                res[i]= noDrop.size()-oldSize<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; noDrop)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m= grid.size(), n= grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">string</span> node= to_string(i)+<span class="string">","</span>+to_string(j);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i&gt;= m || j&lt; <span class="number">0</span> || j&gt;= n || grid[i][j]!= <span class="number">1</span> || noDrop.count(node)) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        noDrop.insert(node);</span><br><span class="line">        check(grid, i<span class="number">-1</span>, j, noDrop);</span><br><span class="line">        check(grid, i+<span class="number">1</span>, j, noDrop);</span><br><span class="line">        check(grid, i, j<span class="number">-1</span>, noDrop);</span><br><span class="line">        check(grid, i, j+<span class="number">1</span>, noDrop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>951. Flip Equivalent Binary Trees</title>
      <link href="/2019/03/10/951-Flip-Equivalent-Binary-Trees/"/>
      <url>/2019/03/10/951-Flip-Equivalent-Binary-Trees/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p><p>A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p><p>Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes root1 and root2.</p><p>Example 1:</p><p>Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]<br>Output: true<br>Explanation: We flipped at nodes with values 1, 3, and 5.<br>Flipped Trees Diagram<br><img src="tree_ex.png" alt=""></p><p>Note:</p><p>Each tree will have at most 100 nodes.<br>Each value in each tree will be a unique integer in the range [0, 99].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">flipEquiv</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root1) <span class="keyword">return</span> !root2;</span><br><span class="line">        <span class="keyword">if</span>(!root2) <span class="keyword">return</span> !root1;</span><br><span class="line">        <span class="keyword">if</span>(root1-&gt;val != root2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (flipEquiv(root1-&gt;left, root2-&gt;left) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;right) || flipEquiv(root1-&gt;left, root2-&gt;right) &amp;&amp; flipEquiv(root1-&gt;right, root2-&gt;left));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>777. Swap Adjacent in LR String</title>
      <link href="/2019/03/09/777-Swap-Adjacent-in-LR-String/"/>
      <url>/2019/03/09/777-Swap-Adjacent-in-LR-String/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>In a string composed of ‘L’, ‘R’, and ‘X’ characters, like “RXXLRXRXL”, a move consists of either replacing one occurrence of “XL” with “LX”, or replacing one occurrence of “RX” with “XR”. Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">We can transform start to end following these steps:</span><br><span class="line">RXXLRXRXL -&gt;</span><br><span class="line">XRXLRXRXL -&gt;</span><br><span class="line">XRLXRXRXL -&gt;</span><br><span class="line">XRLXXRRXL -&gt;</span><br><span class="line">XRLXXRRLX</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>1 &lt;= len(start) = len(end) &lt;= 10000.<br>Both start and end will only consist of characters in {‘L’, ‘R’, ‘X’}.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>In the given string start, L can move to the left but can’t pass through R, R can move to the right but can’t pass through L. Basically, there are 4 situations (when start[i] != ‘X’ and end[j] != ‘X’):</p><ul><li>start[i] != end[j] return false, cause L and R can’t pass through each other.</li><li><p>start[i] == ‘L’ &amp;&amp; j &gt; i return false, cause L can’t move to the right. </p><ul><li>RX XR: true</li><li>XR RX: falase</li></ul></li><li><p>start[i] == ‘R’ &amp;&amp; j &lt; i return false cause R can’t move to the left.</p><ul><li>XL LX: true</li><li>LX XL: false</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool canTransform(string s, string t) &#123;</span><br><span class="line">        if(s.length() != t.length()) return false;</span><br><span class="line">        </span><br><span class="line">        for(int i= 0, j= 0; i&lt; s.length(), j&lt; t.length();)&#123;</span><br><span class="line">            if(s[i] == &apos;X&apos;) i++;</span><br><span class="line">            if(t[j] == &apos;X&apos;) j++;</span><br><span class="line">            </span><br><span class="line">            if(s[i] != &apos;X&apos; &amp;&amp; t[j] != &apos;X&apos;)&#123;</span><br><span class="line">                if(s[i] != t[j]) return false;</span><br><span class="line">                else if(s[i] == &apos;L&apos; &amp;&amp; j&gt; i) return false;</span><br><span class="line">                else if(s[i] == &apos;R&apos; &amp;&amp; i&gt; j) return false;</span><br><span class="line">                else&#123;</span><br><span class="line">                    //printf(&quot;%c, %c, %d, %d\n&quot;, s[i], t[j], i, j);</span><br><span class="line">                    i++, j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>750. Number Of Corner Rectangles</title>
      <link href="/2019/03/08/750-Number-Of-Corner-Rectangles/"/>
      <url>/2019/03/08/750-Number-Of-Corner-Rectangles/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a grid where each entry is only 0 or 1, find the number of corner rectangles.</p><p>A corner rectangle is 4 distinct 1s on the grid that form an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1s used must be distinct.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = </span><br><span class="line">[[1, 0, 0, 1, 0],</span><br><span class="line"> [0, 0, 1, 0, 1],</span><br><span class="line"> [0, 0, 0, 1, 0],</span><br><span class="line"> [1, 0, 1, 0, 1]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4].</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = </span><br><span class="line">[[1, 1, 1],</span><br><span class="line"> [1, 1, 1],</span><br><span class="line"> [1, 1, 1]]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = </span><br><span class="line">[[1, 1, 1, 1]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Rectangles must have four distinct corners.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>The number of rows and columns of grid will each be in the range [1, 200].<br>Each grid[i][j] will be either 0 or 1.<br>The number of 1s in the grid will be at most 6000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ul><li>Naive solution:<br>Find four corner points by traversing the grid in $O(m^2 * n^2)$ time.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCornerRectangles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//find corners start from top-left</span></span><br><span class="line">        <span class="comment">//only need four corner points to be 1</span></span><br><span class="line">        <span class="keyword">int</span> m= grid.size(), n= grid[<span class="number">0</span>].size(), res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="comment">//no need to continue if top-left is 0</span></span><br><span class="line">                </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"i, j grid[%d][%d] is 1\n"</span>, i, j);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p= i+<span class="number">1</span>; p&lt; m; p++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[p][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"grid[%d][%d] is 0\n"</span>, p, j);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                        </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"grid[%d][%d] is 1\n"</span>, p, j);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> q= j+<span class="number">1</span>; q&lt; n; q++)&#123;</span><br><span class="line">                        res+= grid[p][q] &amp;&amp; grid[i][q];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:<br><a href="https://goo.gl/iFofQc" target="_blank" rel="noopener">https://goo.gl/iFofQc</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>497. Random Point in Non-overlapping Rectangles</title>
      <link href="/2019/03/07/497-Random-Point-in-Non-overlapping-Rectangles/"/>
      <url>/2019/03/07/497-Random-Point-in-Non-overlapping-Rectangles/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles.</p><p>Note:</p><p>An integer point is a point that has integer coordinates.<br>A point on the perimeter of a rectangle is included in the space covered by the rectangles.<br>ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner.<br>length and width of each rectangle does not exceed 2000.<br>1 &lt;= rects.length &lt;= 100<br>pick return a point as an array of integer coordinates [p_x, p_y]<br>pick is called at most 10000 times.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;]</span><br><span class="line">[[[[1,1,5,5]]],[],[],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,[4,1],[4,1],[3,3]]</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;Solution&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;,&quot;pick&quot;]</span><br><span class="line">[[[[-2,-2,-1,-1],[1,0,3,0]]],[],[],[],[],[]]</span><br><span class="line">Output: </span><br><span class="line">[null,[-1,-2],[2,0],[-2,-1],[3,0],[-2,-2]]</span><br></pre></td></tr></table></figure></p><p>Explanation of Input Syntax:</p><p>The input is two lists: the subroutines called and their arguments. Solution’s constructor has one argument, the array of rectangles rects. pick has no arguments. Arguments are always wrapped with a list, even if there aren’t any.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rects) &#123;</span><br><span class="line">        _rects = rects;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pick() &#123;</span><br><span class="line">        <span class="keyword">int</span> sumArea = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; selected;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> rect : _rects) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = (rect[<span class="number">2</span>] - rect[<span class="number">0</span>] + <span class="number">1</span>) * (rect[<span class="number">3</span>] - rect[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            sumArea += area;</span><br><span class="line">            <span class="keyword">if</span> (rand() % sumArea &lt; area) selected = rect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = rand() % (selected[<span class="number">2</span>] - selected[<span class="number">0</span>] + <span class="number">1</span>) + selected[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = rand() % (selected[<span class="number">3</span>] - selected[<span class="number">1</span>] + <span class="number">1</span>) + selected[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; _rects;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(rects);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj.pick();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Solution(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rects) &#123;</span><br><span class="line">        _rects = rects;</span><br><span class="line">        _totalArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> rect : rects) &#123;</span><br><span class="line">            _totalArea += (rect[<span class="number">2</span>] - rect[<span class="number">0</span>] + <span class="number">1</span>) * (rect[<span class="number">3</span>] - rect[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            _areaToIdx.insert(&#123;_totalArea, _areaToIdx.size()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pick() &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % _totalArea;</span><br><span class="line">        <span class="keyword">int</span> idx = _areaToIdx.upper_bound(val)-&gt;second;</span><br><span class="line">        <span class="keyword">int</span> width = _rects[idx][<span class="number">2</span>] - _rects[idx][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> height = _rects[idx][<span class="number">3</span>] - _rects[idx][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;rand() % width + _rects[idx][<span class="number">0</span>], rand() % height + _rects[idx][<span class="number">1</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; _rects;</span><br><span class="line">    <span class="keyword">int</span> _totalArea;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; _areaToIdx;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>939. Minimum Area Rectangle</title>
      <link href="/2019/03/06/939-Minimum-Area-Rectangle/"/>
      <url>/2019/03/06/939-Minimum-Area-Rectangle/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.</p><p>If there isn’t any rectangle, return 0.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[1,3],[3,1],[3,3],[2,2]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>1 &lt;= points.length &lt;= 500<br>0 &lt;= points[i][0] &lt;= 40000<br>0 &lt;= points[i][1] &lt;= 40000<br>All points are distinct.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAreaRect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minarea= INT_MAX;</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pointSet;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> point: points)</span><br><span class="line">            pointSet.insert(make_pair(point[<span class="number">0</span>], point[<span class="number">1</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; points.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= i+<span class="number">1</span>; j&lt; points.size(); j++)&#123;</span><br><span class="line">                <span class="comment">//points[i]</span></span><br><span class="line">                <span class="comment">//points[j]</span></span><br><span class="line">                <span class="keyword">int</span> x1= points[i][<span class="number">0</span>], y1= points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> x2= points[j][<span class="number">0</span>], y2= points[j][<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(x1!=x2 &amp;&amp; y1!=y2 &amp;&amp; x1!=y2 &amp;&amp; x2!=y1)</span><br><span class="line">                    <span class="keyword">if</span>(pointSet.count(&#123;x1, y2&#125;) &amp;&amp; pointSet.count(&#123;x2, y1&#125;))&#123;</span><br><span class="line">                        minarea= min(minarea, <span class="built_in">abs</span>((x2-x1)*(y2-y1)));</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minarea == INT_MAX? <span class="number">0</span>: minarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^2)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>833. Find And Replace in String</title>
      <link href="/2019/03/06/833-Find-And-Replace-in-String/"/>
      <url>/2019/03/06/833-Find-And-Replace-in-String/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p><p>Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing.</p><p>For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”.</p><p>Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’.</p><p>All these operations occur simultaneously.  It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeebffff&quot;</span><br><span class="line">Explanation: &quot;a&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;.</span><br><span class="line">&quot;cd&quot; starts at index 2 in S, so it&apos;s replaced by &quot;ffff&quot;.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeecd&quot;</span><br><span class="line">Explanation: &quot;ab&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;. </span><br><span class="line">&quot;ec&quot; doesn&apos;t starts at index 2 in the original S, so we do nothing.</span><br></pre></td></tr></table></figure></p><p>Notes:</p><p>0 &lt;= indexes.length = sources.length = targets.length &lt;= 100<br>0 &lt; indexes[i] &lt; S.length &lt;= 1000<br>All characters in given inputs are lowercase letters.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findReplaceString</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indexes, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; sources, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; targets)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; replace;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; indexes.size(); i++)&#123;</span><br><span class="line">            replace.push_back(make_pair(indexes[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(replace.rbegin(), replace.rend());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: replace)&#123;</span><br><span class="line">            <span class="keyword">int</span> i= n.first;</span><br><span class="line">            <span class="built_in">string</span> s= sources[n.second], t= targets[n.second];</span><br><span class="line">            <span class="keyword">if</span>(S.substr(i, s.length()) == s)</span><br><span class="line">                S= S.substr(<span class="number">0</span>, i)+ t + S.substr(i+s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(SN)$<br>space complexity: $O(N)$<br>reference:<br><a href="https://goo.gl/uKL6KV" target="_blank" rel="noopener">https://goo.gl/uKL6KV</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>853. Car Fleet</title>
      <link href="/2019/03/04/853-Car-Fleet/"/>
      <url>/2019/03/04/853-Car-Fleet/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p><code>N</code> cars are going to the same destination along a one lane road.  The destination is target miles away.</p><p>Each car <code>i</code> has a constant speed <code>speed[i]</code> (in miles per hour), and initial position <code>position[i]</code> miles towards the target along the road.</p><p>A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.</p><p>The distance between these two cars is ignored - they are assumed to have the same position.</p><p>A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet.</p><p>If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.</p><p>How many car fleets will arrive at the destination?</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The cars starting at 10 and 8 become a fleet, meeting each other at 12.</span><br><span class="line">The car starting at 0 doesn&apos;t catch up to any other car, so it is a fleet by itself.</span><br><span class="line">The cars starting at 5 and 3 become a fleet, meeting each other at 6.</span><br><span class="line">Note that no other cars meet these fleets before the destination, so the answer is 3.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>0 &lt;= N &lt;= 10 ^ 4<br>0 &lt; target &lt;= 10 ^ 6<br>0 &lt; speed[i] &lt;= 10 ^ 6<br>0 &lt;= position[i] &lt; target<br>All initial positions are different.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The mean idea is to determine what time for each car would get to the <code>target</code>. Also, need to sort the car in a descending order. The reason is, car close to <code>target</code> at original <code>position</code> would block other following cars and make a fleet.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">carFleet</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; position.size(); i++)</span><br><span class="line">            <span class="built_in">map</span>[-position[i]] = (<span class="keyword">double</span>)(target-position[i])/speed[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> fleet= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> time= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m: <span class="built_in">map</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.second&gt; time)</span><br><span class="line">                fleet++, time= m.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fleet;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">carFleet</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cars;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; position.size(); i++)</span><br><span class="line">            cars.push_back(&#123;position[i], speed[i]&#125;);</span><br><span class="line">        </span><br><span class="line">        sort(cars.begin(), cars.end());</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= cars.size()<span class="number">-1</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">double</span> tmp= (<span class="keyword">double</span>)(target-cars[i].first)/cars[i].second;</span><br><span class="line">            <span class="keyword">if</span>(stk.empty() || tmp &gt; stk.top())</span><br><span class="line">                stk.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>855. Exam Room</title>
      <link href="/2019/03/04/855-Exam-Room/"/>
      <url>/2019/03/04/855-Exam-Room/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>In an exam room, there are N seats in a single row, numbered 0, 1, 2, …, N-1.</p><p>When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)</p><p>Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]</span><br><span class="line">Output: [null,0,9,4,2,null,5]</span><br><span class="line">Explanation:</span><br><span class="line">ExamRoom(10) -&gt; null</span><br><span class="line">seat() -&gt; 0, no one is in the room, then the student sits at seat number 0.</span><br><span class="line">seat() -&gt; 9, the student sits at the last seat number 9.</span><br><span class="line">seat() -&gt; 4, the student sits at the last seat number 4.</span><br><span class="line">seat() -&gt; 2, the student sits at the last seat number 2.</span><br><span class="line">leave(4) -&gt; null</span><br><span class="line">seat() -&gt; 5, the student sits at the last seat number 5.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>1 &lt;= N &lt;= 10^9<br>ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases.<br>Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>find where have max distance</li><li>find value to insert</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExamRoom</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">    </span><br><span class="line">    ExamRoom(<span class="keyword">int</span> N) &#123;</span><br><span class="line">        n= N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">seat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            L.push_back(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> d= max(L[<span class="number">0</span>], n<span class="number">-1</span>- L.back());</span><br><span class="line">        <span class="comment">//printf("back= %d, %d\n", L.back(), L[L.size()-1]);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; L.size()<span class="number">-1</span>; i++)</span><br><span class="line">            d= max(d, (L[i+<span class="number">1</span>]- L[i])/<span class="number">2</span>); <span class="comment">//find position to insert, so this is finding the middle point between two slots</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(L[<span class="number">0</span>] == d)&#123;</span><br><span class="line">            L.insert(L.begin(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; L.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (L[i+<span class="number">1</span>]-L[i])/<span class="number">2</span> == d)&#123;</span><br><span class="line">                <span class="comment">//need to find value for insert</span></span><br><span class="line">                L.insert(L.begin()+i+<span class="number">1</span>, (L[i+<span class="number">1</span>]+L[i])/<span class="number">2</span>); </span><br><span class="line">                <span class="keyword">return</span> L[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        L.push_back(n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leave</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; L.size(); i++)</span><br><span class="line">            <span class="keyword">if</span>(L[i] == p)&#123;</span><br><span class="line">                L.erase(L.begin()+i);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: L)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ExamRoom object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ExamRoom obj = new ExamRoom(N);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.seat();</span></span><br><span class="line"><span class="comment"> * obj.leave(p);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>890. Find and Replace Pattern</title>
      <link href="/2019/03/03/890-Find-and-Replace-Pattern/"/>
      <url>/2019/03/03/890-Find-and-Replace-Pattern/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You have a list of words and a pattern, and you want to know which words in words matches the pattern.</p><p>A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.</p><p>(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)</p><p>Return a list of the words in words that match the given pattern. </p><p>You may return the answer in any order.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;</span><br><span class="line">Output: [&quot;mee&quot;,&quot;aqq&quot;]</span><br><span class="line">Explanation: &quot;mee&quot; matches the pattern because there is a permutation &#123;a -&gt; m, b -&gt; e, ...&#125;. </span><br><span class="line">&quot;ccc&quot; does not match the pattern because &#123;a -&gt; c, b -&gt; c, ...&#125; is not a permutation,</span><br><span class="line">since a and b map to the same letter.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>1 &lt;= words.length &lt;= 50<br>1 &lt;= pattern.length = words[i].length &lt;= 20</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>build a function that can normalize the string into a same form.<br>if a word appears the first time, then we mark it as the size of string in the map.<br>Since all same pattern would have new letter in the same position, after normalize, they’ll become same word.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findAndReplacePattern(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> p) &#123;</span><br><span class="line">        <span class="comment">//normalize words into same patter</span></span><br><span class="line">        <span class="comment">//ex: ppood -&gt; aabbc, qqwwf -&gt; aabbc</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w: words)&#123;</span><br><span class="line">            <span class="keyword">if</span>(normalize(w) == normalize(p)) res.push_back(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">normalize</span><span class="params">(<span class="built_in">string</span> w)</span></span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: w) <span class="keyword">if</span>(!<span class="built_in">map</span>.count(c)) <span class="built_in">map</span>[c]= <span class="built_in">map</span>.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; w.length(); i++) </span><br><span class="line">            w[i]= <span class="string">'a'</span>+ <span class="built_in">map</span>[w[i]];</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n*m)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/M1DEku" target="_blank" rel="noopener">https://goo.gl/M1DEku</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>489. Robot Room Cleaner</title>
      <link href="/2019/03/02/489-Robot-Room-Cleaner/"/>
      <url>/2019/03/02/489-Robot-Room-Cleaner/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a robot cleaner in a room modeled as a grid.</p><p>Each cell in the grid can be empty or blocked.</p><p>The robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it made is 90 degrees.</p><p>When it tries to move into a blocked cell, its bumper sensor detects the obstacle and it stays on the current cell.</p><p>Design an algorithm to clean the entire room using only the 4 given APIs shown below.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Robot &#123;</span><br><span class="line">  // returns true if next cell is open and robot moves into the cell.</span><br><span class="line">  // returns false if next cell is obstacle and robot stays on the current cell.</span><br><span class="line">  boolean move();</span><br><span class="line"></span><br><span class="line">  // Robot will stay on the same cell after calling turnLeft/turnRight.</span><br><span class="line">  // Each turn will be 90 degrees.</span><br><span class="line">  void turnLeft();</span><br><span class="line">  void turnRight();</span><br><span class="line"></span><br><span class="line">  // Clean the current cell.</span><br><span class="line">  void clean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Example:</p><p>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">room = [</span><br><span class="line">  [1,1,1,1,1,0,1,1],</span><br><span class="line">  [1,1,1,1,1,0,1,1],</span><br><span class="line">  [1,0,1,1,1,1,1,1],</span><br><span class="line">  [0,0,0,1,0,0,0,0],</span><br><span class="line">  [1,1,1,1,1,1,1,1]</span><br><span class="line">],</span><br><span class="line">row = 1,</span><br><span class="line">col = 3</span><br></pre></td></tr></table></figure></p><p>Explanation:<br>All grids in the room are marked by either 0 or 1.<br>0 means the cell is blocked, while 1 means the cell is accessible.<br>The robot initially starts at the position of row=1, col=3.<br>From the top left corner, its position is one row below and three columns right.<br>Notes:</p><p>The input is only given to initialize the room and the robot’s position internally. You must solve this problem “blindfolded”. In other words, you must control the robot using only the mentioned 4 APIs, without knowing the room layout and the initial robot’s position.<br>The robot’s initial position will always be in an accessible cell.<br>The initial direction of the robot will be facing up.<br>All accessible cells are connected, which means the all cells marked as 1 will be accessible by the robot.<br>Assume all four edges of the grid are all surrounded by wall.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>Use parameter to track the <code>location</code> and <code>direction</code> of robot</li><li>Need to <code>go back</code> to original location and <code>turn to original direction</code> after backtracking</li><li>Use set to remember visited place</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the robot's control interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class Robot &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Returns true if the cell in front is open and robot moves into the cell.</span></span><br><span class="line"><span class="comment"> *     // Returns false if the cell in front is blocked and robot stays in the current cell.</span></span><br><span class="line"><span class="comment"> *     bool move();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Robot will stay in the same cell after calling turnLeft/turnRight.</span></span><br><span class="line"><span class="comment"> *     // Each turn will be 90 degrees.</span></span><br><span class="line"><span class="comment"> *     void turnLeft();</span></span><br><span class="line"><span class="comment"> *     void turnRight();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Clean the current cell.</span></span><br><span class="line"><span class="comment"> *     void clean();</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanRoom</span><span class="params">(Robot&amp; robot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//need something record visited place</span></span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; visited;</span><br><span class="line">        <span class="comment">//direction 0: up, 1: right, 2: down, 3: left</span></span><br><span class="line">        dfs(visited, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, robot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> curDir, Robot&amp; robot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.count(make_pair(i, j))) <span class="keyword">return</span>;</span><br><span class="line">        visited.insert(make_pair(i, j));</span><br><span class="line">        robot.clean();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k= <span class="number">0</span>; k&lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x= i, y= j;</span><br><span class="line">            <span class="keyword">if</span>(robot.move())&#123;</span><br><span class="line">                <span class="keyword">switch</span>(curDir)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>: x-= <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>: y+= <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>: x+= <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>: y-= <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(visited, x, y, curDir, robot);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//go back to original place, because dfs is our helper function</span></span><br><span class="line">                <span class="comment">//function return does not make the robot move back</span></span><br><span class="line">                robot.turnRight();</span><br><span class="line">                robot.turnRight();</span><br><span class="line">                robot.move();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//redirect to curDir</span></span><br><span class="line">                robot.turnRight();</span><br><span class="line">                robot.turnRight();</span><br><span class="line">            &#125;</span><br><span class="line">            robot.turnRight();</span><br><span class="line">            curDir += <span class="number">1</span>;</span><br><span class="line">            curDir %= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>design Elevator</title>
      <link href="/2019/02/26/design-Elevator/"/>
      <url>/2019/02/26/design-Elevator/</url>
      <content type="html"><![CDATA[<p>Design interview questions can be pretty vague and answers often depends on interviewers requirement.</p><p>But there are some generic steps that you can follow:</p><p>Gather requirements<br>Think about best data structure that can be used<br>How important are Latency, Consistency and Availability for your system?<br>How is concurrency handled in your system?<br>How many classes will be there and what will be their methods<br>For example,</p><p>Some simple requirements for your question would be:</p><p>For users:</p><p>call an elevator by pressing buttons in lobby.<br>Choose a floor<br>For System:</p><p>get all available elevators<br>choose any available elevator and send it on the requested floor (this can be optimized)<br>get list of all floors where elevator is supposed to make a stop<br>Classes :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElevatorSystem</span> &#123;</span></span><br><span class="line">  Elevator[] elevators;</span><br><span class="line">  <span class="keyword">int</span> totalFloors; <span class="comment">// total floors in the building</span></span><br><span class="line">  Queue&lt;Elevator&gt; availableElevators; <span class="comment">// Queue of all available floors</span></span><br><span class="line">  boolean[] requestedFloors; <span class="comment">// all the floors from where an elevator was requested</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Elevator <span class="title">getNearestAvailableElevator</span><span class="params">(floorNumber)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callElevator</span><span class="params">(floorNumber, elevator)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloorLobby</span> &#123;</span></span><br><span class="line">  Button up;</span><br><span class="line">  Button down;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elevator</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">int</span> currentFloor;</span><br><span class="line">  boolean goUp; <span class="comment">// is elevator suppose to go up</span></span><br><span class="line">  boolean goDown;</span><br><span class="line">  boolean[] isAStop; <span class="comment">// flags all floors on which elevator is suppose to stop</span></span><br><span class="line">  Button[] buttons;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAsAvailable</span><span class="params">(id)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gotoFloor</span><span class="params">(<span class="built_in">floor</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">currentFloor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> buttonId;</span><br><span class="line">  <span class="keyword">int</span> floorNumber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/q1OYej" target="_blank" rel="noopener">https://goo.gl/q1OYej</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>239. Sliding Window Maximum</title>
      <link href="/2019/02/26/239-Sliding-Window-Maximum/"/>
      <url>/2019/02/26/239-Sliding-Window-Maximum/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3</span><br><span class="line">Output: [3,3,5,5,6,7] </span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure></p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p><p>Follow up:<br>Could you solve it in linear time?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The basic idea is to use a deque (buffer) to save all currently potential “maximum” elements (i.e. the element in the current k-element window [i-k+1, i], and it is larger than the elements after itself). </p><p>So for each i, we first pop up the elements that are no larger than nums[i] from buffer until we find one that is larger than nums[i] or the buffer is empty since those elements will be covered by nums[i] and can not be a maximum of any k-element window. </p><p>Then we put nums[i] in the buffer. If i&gt;=k-1, we need to ouput the maximum for window [i-k+1, i], which is the front element of buffer. At last, we will check if the front element is nums[i-k+1], if so, we have to pop it up since it will be out of the window [i-k+2, i+1] in the next iteration. Since all the elements will be pushed into/ popped out of the buffer only once, so the time complexity is O(N).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!deq.empty() &amp;&amp; nums[i] &gt;= nums[deq.back()]) &#123;</span><br><span class="line">                <span class="comment">//printf("pop out: nums[%d]=%d\n", deq.back(), nums[deq.back()]);</span></span><br><span class="line">                deq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            deq.push_back(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) res.push_back(nums[deq.front()]);</span><br><span class="line">            <span class="keyword">if</span>(deq.front() &lt;= i-k+<span class="number">1</span>) deq.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(k)$<br>reference:<br><a href="https://goo.gl/mvk9ht" target="_blank" rel="noopener">https://goo.gl/mvk9ht</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>490. The Maze</title>
      <link href="/2019/02/22/490-The-Maze/"/>
      <url>/2019/02/22/490-The-Maze/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p><p>Given the ball’s start position, the destination and the maze, determine whether the ball could stop at the destination.</p><p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input 1: a maze represented by a 2D array</span><br><span class="line"></span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0 1 0</span><br><span class="line">1 1 0 1 1</span><br><span class="line">0 0 0 0 0</span><br><span class="line"></span><br><span class="line">Input 2: start coordinate (rowStart, colStart) = (0, 4)</span><br><span class="line">Input 3: destination coordinate (rowDest, colDest) = (4, 4)</span><br><span class="line"></span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Explanation: One possible way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.</span><br></pre></td></tr></table></figure></p><p><img src="maze_1.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input 1: a maze represented by a 2D array</span><br><span class="line"></span><br><span class="line">0 0 1 0 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0 1 0</span><br><span class="line">1 1 0 1 1</span><br><span class="line">0 0 0 0 0</span><br><span class="line"></span><br><span class="line">Input 2: start coordinate (rowStart, colStart) = (0, 4)</span><br><span class="line">Input 3: destination coordinate (rowDest, colDest) = (3, 2)</span><br><span class="line"></span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Explanation: There is no way for the ball to stop at the destination.</span><br></pre></td></tr></table></figure><p><img src="maze_2.png" alt=""></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ul><li>DFS</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; direction&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; destination)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visited;</span><br><span class="line">        <span class="keyword">return</span> dfs(maze, start, destination, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; destination, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == destination) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited.find(start) != visited.end()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited.insert(start);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; direction.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> res= Go2End(maze, start, direction[i]);</span><br><span class="line">            <span class="keyword">if</span>(res == destination || dfs(maze, res, destination, visited)) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Go2End(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; start, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; direction)&#123;</span><br><span class="line">        <span class="keyword">int</span> i= start[<span class="number">0</span>]+ direction[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> j= start[<span class="number">1</span>]+ direction[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> m= maze.size();</span><br><span class="line">        <span class="keyword">int</span> n= maze[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || maze[i][j] == <span class="number">1</span>) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newStart&#123;i, j&#125;;</span><br><span class="line">        <span class="keyword">return</span> Go2End(maze, newStart, direction);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>857. Minimum Cost to Hire K Workers</title>
      <link href="/2019/02/20/857-Minimum-Cost-to-Hire-K-Workers/"/>
      <url>/2019/02/20/857-Minimum-Cost-to-Hire-K-Workers/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].</p><p>Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:</p><p>Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.<br>Every worker in the paid group must be paid at least their minimum wage expectation.<br>Return the least amount of money needed to form a paid group satisfying the above conditions.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: quality = [10,20,5], wage = [70,50,30], K = 2</span><br><span class="line">Output: 105.00000</span><br><span class="line">Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3</span><br><span class="line">Output: 30.66667</span><br><span class="line">Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>1 &lt;= K &lt;= N &lt;= 10000, where N = quality.length = wage.length<br>1 &lt;= quality[i] &lt;= 10000<br>1 &lt;= wage[i] &lt;= 10000<br>Answers within 10^-5 of the correct answer will be considered correct.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use heap to sort the ratio of (wage/quality).<br>With the priority_queue, we can ensure that we find the higher quality but cheaper worker.<br>When the heap reaches the predefined size, calculate the total wages again.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">mincostToHireWorkers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; q, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; workers;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q.size(); ++i)</span><br><span class="line">            workers.push_back(&#123;(<span class="keyword">double</span>)(w[i]) / q[i], (<span class="keyword">double</span>)q[i]&#125;);</span><br><span class="line">        sort(workers.begin(), workers.end());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//for(auto worker: workers)</span></span><br><span class="line">        <span class="comment">//    printf("%f, %f\n", worker[0], worker[1]);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> res = DBL_MAX, qsum = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> worker: workers) &#123;</span><br><span class="line">            <span class="comment">//printf("")</span></span><br><span class="line">            qsum += worker[<span class="number">1</span>], pq.push(worker[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; K) qsum -= pq.top(), pq.pop();</span><br><span class="line">            <span class="comment">//printf("res= %f, qsum*worker[0]= %f\n", res, qsum * worker[0]);</span></span><br><span class="line">            <span class="keyword">if</span> (pq.size() == K) res = min(res, qsum * worker[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$, $O(n)$ for the worker iteration, $O(logn)$ because heap insertion<br>space complexity: $O(n)$<br>reference:<br><a href="https://www.cnblogs.com/lightwindy/p/9795918.html" target="_blank" rel="noopener">https://www.cnblogs.com/lightwindy/p/9795918.html</a><br><a href="https://goo.gl/qmbR5h" target="_blank" rel="noopener">https://goo.gl/qmbR5h</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> google </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sajfd hfafbjhd</title>
      <link href="/2019/02/08/sajfd-hfafbjhd/"/>
      <url>/2019/02/08/sajfd-hfafbjhd/</url>
      <content type="html"><![CDATA[<p>CSCE 670 :: Information Storage and Retrieval :: Texas A&amp;M University :: Spring 2019</p><p>For this part, your goal is to put on your “search engine optimization” hat. Your job is to create a webpage that scores highest for the query: <a href="https://www.google.com/search?q=sajfd+hfafbjhd" target="_blank" rel="noopener">sajfd hfafbjhd</a> — two <a href="https://www.google.com/search?q=terms" target="_blank" rel="noopener">terms</a>, <a href="https://www.google.com/search?q=lower+case" target="_blank" rel="noopener">lower case</a>, no quote. As of today (Jan 24, 2019), there are no hits for this query on either <a href="www.google.com">Google</a><br> or <a href="https://www.bing.com/" target="_blank" rel="noopener">Bing</a>. Based on our discussions of <a href="https://en.wikipedia.org/wiki/Search_engine_optimization" target="_blank" rel="noopener">search engine ranking algorithms</a>, you know that several factors may impact a <a href="https://www.google.com/search?q=page+rank" target="_blank" rel="noopener">page’s rank</a>. Your goal is to use this knowledge to promote your own page to the top of the list.</p><p><img src="SEO.jpg" alt=""></p><p>What we’re doing here is a form of <a href="https://en.wikipedia.org/wiki/SEO_contest" target="_blank" rel="noopener">SEO contest</a>. While you have great latitude in how you approach this problem, you are not allowed to engage in any unethical or illegal behavior. Please read the discussion of “<a href="https://www.google.com/search?q=white+hat" target="_blank" rel="noopener">white hat</a>“ versus “<a href="https://www.google.com/search?q=black+hat" target="_blank" rel="noopener">black hat</a>“ SEO over at <a href="https://www.wikipedia.org/" target="_blank" rel="noopener">Wikipedia</a>.</p><p>Rules of the game:<br><img src="game.jpg" alt=""></p><p><a href="https://linlaw0229.github.io/about/">Lawrence Lin</a><br>UIN: 926009408</p><p>Somewhere in the page (possibly in the non-viewable source html) you must include your name or some other way for us to identify you.<br>Your target page may only be a <a href="https://www.tamu.edu/" target="_blank" rel="noopener">TAMU</a> student page, a page on your own webserver, a page on a standard blog platform (e.g., wordpress), or some other primarily user-controlled page<br>Your target page CAN NOT be a <a href="https://twitter.com/" target="_blank" rel="noopener">twitter</a> account, a <a href="https://www.facebook.com/" target="_blank" rel="noopener">facebook</a> page, a <a href="https://www.yahoo.com/" target="_blank" rel="noopener">Yahoo</a> Answers or similar page<br>No <a href="https://www.wikipedia.org/" target="_blank" rel="noopener">Wikipedia</a> vandalism<br>No <a href="https://www.yahoo.com/" target="_blank" rel="noopener">Yahoo</a>/<a href="https://www.wikipedia.org/" target="_blank" rel="noopener">Wikipedia</a> answers questions<br>No comment spamming of <a href="https://linlaw0229.github.io/">blogs</a><br>If you have concerns/questions/clarifications, please post on <a href="https://piazza.com" target="_blank" rel="noopener">Piazza</a> and we will discuss<br>For your homework turnin for this part, you should provide us the URL of your target page and a brief discussion (2-4 paragraphs) of the strategies you are using. We will issue the query and check the rankings at some undetermined time in the next couple of weeks. You might guess that major search engines take some time to discover and integrate new pages: if I were you, I’d get a target page up immediately.</p><p>Grading:</p><p>5 points for providing a valid URL<br>5 points for a well-reasoned discussion of your strategy<br><strong> Bonus: </strong></p><p>1 point for your page appearing in the top-20 on <a href="www.google.com">Google</a> or <a href="https://www.bing.com/" target="_blank" rel="noopener">Bing</a><br>1 more point for your page appearing in the top-10 on <a href="www.google.com">Google</a> or <a href="https://www.bing.com/" target="_blank" rel="noopener">Bing</a><br>1 more point for your page appearing in the top-5 on <a href="www.google.com">Google</a> or <a href="https://www.bing.com/" target="_blank" rel="noopener">Bing</a><br>2 more points for your page being ranked first by <a href="www.google.com">Google</a> or <a href="https://www.bing.com/" target="_blank" rel="noopener">Bing</a>. And, a vigorous announcement in class, and a high-five for having the top result!</p><h1 id="sajfd-hfafbjhd"><a href="#sajfd-hfafbjhd" class="headerlink" title="sajfd hfafbjhd"></a>sajfd hfafbjhd</h1><h2 id="sajfd-hfafbjhd-1"><a href="#sajfd-hfafbjhd-1" class="headerlink" title="sajfd hfafbjhd"></a>sajfd hfafbjhd</h2><p>###sajfd hfafbjhd</p><ul><li>sajfd hfafbjhd</li></ul><ul><li>sajfd hfafbjhd<br><img src="sajfd hfafbjhd.jpg" alt="sajfd hfafbjhd"><br><a href="sajfd hfafbjhd.jpg">sajfd hfafbjhd</a><br><a href="http://www.cplusplus.com/" target="_blank" rel="noopener">C++</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sajfd</span><span class="params">(<span class="keyword">int</span> hfafbjhd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"sajfd hfafbjhd\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">hfafbjhd</span><span class="params">(sajfd)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"sajfd hfafbjhd"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sajfd hfafbjhd\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//https://linlaw0229.github.io/2019/02/08/sajfd-hfafbjhd/</span></span><br></pre></td></tr></table></figure><p>What’s the URL of your page?</p><p><a href="https://linlaw0229.github.io/2019/02/08/sajfd-hfafbjhd/">https://linlaw0229.github.io/2019/02/08/sajfd-hfafbjhd/</a></p><p>What’s your strategy? (2-4 paragraphs)</p><ul><li><p>Increase the hub score<br>My strategy for this is to make the webpage links to many of the famous websites. For example, I created several direct links to <a href="www.google.com">Google</a>, <a href="https://www.bing.com/" target="_blank" rel="noopener">Bing</a>, <a href="https://www.wikipedia.org/" target="_blank" rel="noopener">Wikipedia</a>, etc. </p></li><li><p>Increase the authority score<br>For this part, I tried to named some of the images in my webpage, and link some other pages to this image.<br>In addition, I wrote some simple code with the key word, <a href="https://linlaw0229.github.io/2019/02/08/sajfd-hfafbjhd/">sajfd hfafbjhd</a>, in it. </p></li></ul>]]></content>
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Information Storage and Retrival </tag>
            
            <tag> Texas A&amp;M University </tag>
            
            <tag> TAMU </tag>
            
            <tag> CSCE </tag>
            
            <tag> CSCE 670 </tag>
            
            <tag> Spring 2019 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>904. Fruit Into Baskets</title>
      <link href="/2019/01/22/904-Fruit-Into-Baskets/"/>
      <url>/2019/01/22/904-Fruit-Into-Baskets/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>In a row of trees, the i-th tree produces fruit with type tree[i].</p><p>You start at any tree of your choice, then repeatedly perform the following steps:</p><p>Add one piece of fruit from this tree to your baskets.  If you cannot, stop.<br>Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.<br>Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.</p><p>You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.</p><p>What is the total amount of fruit you can collect with this procedure?</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p><p>Explanation: We can collect [1,2,1].</p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,2,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p><p>Explanation: We can collect [1,2,2].<br>If we started at the first tree, we would only collect [0, 1].</p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,2,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>Explanation: We can collect [2,3,2,2].<br>If we started at the first tree, we would only collect [1, 2].</p><p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p><p>Explanation: We can collect [1,2,1,1,2].<br>If we started at the first tree or the eighth tree, we would only collect 4 fruits.</p><p>Note:</p><p>1 &lt;= tree.length &lt;= 40000<br>0 &lt;= tree[i] &lt; tree.length</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>It’s a similar question to <a href="/2018/08/21/76-Minimum-Window-Substring/" title="76. Minimum Window Substring">76. Minimum Window Substring</a>. We can see it as <code>Find out the longest length of subarrays with at most 2 different numbers?</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//longest substring with max 2 different elements</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>, start= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end= <span class="number">0</span>; end&lt; tree.size(); end++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[tree[end]]++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">map</span>.size()&gt; <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">map</span>[tree[start]]--;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[tree[start]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">map</span>.erase(tree[start]);</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            res= max(res, end- start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n))$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>979. Distribute Coins in Binary Tree</title>
      <link href="/2019/01/20/979-Distribute-Coins-in-Binary-Tree/"/>
      <url>/2019/01/20/979-Distribute-Coins-in-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total.</p><p>In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.)</p><p>Return the number of moves required to make every node have exactly one coin.</p><p>Example 1:</p><p><img src="tree1.png" alt=""></p><p>Input: [3,0,0]<br>Output: 2<br>Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.</p><p>Example 2:</p><p><img src="tree2.png" alt=""></p><p>Input: [0,3,0]<br>Output: 3<br>Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.</p><p>Example 3:</p><p><img src="tree3.png" alt=""></p><p>Input: [1,0,2]<br>Output: 2<br>Example 4:</p><p><img src="tree4.png" alt=""></p><p>Input: [1,0,0,null,3]<br>Output: 4</p><p>Note:</p><p>1&lt;= N &lt;= 100<br>0 &lt;= node.val &lt;= N</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The dfs function returns the amount of coins each node need or have excessively. For each node, it will try to balance the amount of the coins used by its left child and right child.</p><p>And it will return a positive number if there is excessive coins which could be used by its parent node, or a negative number if current node or its children need coins.</p><p>Each coin (excessive or needed) need one step to be sent to the parent node.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCoins</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left= dfs(root-&gt;left), right= dfs(root-&gt;right);</span><br><span class="line">        res += <span class="built_in">abs</span>(left)+ <span class="built_in">abs</span>(right);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val+ left+ right<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(logn)$<br>reference:<br><a href="https://goo.gl/YkYRTs" target="_blank" rel="noopener">https://goo.gl/YkYRTs</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>978. Longest Turbulent Subarray</title>
      <link href="/2019/01/20/978-Longest-Turbulent-Subarray/"/>
      <url>/2019/01/20/978-Longest-Turbulent-Subarray/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A subarray A[i], A[i+1], …, A[j] of A is said to be turbulent if and only if:</p><p>For i &lt;= k &lt; j, A[k] &gt; A[k+1] when k is odd, and A[k] &lt; A[k+1] when k is even;<br>OR, for i &lt;= k &lt; j, A[k] &gt; A[k+1] when k is even, and A[k] &lt; A[k+1] when k is odd.<br>That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.</p><p>Return the length of a maximum size turbulent subarray of A.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,4,2,10,7,8,8,1,9]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: (A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5])</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,8,12,16]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [100]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>1 &lt;= A.length &lt;= 40000<br>0 &lt;= A[i] &lt;= 10^9</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Keep track of the <code>current run</code> length and the <code>best run length</code>. If the last three elements are turbulent, increase the current run length by 1. Otherwise, reset the run length.<br>We reset the run length to <code>1</code> if the previous and current elements are <code>the same</code> (Ex: [2,2,2,2,2]), or reset the run length to <code>2</code> if the previous and current elements are <code>different</code> (Ex: [2,4,6,8]). Return the length of the best run found.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>, cur= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; A.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span> &amp;&amp; (A[i<span class="number">-2</span>] &gt; A[i<span class="number">-1</span>] &amp;&amp; A[i] &gt; A[i<span class="number">-1</span>]) ||</span><br><span class="line">                          (A[i<span class="number">-2</span>] &lt; A[i<span class="number">-1</span>] &amp;&amp; A[i] &lt; A[i<span class="number">-1</span>]))&#123;</span><br><span class="line">                cur++;</span><br><span class="line">                <span class="comment">// If the last three elements are turbulent, increment run length by 1.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; A[i] != A[i<span class="number">-1</span>])</span><br><span class="line">                cur= <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// The last three elements are not turbulent, so we'll reset the run length.</span></span><br><span class="line">                <span class="comment">// If the previous and current elements are not equal, the new run length is 2.</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur= <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// Otherwise, the new run length is 1.</span></span><br><span class="line">            res= max(res, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/h3ZDKL" target="_blank" rel="noopener">https://goo.gl/h3ZDKL</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>977. Squares of a Sorted Array</title>
      <link href="/2019/01/20/977-Squares-of-a-Sorted-Array/"/>
      <url>/2019/01/20/977-Squares-of-a-Sorted-Array/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-4,-1,0,3,10]</span><br><span class="line">Output: [0,1,9,16,100]</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Input: [-7,-3,2,3,11]</span><br><span class="line">Output: [4,9,9,49,121]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">1 &lt;= A.length &lt;= 10000</span><br><span class="line">-10000 &lt;= A[i] &lt;= 10000</span><br><span class="line">A is sorted in non-decreasing order.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Solution:</span><br><span class="line"></span><br><span class="line">The following solution can solve it in one pass. The idea is to check from two side of the array. Since the array is already sorted, we can check the `absolute value` from two sides, and determine which value is greater.</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        //start from two side of the array</span><br><span class="line">        int i= 0, j= A.size()-1, k= A.size()-1;</span><br><span class="line">        vector&lt;int&gt; res(A.size());</span><br><span class="line">        </span><br><span class="line">        while(i&lt;= j)&#123;</span><br><span class="line">            </span><br><span class="line">            if(abs(A[i])&gt; abs(A[j]))&#123;</span><br><span class="line">                res[k]= A[i]*A[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                res[k]= A[j]*A[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> array </tag>
            
            <tag> sort </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>74. Search a 2D Matrix</title>
      <link href="/2019/01/19/74-Search-a-2D-Matrix/"/>
      <url>/2019/01/19/74-Search-a-2D-Matrix/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><p>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to think the matrix as an array.<br>array convert to n * m matrix =&gt; a[x] =&gt; matrix[x / m][x % m];</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m= matrix.size(), n= matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= m*n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= left+ (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp= matrix[mid/n][mid%n];</span><br><span class="line">            <span class="keyword">if</span>(target&gt; tmp)</span><br><span class="line">                left= mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt; tmp)</span><br><span class="line">                right= mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(log(mn))$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/FAmm72" target="_blank" rel="noopener">https://goo.gl/FAmm72</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
            <tag> twitter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note Information Retrieval</title>
      <link href="/2019/01/18/note-Information-Retrieval/"/>
      <url>/2019/01/18/note-Information-Retrieval/</url>
      <content type="html"><![CDATA[<p>Definition:<br>Information Retrieval: Information retrieval (IR) is finding material (usually documents) of an unstructured nature (usually text) that satisfies an information need from within large collections (usually stored on computers).</p><p>Chapter 1:<br>first manually classifying some documents and then hoping to be able to classify new documents automatically.<br>Three prominent scale:</p><ol><li>web search<br> gather documents for indexing, being able to build systems that work efficiently at this enormous scale, and handling particular aspects of the web,</li><li>personal information retrieval</li><li>enterprise, institutional, and domain-specific search</li></ol><p>Chapter 6: Scoring, term weighting and the vector space model<br>Term frequency and weighting:<br>a document or zone that mentions a <code>query term</code> more often has more to do with that query and therefore should receive a higher score.</p><p>Reference:<br><a href="https://nlp.stanford.edu/IR-book/" target="_blank" rel="noopener">https://nlp.stanford.edu/IR-book/</a></p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Information Retrieval </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>62. Unique Paths</title>
      <link href="/2019/01/18/62-Unique-Paths/"/>
      <url>/2019/01/18/62-Unique-Paths/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Naive solution. Use a 2D array, initialize it with 0th row and 0th column to 1(because only one way to reach).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">1</span>; r&lt; m; r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">1</span>; c&lt; n; c++)&#123;</span><br><span class="line">                dp[r][c]= dp[r<span class="number">-1</span>][c]+ dp[r][c<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(m<em>n)$<br>space complexity: $O(m</em>n)$</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h3><p>Optimized the space usage:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">1</span>; r&lt; m; r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; n; i++)&#123;</span><br><span class="line">                dp[i]+= dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(m*n)$<br>space complexity: $O(n)$</p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note-Recursion and DP</title>
      <link href="/2019/01/16/note-Recursion-and-DP/"/>
      <url>/2019/01/16/note-Recursion-and-DP/</url>
      <content type="html"><![CDATA[<ul><li><p>Bottom-Up approach:<br>more intuitive. The key is to think about how to build solution for one case off of the previous case</p></li><li><p>Top-Down approach:<br>how to divide the problem for case N into subproblems, be careful of overlap between cases.</p></li></ul><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>46. Permutations</title>
      <link href="/2019/01/02/46-Permutations/"/>
      <url>/2019/01/02/46-Permutations/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>43. Multiply Strings</title>
      <link href="/2019/01/02/43-Multiply-Strings/"/>
      <url>/2019/01/02/43-Multiply-Strings/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">Output: &quot;56088&quot;</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>The length of both num1 and num2 is &lt; 110.<br>Both num1 and num2 contain only digits 0-9.<br>Both num1 and num2 do not contain any leading zero, except the number 0 itself.<br>You must not use any built-in BigInteger library or convert the inputs to integer directly.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Things to note:</p><ol><li>The product of two numbers cannot exceed the sum of the two lengths. (e.g. 99 * 99 cannot be five digit)</li><li>The position of result:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int d1 = num1.charAt(i) - &apos;0&apos;;</span><br><span class="line">int d2 = num2.charAt(j) - &apos;0&apos;;</span><br><span class="line">products[i + j + 1] += d1 * d2;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. the length of result string is (num1.length+ num2.length)</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        string res(num1.length()+num2.length(), '0');</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= num1.size()<span class="number">-1</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> carry= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= num2.size()<span class="number">-1</span>; j&gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp= (res[i+j+<span class="number">1</span>]- <span class="string">'0'</span>)+ (num1[i]-<span class="string">'0'</span>)* (num2[j]-<span class="string">'0'</span>)+ carry;</span><br><span class="line">                res[i+j+<span class="number">1</span>] = tmp%<span class="number">10</span>+<span class="string">'0'</span>; <span class="comment">//because i and j both starts at size-1</span></span><br><span class="line">                carry= tmp/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i]+= carry;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">size_t</span> startpos = res.find_first_not_of(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>::npos != startpos) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.substr(startpos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>41. First Missing Positive</title>
      <link href="/2019/01/01/41-First-Missing-Positive/"/>
      <url>/2019/01/01/41-First-Missing-Positive/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an unsorted integer array, find the smallest missing positive integer.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>Your algorithm should run in O(n) time and uses constant extra space.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea of this question is we can traverse the whole array once, putting every element in a slot.<br>So, how do we know where we should put this element?</p><p>Let’s check and observe the example.</p><ol><li>Input: [1,2,0]</li></ol><ul><li>Zero and negative number does not count: The question is asking for missing positive number.</li><li>we can put the number <code>nums[i]</code> in slot <code>i-1</code></li></ul><ol start="2"><li>Input: [3,4,-1,1]<br>[-1,4,3,1]<br>[-1,1,3,4]<br>Output: 2</li></ol><ul><li>if we put the numbers into the slot that we observed earlier, we can get [-1,1,3,4]; however, if we stop here, <code>1</code> is not in the right place. Therefore, we need to keep swapping until the <code>i</code>th element contains correct number or a zero/negative number.</li></ul><ol start="3"><li>Input: [7,8,9,11,12]<br>Output: 1</li></ol><ul><li>every element in the array exceed the size of array</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Thoughts:</span></span><br><span class="line"><span class="comment">        Since we can only do it in O(n) time, ony way to put all elements in order is to traverse all element once</span></span><br><span class="line"><span class="comment">        We can put n in A[n-1] slot</span></span><br><span class="line"><span class="comment">        Then walk through the array, if the number in A[n-1] is not n, then return it</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//[1,2,0]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i]&gt; <span class="number">0</span> &amp;&amp; nums[i]&lt;= nums.size() &amp;&amp; nums[nums[i]<span class="number">-1</span>] != nums[i])</span><br><span class="line">                swap(nums[i], nums[nums[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/Rq1yXX" target="_blank" rel="noopener">https://goo.gl/Rq1yXX</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>35. Search Insert Position</title>
      <link href="/2018/12/30/35-Search-Insert-Position/"/>
      <url>/2018/12/30/35-Search-Insert-Position/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= left+ (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mid])</span><br><span class="line">                left= mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right= mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>python</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchInsert(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        p = 0</span><br><span class="line">        q= len(nums)-1</span><br><span class="line">        while p &lt;= q :</span><br><span class="line">            mid = (p+q) // 2</span><br><span class="line">            if nums[mid] == target:</span><br><span class="line">                return mid</span><br><span class="line">            elif(nums[mid] &lt; target):</span><br><span class="line">                p = mid + 1 </span><br><span class="line">            else:</span><br><span class="line">                q = mid - 1        </span><br><span class="line">        return p</span><br></pre></td></tr></table></figure><p>time complexity: $O(logn)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/yDCBXv" target="_blank" rel="noopener">https://goo.gl/yDCBXv</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>27. Remove Element</title>
      <link href="/2018/12/30/27-Remove-Element/"/>
      <url>/2018/12/30/27-Remove-Element/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br></pre></td></tr></table></figure></p><p>It doesn’t matter what values are set beyond the returned length.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums[cur++]= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>26. Remove Duplicates from Sorted Array</title>
      <link href="/2018/12/30/26-Remove-Duplicates-from-Sorted-Array/"/>
      <url>/2018/12/30/26-Remove-Duplicates-from-Sorted-Array/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br></pre></td></tr></table></figure></p><p>It doesn’t matter what values are set beyond the returned length.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>check the size of the array</li><li>Does the first two elements the same?<ol><li>Same: find another element to replace it</li><li>Not the same: proceed the <code>pre</code> pointer to keep the different elements</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt; <span class="number">2</span>) <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="keyword">int</span> pre= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>] != nums[i])</span><br><span class="line">                nums[pre++]= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>25. Reverse Nodes in k-Group</title>
      <link href="/2018/12/29/25-Reverse-Nodes-in-k-Group/"/>
      <url>/2018/12/29/25-Reverse-Nodes-in-k-Group/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>Example:</p><p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>For k = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>For k = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p>Note:</p><p>Only constant extra memory is allowed.<br>You may not alter the values in the list’s nodes, only nodes itself may be changed.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1st k-1 loop init:</span><br><span class="line">-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><span class="line"> |    |    |    </span><br><span class="line">pre  cur  nex  </span><br><span class="line"></span><br><span class="line">-1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 5</span><br><span class="line"> |         |    |   </span><br><span class="line">pre       cur  nex  </span><br><span class="line"></span><br><span class="line">-1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5</span><br><span class="line"> |              |    |    </span><br><span class="line">pre            cur  nex  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2nd loop init:</span><br><span class="line">-1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5</span><br><span class="line">                |    |    |    </span><br><span class="line">               pre  cur  nex</span><br></pre></td></tr></table></figure><p>Above is how it works inside one group iteration(for example, k=3)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy= <span class="keyword">new</span> ListNode(<span class="number">-1</span>); dummy-&gt;next= head;</span><br><span class="line">        ListNode *cur= dummy, *nex, *pre= dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. get the length of linked list</span></span><br><span class="line">        <span class="keyword">int</span> count= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur= cur-&gt;next)</span><br><span class="line">            count++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. use the length to do swapping</span></span><br><span class="line">        <span class="keyword">while</span>(count &gt;= k)&#123;</span><br><span class="line">            cur= pre-&gt;next;</span><br><span class="line">            nex= cur-&gt;next;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; k; i++)&#123; <span class="comment">//IMPORTANT: change in k groups, only needs to swap k-1 times</span></span><br><span class="line">                cur-&gt;next= nex-&gt;next;</span><br><span class="line">                nex-&gt;next= pre-&gt;next;</span><br><span class="line">                pre-&gt;next= nex;</span><br><span class="line">                nex= cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre= cur;</span><br><span class="line">            count -= k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/uyufCT" target="_blank" rel="noopener">https://goo.gl/uyufCT</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note-Priority_Queue</title>
      <link href="/2018/12/29/note-Priority-Queue/"/>
      <url>/2018/12/29/note-Priority-Queue/</url>
      <content type="html"><![CDATA[<p>Initialize of customize priority queue:</p><ol><li>define a struct of compare function.</li><li>note the init method of pq.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compare</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode *a, ListNode *b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val&gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, compare&gt; pq;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="http://www.cplusplus.com/reference/queue/priority_queue/priority_queue/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/queue/priority_queue/priority_queue/</a></p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
            <tag> priority queue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>22. Generate Parentheses</title>
      <link href="/2018/12/27/22-Generate-Parentheses/"/>
      <url>/2018/12/27/22-Generate-Parentheses/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea of this question is to use backtracking and dfs. Design a dfs helper function with <code>left</code> and <code>right</code> input. Everytime when we add a left parentheses <code>(</code>, we subtract <code>left</code> by 1, and increase <code>right</code> by 1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.permutation(res, <span class="string">""</span>, n, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, res, tmp, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l == r == <span class="number">0</span>:</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; <span class="number">0</span>:</span><br><span class="line">            self.permutation(res, tmp+ <span class="string">'('</span>, l<span class="number">-1</span>, r+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> r &gt; <span class="number">0</span>:</span><br><span class="line">            self.permutation(res, tmp+ <span class="string">')'</span>, l, r<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">string</span> tmp= <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(res, tmp, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span> tmp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span> &amp;&amp; right== <span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right&gt; <span class="number">0</span>)</span><br><span class="line">            helper(res, tmp+<span class="string">")"</span>, left, right<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(left&gt; <span class="number">0</span>)</span><br><span class="line">            helper(res, tmp+<span class="string">"("</span>, left<span class="number">-1</span>, right+<span class="number">1</span>);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(2^n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> backtracking </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>962. Maximum Width Ramp</title>
      <link href="/2018/12/23/962-Maximum-Width-Ramp/"/>
      <url>/2018/12/23/962-Maximum-Width-Ramp/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array A of integers, a ramp is a tuple (i, j) for which i &lt; j and A[i] &lt;= A[j].  The width of such a ramp is j - i.</p><p>Find the maximum width of a ramp in A.  If one doesn’t exist, return 0.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [6,0,8,2,1,5]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>Explanation:<br>The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.<br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,8,1,0,1,9,4,0,4,1]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure></p><p>Explanation:<br>The maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1.</p><p>Note:</p><p>2 &lt;= A.length &lt;= 50000<br>0 &lt;= A[i] &lt;= 50000</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ul><li>Brute force<br>use two pointers to solve. One start from left, the other one start from right side of array. <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//brute force</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res= INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left= <span class="number">0</span>; left&lt; A.size()<span class="number">-1</span>; left++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> right= A.size()<span class="number">-1</span>; right&gt; left; right--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[right]&gt;= A[left])&#123;</span><br><span class="line">                    res= max(res, right-left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MIN? <span class="number">0</span>: res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: $O(n^2)$<br>space complexity: $O(1)$</p><ul><li>Decreasing Stack<br>Use a stack to keep small elements index start from the left.<br>ex:<br>[6,0,1,2], then the stack will have [0,1] (this is the index).<br>A[0] is because the stack was empty.<br>A[1] is smaller than A[0], so push into stack.<br>Rest of the elements all greater than A[1], so no need to keep in stack.</li></ul><p>The second step is to find the maximum ramp, which start traverse from the right side of the array. One thing to notice is that, we don’t need to keep finding if the remain distance is smaller than the maximum ramp we already have.<br>ex:<br>[6,0,8,2,1,5]</p><ol><li>[0,1] is the stack</li><li>start from right side of the array. which is A[5]= 5<br>5-1= 4, which is the current maximum ramp we have. Then pop out the element from the stack to see if we can find a maximum ramp if use current right as a pivot.</li><li>This guarantee us to find a left index with smaller value.</li><li>We don’t need to keep finding if we’ve already reach the longest distance we can have.<br>in this case, <code>res= 4, i= 4</code> so we don’t need to move the <code>right</code> pointer toward left anymore.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//use a stack to keep a decreasing numbers</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; A.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stk.empty() || A[stk.top()] &gt; A[i])&#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= A.size()<span class="number">-1</span>; i&gt; res; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; A[stk.top()]&lt;= A[i])&#123;</span><br><span class="line">                <span class="comment">//printf("stk.top=%d, i= %d\n", stk.top(), i);</span></span><br><span class="line">                res= max(res, i- stk.top());</span><br><span class="line">                </span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf("i=%d ,res=%d\n", i, res);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/97BXKc" target="_blank" rel="noopener">https://goo.gl/97BXKc</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/2018/12/23/19-Remove-Nth-Node-From-End-of-List/"/>
      <url>/2018/12/23/19-Remove-Nth-Node-From-End-of-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a linked list, remove the n-th node from the end of list and return its head.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br></pre></td></tr></table></figure></p><p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:</p><p>Given n will always be valid.</p><p>Follow up:</p><p>Could you do this in one pass?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Since we’re going to do it in one pass, we need to find a way to create a gap of <code>n+1</code>. The reason is because, we will traverse to the end of the linked list, and we can use another pointer <code>n+1</code> steps slower to find the node before <code>n</code>th node from end of list.</p><p>For example:<br><img src="IMG_6246.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy= <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next= head;</span><br><span class="line">        ListNode* slow= dummy, *fast= dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            fast= fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;fast-&gt;val;</span></span><br><span class="line">        <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">            slow= slow-&gt;next;</span><br><span class="line">            fast= fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf("\nslow:%d\n", slow-&gt;val);</span></span><br><span class="line">        slow-&gt;next= slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>929. Unique Email Addresses</title>
      <link href="/2018/12/21/929-Unique-Email-Addresses/"/>
      <url>/2018/12/21/929-Unique-Email-Addresses/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Every email consists of a local name and a domain name, separated by the @ sign.</p><p>For example, in <a href="mailto:alice@leetcode.com" target="_blank" rel="noopener">alice@leetcode.com</a>, alice is the local name, and leetcode.com is the domain name.</p><p>Besides lowercase letters, these emails may contain ‘.’s or ‘+’s.</p><p>If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, “<a href="mailto:alice.z@leetcode.com" target="_blank" rel="noopener">alice.z@leetcode.com</a>“ and “<a href="mailto:alicez@leetcode.com" target="_blank" rel="noopener">alicez@leetcode.com</a>“ forward to the same email address.  (Note that this rule does not apply for domain names.)</p><p>If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example <a href="mailto:m.y+name@email.com" target="_blank" rel="noopener">m.y+name@email.com</a> will be forwarded to <a href="mailto:my@email.com" target="_blank" rel="noopener">my@email.com</a>.  (Again, this rule does not apply for domain names.)</p><p>It is possible to use both of these rules at the same time.</p><p>Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails? </p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>1 &lt;= emails[i].length &lt;= 100<br>1 &lt;= emails.length &lt;= 100<br>Each emails[i] contains exactly one ‘@’ character.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> email: emails)&#123;</span><br><span class="line">            <span class="keyword">int</span> idx = email.find_first_of(<span class="string">'@'</span>);</span><br><span class="line">            <span class="built_in">string</span> local= email.substr(<span class="number">0</span>, idx);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">string</span> domain= email.substr(idx);</span><br><span class="line">            <span class="comment">//printf("%s\n%s\n\n", local.c_str(), domain.c_str());</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//string.erase(begin, end)</span></span><br><span class="line">            <span class="comment">//remove_if() return a pointer</span></span><br><span class="line">            local.erase(remove_if(local.begin(), local.end(), [](<span class="keyword">auto</span> &amp;c)&#123; <span class="keyword">return</span> c == <span class="string">'.'</span>;&#125; ), local.end() );</span><br><span class="line">            <span class="comment">//printf("%s\n\n", local.c_str());</span></span><br><span class="line">            result.insert(local.substr(<span class="number">0</span>, local.find_first_of(<span class="string">'+'</span>))+ domain );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.size();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$</p><p>reference:<br><a href="http://www.cplusplus.com/reference/algorithm/remove_if/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/algorithm/remove_if/</a><br><a href="http://www.cplusplus.com/reference/string/string/erase/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/string/string/erase/</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> string </tag>
            
            <tag> google </tag>
            
            <tag> adobe </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>958. Check Completeness of a Binary Tree</title>
      <link href="/2018/12/16/958-Check-Completeness-of-a-Binary-Tree/"/>
      <url>/2018/12/16/958-Check-Completeness-of-a-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, determine if it is a complete binary tree.</p><p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p><p>Example 1:</p><p><img src="1.png" alt=""></p><p>Input: <code>[1,2,3,4,5,6]</code><br>Output: true<br>Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.</p><p>Example 2:</p><p><img src="2.png" alt=""></p><p>Input: <code>[1,2,3,4,5,null,7]</code><br>Output: false<br>Explanation: The node with value 7 isn’t as far left as possible.</p><p>Note:</p><p>The tree will have between 1 and 100 nodes.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>When level-order traversal in a complete tree, after the last node, all nodes in the queue should be null.<br>Otherwise, the tree is not complete.</p><p>I use the preorder traversal to trace the tree. It is because we need to walk the level from left to right.<br>example:<br>we can see that the X is the last node in this level. After X, we’ll go to next level, which should all be NULL.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 4 X</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//idea is to check if there're other node is also empty after we already find an empty node</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">bool</span> end= <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur= q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!cur)</span><br><span class="line">                end= <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q.push(cur-&gt;left);</span><br><span class="line">                q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>322. Coin Change</title>
      <link href="/2018/12/04/322-Coin-Change/"/>
      <url>/2018/12/04/322-Coin-Change/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [1, 2, 5], amount = 11</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [2], amount = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Key idea is to come up with the dp array. The array contains the min number of coins to compose n amount of money.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(amount+<span class="number">1</span>, amount+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= amount; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; coins.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coins[j] &lt;= i)</span><br><span class="line">                    dp[i]= min(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span>: dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>675. Cut Off Trees for Golf Event</title>
      <link href="/2018/12/04/675-Cut-Off-Trees-for-Golf-Event/"/>
      <url>/2018/12/04/675-Cut-Off-Trees-for-Golf-Event/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:</p><p>0 represents the obstacle can’t be reached.<br>1 represents the ground can be walked through.<br>The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height.<br>You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).</p><p>You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.</p><p>You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line"> [1,2,3],</span><br><span class="line"> [0,0,4],</span><br><span class="line"> [7,6,5]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line"> [1,2,3],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [7,6,5]</span><br><span class="line">]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line"> [2,3,4],</span><br><span class="line"> [0,0,5],</span><br><span class="line"> [8,7,6]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.</span><br></pre></td></tr></table></figure></p><p>Hint: size of the given matrix will not exceed 50x50.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; forest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = forest.size(), n = forest[<span class="number">0</span>].size(), res = <span class="number">0</span>, row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; trees;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (forest[i][j] &gt; <span class="number">1</span>) trees.push_back(&#123;forest[i][j], i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(trees.begin(), trees.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trees.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = helper(forest, row, col, trees[i][<span class="number">1</span>], trees[i][<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            res += cnt;</span><br><span class="line">            row = trees[i][<span class="number">1</span>];</span><br><span class="line">            col = trees[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; forest, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> treeRow, <span class="keyword">int</span> treeCol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == treeRow &amp;&amp; col == treeCol) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = forest.size(), n = forest[<span class="number">0</span>].size(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q&#123;&#123;&#123;row, col&#125;&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = t.first + dir[<span class="number">0</span>], y = t.second + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || visited[x][y] || forest[x][y] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (x == treeRow &amp;&amp; y == treeCol) <span class="keyword">return</span> cnt;</span><br><span class="line">                    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C++ object-oriented</title>
      <link href="/2018/11/28/C-object-oriented/"/>
      <url>/2018/11/28/C-object-oriented/</url>
      <content type="html"><![CDATA[<ul><li><p>Object<br>This is the basic unit of object-oriented programming. That is both data and function that operate on data are bundled as a unit called as object.</p></li><li><p>Class<br>When you define a class, you define a blueprint for an object. This doesn’t actually define any data, but it does define what the class name means, that is, define what an object of the class will consist of and what operations can be performed on such an object.</p></li><li><p>Abstraction<br>Data abstraction refers to, providing only essential information to the outside world and hiding their background details, i.e., to represent the needed information in program without presenting the details.<br>For example, a database system hides certain details of how data is stored and created and maintained. Similar way, C++ classes provides different methods to the outside world without giving internal details about those methods and data.</p></li><li><p>Encapsulation<br>Encapsulation is placing the data and the functions that work on that data in the same place. While working with procedural languages, it is not always clear which functions work on which variables but object-oriented programming provides you framework to place the data and the relevant functions together in the same object.</p></li><li><p>Inheritance<br>One of the most useful aspects of object-oriented programming is code reusability. As the name suggests Inheritance is the process of forming a new class from an existing class that is from the existing class called as base class, new class is formed called as derived class.<br>Code reusability -&gt; Reduce the code size.</p></li><li><p>Polymorphism<br>Poly refers to many. The ability to use an operator or function in different ways. In other words, giving different meaning to the operators or functions is called polymorphism. That is a single function or an operator functioning in many ways different upon the usage is called polymorphism.</p></li><li><p>Overloading<br>The concept of overloading is also a branch of polymorphism. When the exiting operator or function is made to operate on new data type, it is said to be overloaded.</p></li></ul><p><a href="https://docs.microsoft.com/en-us/windows/desktop/fileio/i-o-completion-ports" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/fileio/i-o-completion-ports</a></p>]]></content>
      
      <categories>
          
          <category> study </category>
          
          <category> programming language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>14. Longest Common Prefix</title>
      <link href="/2018/11/20/14-Longest-Common-Prefix/"/>
      <url>/2018/11/20/14-Longest-Common-Prefix/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure></p><p>Explanation: There is no common prefix among the input strings.<br>Note:</p><p>All given inputs are in lowercase letters a-z.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line"><span class="comment">#         str=["flower","flow","flight"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         after zip(*strs)</span></span><br><span class="line"><span class="comment">#         [('f', 'f', 'f'), ('l', 'l', 'l'), ('o', 'o', 'i'), ('w', 'w', 'g')]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         taken first set</span></span><br><span class="line"><span class="comment">#         len(set( "f","f","f"))=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         and taken 3</span></span><br><span class="line"><span class="comment">#         len(set("o","o","i"))=2</span></span><br><span class="line"></span><br><span class="line">        prefix = []</span><br><span class="line">        num = len(strs)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> zip(*strs):</span><br><span class="line">            <span class="keyword">if</span> len(set(x)) == <span class="number">1</span>:</span><br><span class="line">                prefix.append(x[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(prefix)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//compare the firs two strings to find it's common, then use it to find others common</span></span><br><span class="line">        <span class="keyword">if</span>(strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> common= strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; strs.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(common == <span class="string">""</span>) <span class="keyword">return</span> common;</span><br><span class="line">            <span class="keyword">int</span> size= min(common.length(), strs[i].length());</span><br><span class="line">            <span class="keyword">int</span> c= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>( c&lt; size)&#123;</span><br><span class="line">                <span class="keyword">if</span>(common[c] != strs[i][c])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            common= common.substr(<span class="number">0</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> common;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> citrix </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/2018/11/19/11-Container-With-Most-Water/"/>
      <url>/2018/11/19/11-Container-With-Most-Water/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and n is at least 2.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l= <span class="number">0</span>, r= height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_area= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp= min(height[l], height[r])* (r-l);</span><br><span class="line">            max_area= max(max_area, tmp);</span><br><span class="line">            height[l]&lt; height[r]? l++: r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>7. Reverse Integer</title>
      <link href="/2018/11/17/7-Reverse-Integer/"/>
      <url>/2018/11/17/7-Reverse-Integer/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure></p><p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [$−2^31$, $2^31 − 1$]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>need to check if the reversed number is overflow.<br>use a <code>long long</code> variable to store the reversed number.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign= x&gt; <span class="number">0</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">        x= <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            tmp= tmp*<span class="number">10</span> +x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (tmp*sign&lt; INT_MIN || tmp*sign&gt; INT_MAX)? <span class="number">0</span>: tmp*sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/zKDGQk" target="_blank" rel="noopener">https://goo.gl/zKDGQk</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> adobe </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>6. ZigZag Conversion</title>
      <link href="/2018/11/17/6-ZigZag-Conversion/"/>
      <url>/2018/11/17/6-ZigZag-Conversion/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p><p>And then read line by line: “PAHNAPLSIIGYIR”</p><p>Write the code that will take a string and make this conversion given a number of rows:</p><p>string convert(string s, int numRows);<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Create a vector<string> to store the characters in each row.<br>Traverse the string sequentially, the end condition is as follows.<br>vertically down: 0&lt;= idx&lt; numRows<br>obliquely up: 1&lt;= idx &lt;= numRows-2<br><img src="6.png" alt=""></string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(numRows);</span><br><span class="line">        <span class="keyword">int</span> curRow= <span class="number">0</span>, i= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idx= <span class="number">0</span>; i&lt; s.length() &amp;&amp; idx&lt; numRows; idx++)</span><br><span class="line">                res[idx].push_back(s[i++]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idx= numRows<span class="number">-2</span>; i&lt; s.length() &amp;&amp; idx&gt;= <span class="number">1</span>; idx--)</span><br><span class="line">                res[idx].push_back(s[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> _res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: res)&#123;</span><br><span class="line">            _res.append(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/Jegxjj" target="_blank" rel="noopener">https://goo.gl/Jegxjj</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> paypal </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>212. Word Search II</title>
      <link href="/2018/11/09/212-Word-Search-II/"/>
      <url>/2018/11/09/212-Word-Search-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p><p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =</span><br><span class="line">[</span><br><span class="line">  [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;],</span><br><span class="line">  [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;],</span><br><span class="line">  [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;],</span><br><span class="line">  [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure></p><p>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>For this question, we can start from thinking how to search multiple words in a 2D matrix.<br>Normally when we want to search multiple words, we’ll use <code>unordered_map</code>. But the given 2D matrix are lots of characters, so when we start searching one word, we need to know if the 2D matrix exist the next character of this word.</p><p>How do we instantly know the current character is invalid? <code>HashMap</code>?<br>How do we instantly know what’s the next valid character? <code>LinkedList</code>?<br>But the next character can be chosen from a list of characters. <code>Mutil-LinkedList</code>?<br>Combing them, <code>Trie</code> is the natural choice</p><p><img src="212. Word Search II.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hastable and linked list to search word</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.dic = defaultdict(TrieNode)</span><br><span class="line">        self.isWord = <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            p = p.dic[c]</span><br><span class="line">        p.isWord = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span><span class="params">(self, board: List[List[str]], words: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        res = []</span><br><span class="line">        trie = Trie()</span><br><span class="line">        node = trie.root</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            trie.insert(word)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                self.dfs(res, board, r, c, node, <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, res, board, r, c, node, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.isWord:</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            node.isWord = <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> r &gt;= len(board) <span class="keyword">or</span> c &gt;= len(board[<span class="number">0</span>]) <span class="keyword">or</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> c &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        ch = board[r][c]</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> node.dic:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        node = node.dic[ch]</span><br><span class="line">        board[r][c] = <span class="string">'#'</span></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)]:</span><br><span class="line">            self.dfs(res, board, r+x, c+y, node, tmp+ch)</span><br><span class="line">        board[r][c] = ch</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode*&gt; next;</span><br><span class="line">    TrieNode(): word(<span class="string">""</span>), next(<span class="built_in">vector</span>&lt;TrieNode*&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>))&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TrieNode* <span class="title">buildTrie</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span></span>&#123;</span><br><span class="line">        TrieNode* root= <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word: words)&#123;</span><br><span class="line">            TrieNode* tmp= root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c: word)&#123;</span><br><span class="line">                <span class="keyword">int</span> i= c- <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;next[i] == <span class="literal">NULL</span>)</span><br><span class="line">                    tmp-&gt;next[i]= <span class="keyword">new</span> TrieNode();</span><br><span class="line">                tmp= tmp-&gt;next[i];</span><br><span class="line">            &#125;</span><br><span class="line">            tmp-&gt;word= word;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, TrieNode* cur, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.size() || j &gt;= board[<span class="number">0</span>].size() || i&lt; <span class="number">0</span> || j&lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span> c= board[i][j];</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'#'</span> || cur-&gt;next[c-<span class="string">'a'</span>] == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        cur= cur-&gt;next[c-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;word != <span class="string">""</span>)&#123;</span><br><span class="line">            res.push_back(cur-&gt;word);</span><br><span class="line">            cur-&gt;word= <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        board[i][j]= <span class="string">'#'</span>;</span><br><span class="line">        dfs(board, cur, i+<span class="number">1</span>, j, res);</span><br><span class="line">        dfs(board, cur, i<span class="number">-1</span>, j, res);</span><br><span class="line">        dfs(board, cur, i, j+<span class="number">1</span>, res);</span><br><span class="line">        dfs(board, cur, i, j<span class="number">-1</span>, res);</span><br><span class="line">        board[i][j]= c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findWords(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        TrieNode* root= buildTrie(words);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                dfs(board, root, i, j, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> trie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note-OS</title>
      <link href="/2018/11/05/note-OS/"/>
      <url>/2018/11/05/note-OS/</url>
      <content type="html"><![CDATA[<h3 id="4-5-Atomic-Transaction"><a href="#4-5-Atomic-Transaction" class="headerlink" title="4-5 Atomic Transaction"></a>4-5 Atomic Transaction</h3><ul><li><p>Why not keep using lock?</p><ol><li>reduce concurrency</li><li>lead to deadlock</li><li>lead to priority inversion. low priority blocks high priority thread, caused high priority thread starved. example: Mars Pathfinder</li><li>lead to convoying. a performance problem caused by the overhead of repeated context switches from each time a thread attempts to acquire the lock and fails.</li><li>lack of soft&amp;hard composability: it is hard to combine small, correct lock-based modules into equally correct larger programs without modifying the modules or at least knowing about their internals.</li></ol></li><li><p>Transaction: groups of operations executed by a thread.</p></li><li>Serializability: <ul><li>idea: go without</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>811. Subdomain Visit Count</title>
      <link href="/2018/11/02/811-Subdomain-Visit-Count/"/>
      <url>/2018/11/02/811-Subdomain-Visit-Count/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A website domain like “discuss.leetcode.com” consists of various subdomains. At the top level, we have “com”, at the next level, we have “leetcode.com”, and at the lowest level, “discuss.leetcode.com”. When we visit a domain like “discuss.leetcode.com”, we will also visit the parent domains “leetcode.com” and “com” implicitly.</p><p>Now, call a “count-paired domain” to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be “9001 discuss.leetcode.com”.</p><p>We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;]</span><br><span class="line">Output: </span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]</span><br><span class="line">Explanation: </span><br><span class="line">We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]</span><br><span class="line">Output: </span><br><span class="line">[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]</span><br><span class="line">Explanation: </span><br><span class="line">We will visit &quot;google.mail.com&quot; 900 times, &quot;yahoo.com&quot; 50 times, &quot;intel.mail.com&quot; once and &quot;wiki.org&quot; 5 times. For the subdomains, we will visit &quot;mail.com&quot; 900 + 1 = 901 times, &quot;com&quot; 900 + 50 + 1 = 951 times, and &quot;org&quot; 5 times.</span><br></pre></td></tr></table></figure></p><p>Notes:</p><p>The length of cpdomains will not exceed 100.<br>The length of each domain name will not exceed 100.<br>Each address will have either 1 or 2 “.” characters.<br>The input count in any count-paired domain will not exceed 10000.<br>The answer output can be returned in any order.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; subdomainVisits(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cpdomains) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> domain: cpdomains)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos= domain.find(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> count= stoi(domain.substr(<span class="number">0</span>, pos));</span><br><span class="line">            <span class="built_in">map</span>[domain.substr(pos+<span class="number">1</span>)]+= count;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= pos+<span class="number">1</span>; i&lt; domain.length(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(domain[i] == <span class="string">'.'</span>) <span class="built_in">map</span>[domain.substr(i+<span class="number">1</span>)]+= count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: <span class="built_in">map</span>)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp= to_string(it.second)+ <span class="string">" "</span>+it.first;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/wgn31v" target="_blank" rel="noopener">https://goo.gl/wgn31v</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> hash table </tag>
            
            <tag> citrix </tag>
            
            <tag> indeed </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>380. Insert Delete GetRandom O(1)</title>
      <link href="/2018/11/01/380-Insert-Delete-GetRandom-O-1/"/>
      <url>/2018/11/01/380-Insert-Delete-GetRandom-O-1/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a data structure that supports all following operations in average O(1) time.</p><p>insert(val): Inserts an item val to the set if not already present.<br>remove(val): Removes an item val from the set if present.<br>getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">// Returns false as 2 does not exist in the set.</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">// Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// getRandom should return either 1 or 2 randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">// 2 was already in the set, so return false.</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// Since 2 is the only number in the set, getRandom always return 2.</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>In this question, we need to randomly pick a element from the inserted numbers. To do so, we need to know two things:</p><ol><li>The numbers we currently have</li><li>Where are they(index)</li></ol><p>We use a dictionary to store the <code>value-index</code> mapping, an array to store all the numbers. </p><p>Also, the question mentioned want to make each operation <code>O(1)</code>. We have two choice to delete the element in array:</p><ol><li><code>array.remove(val)</code>: takes <code>O(n)</code> time</li><li>move the element to last index then <code>array.pop()</code>: <code>O(1)</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.dic, self.nums = &#123;&#125;, []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dic:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.nums.append(val)</span><br><span class="line">            self.dic[val] = len(self.nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dic:</span><br><span class="line">            <span class="comment"># move the last index value to where val is</span></span><br><span class="line">            <span class="comment"># then pop the last element in array to achieve O(1) remove </span></span><br><span class="line">            idx = self.dic[val]</span><br><span class="line">            last = self.nums[<span class="number">-1</span>]</span><br><span class="line">            last_idx = self.dic[last]</span><br><span class="line">            self.nums[idx] = last</span><br><span class="line">            self.dic[last] = idx</span><br><span class="line">            self.nums.pop()</span><br><span class="line">            <span class="keyword">del</span> self.dic[val]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> random.choice(self.nums)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//store input numbers in vector</span></span><br><span class="line">    <span class="comment">//save index and </span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    RandomizedSet() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(val) != m.end()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        nums.push_back(val);</span><br><span class="line">        m[val] = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.find(val) == m.end()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> last = nums.back();</span><br><span class="line">        m[last] = m[val];</span><br><span class="line">        nums[m[val]] = last;</span><br><span class="line">        nums.pop_back();</span><br><span class="line">        m.erase(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx= rand()%nums.size();</span><br><span class="line">        <span class="keyword">return</span> nums[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(1)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> design </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>771. Jewels and Stones</title>
      <link href="/2018/10/31/771-Jewels-and-Stones/"/>
      <url>/2018/10/31/771-Jewels-and-Stones/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.</p><p>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.</p><p>Example 1:</p><p>Input: J = “aA”, S = “aAAbbbb”<br>Output: 3<br>Example 2:</p><p>Input: J = “z”, S = “ZZ”<br>Output: 0<br>Note:</p><p>S and J will consist of letters and have length at most 50.<br>The characters in J are distinct.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; jewels(J.begin(), J.end());</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: S)&#123;</span><br><span class="line">            <span class="keyword">if</span>(jewels.find(c) != jewels.end())</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>692. Top K Frequent Words</title>
      <link href="/2018/10/29/692-Top-K-Frequent-Words/"/>
      <url>/2018/10/29/692-Top-K-Frequent-Words/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-empty list of words, return the k most frequent elements.</p><p>Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2</span><br><span class="line">Output: [&quot;i&quot;, &quot;love&quot;]</span><br><span class="line">Explanation: &quot;i&quot; and &quot;love&quot; are the two most frequent words.</span><br><span class="line">    Note that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</span><br><span class="line">Output: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</span><br><span class="line">Explanation: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words,</span><br><span class="line">    with the number of occurrence being 4, 3, 2 and 1 respectively.</span><br></pre></td></tr></table></figure></p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.<br>Input words contain only lowercase letters.<br>Follow up:<br>Try to solve it in O(n log k) time and O(n) extra space.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We can use <code>map</code> and <code>bucket sort</code> to solve. The reason to choose <code>map</code> instead of <code>unordered_map</code> is because of the alphabetical order. </p><ol><li>Count the appearance of each word</li><li>Create buckets. Only need to create <code>words.size()</code> buckets.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// use map to count the appearance of word</span></span><br><span class="line">        <span class="comment">// then use bucket sort to get the top k frequent elements</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word: words)</span><br><span class="line">            <span class="built_in">map</span>[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; buckets(words.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: <span class="built_in">map</span>)</span><br><span class="line">            buckets[it.second].push_back(it.first);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= buckets.size()<span class="number">-1</span>; i&gt;= <span class="number">0</span> &amp;&amp; k&gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i].size() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//have element in the bucket, find out how many we need to get</span></span><br><span class="line">            <span class="comment">//because we need to follow alphabetical order</span></span><br><span class="line">            <span class="keyword">int</span> n= min(k, (<span class="keyword">int</span>)buckets[i].size());</span><br><span class="line">            res.insert(res.end(), buckets[i].begin(), buckets[i].begin()+n);</span><br><span class="line">            k-=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution-python-heap"><a href="#Solution-python-heap" class="headerlink" title="Solution python heap"></a>Solution python heap</h2><p>We could do without the count since by default the lower count will be popped first in a heapq implementation - the idea is to create a heap of length k containing the tuple <code>(count,word)</code>. When length exceeds <code>k</code>, the tuple with lower count is popped, thereby always having the top <code>k</code> count words.</p><p>However, if count is same in 2 tuples, the alphabetically lower word is popped out since that is the default ordering in a heapq (minheap) implementation, i.e for <code>(count, word1)</code> and <code>(count, word2)</code>, if <code>word1 &lt; word2</code>, <code>(count, word1)</code> is popped. We create a custom class to reverse this ordering such that if <code>word1 &lt; word2</code>, <code>(count, word2)</code> is popped. Our heap will then have the top <code>k</code> frequent words, with alphabetically lower words being treated as <code>&quot;greater&quot;</code> when the count is same in two tuples.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseWordOrder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        self.word = word</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># guaranteed no equality since we are comparing keys in counter</span></span><br><span class="line">        <span class="comment"># flipping the lesser than comparator for our purpose to keep greater word in heap</span></span><br><span class="line">        <span class="keyword">return</span> self.word &gt; other.word</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, words: List[str], k: int)</span> -&gt; List[str]:</span></span><br><span class="line">        counter = collections.Counter(words)    <span class="comment"># O(n) space and time</span></span><br><span class="line">        heap = []    <span class="comment"># max length will be k, so O(k) extra space</span></span><br><span class="line">        <span class="keyword">for</span> word,freq <span class="keyword">in</span> counter.items():    <span class="comment"># O(n) time to iterate counter</span></span><br><span class="line">            heapq.heappush(heap, (freq,ReverseWordOrder(word)))    <span class="comment"># O(logk) for each heappush operation</span></span><br><span class="line">            <span class="keyword">if</span> len(heap) &gt; k:    <span class="comment"># by not letting the heap exceed more than k length</span></span><br><span class="line">                heapq.heappop(heap)    <span class="comment"># O(logk) for each heappop operation</span></span><br><span class="line">        output = []    <span class="comment"># O(k) space, same length as heap</span></span><br><span class="line">        <span class="keyword">while</span> heap:    <span class="comment"># O(k) since len(heap) = k</span></span><br><span class="line">            _freq, reverseWordObj = heapq.heappop(heap)    <span class="comment"># O(logk)</span></span><br><span class="line">            output.append(reverseWordObj.word)</span><br><span class="line">        <span class="keyword">return</span> output[::<span class="number">-1</span>]    <span class="comment"># O(k)</span></span><br></pre></td></tr></table></figure><h2 id="Solution-python-Trie"><a href="#Solution-python-Trie" class="headerlink" title="Solution python Trie:"></a>Solution python Trie:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line">        self.freq = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">                node.children[char] = TrieNode()</span><br><span class="line">            node = node.children[char]</span><br><span class="line">        node.freq += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_words</span><span class="params">(node, s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node.freq &gt; <span class="number">0</span>:</span><br><span class="line">                lst.append((-node.freq, s))</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> node.children:</span><br><span class="line">                find_words(node.children[char], s + char)</span><br><span class="line">                </span><br><span class="line">        lst = []</span><br><span class="line">        find_words(self.root, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, words: List[str], k: int)</span> -&gt; List[str]:</span></span><br><span class="line">        trie = Trie()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            trie.insert(word)</span><br><span class="line">        heap = trie.counter()</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> heap <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            res.append(heapq.heappop(heap)[<span class="number">1</span>])</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/Eznk8c" target="_blank" rel="noopener">https://goo.gl/Eznk8c</a><br><a href="https://goo.gl/oMLd8T" target="_blank" rel="noopener">https://goo.gl/oMLd8T</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> hash table </tag>
            
            <tag> heap </tag>
            
            <tag> trie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>103. Binary Tree Zigzag Level Order Traversal</title>
      <link href="/2018/10/29/103-Binary-Tree-Zigzag-Level-Order-Traversal/"/>
      <url>/2018/10/29/103-Binary-Tree-Zigzag-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its zigzag level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution1-BFS-Deque"><a href="#Solution1-BFS-Deque" class="headerlink" title="Solution1 BFS+ Deque:"></a>Solution1 BFS+ Deque:</h3><p>Use a deque to store the elements. The idea is to change direction of <code>push</code> elements into the deque and <code>pop</code> elements from deque.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q, res, d = deque([]), [], <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># True: look from right to left</span></span><br><span class="line">        <span class="comment"># False: look from left to right</span></span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            pre_level_size = len(q)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(pre_level_size):</span><br><span class="line">                <span class="keyword">if</span> d: </span><br><span class="line">                    <span class="comment"># cur level pop from right, append next level from left</span></span><br><span class="line">                    <span class="comment"># pop from right so we would the rightest node as first one</span></span><br><span class="line">                    tmp = q.pop()</span><br><span class="line">                    <span class="keyword">if</span> tmp.left: q.appendleft(tmp.left)</span><br><span class="line">                    <span class="keyword">if</span> tmp.right: q.appendleft(tmp.right)</span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    <span class="comment"># cur level pop from left, append next level from right</span></span><br><span class="line">                    <span class="comment"># pop from left so we would the leftest node as first one</span></span><br><span class="line">                    tmp = q.popleft()</span><br><span class="line">                    <span class="keyword">if</span> tmp.right: q.append(tmp.right)</span><br><span class="line">                    <span class="keyword">if</span> tmp.left: q.append(tmp.left)</span><br><span class="line">                level.append(tmp.val)</span><br><span class="line">            d = <span class="keyword">not</span> d</span><br><span class="line">            res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; deq;</span><br><span class="line">        <span class="keyword">bool</span> dir= <span class="literal">false</span>;</span><br><span class="line">        deq.push_front(root);</span><br><span class="line">        <span class="keyword">while</span>(!deq.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size= deq.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curlevel;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; size; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dir)&#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp= deq.front(); deq.pop_front();</span><br><span class="line">                    curlevel.push_back(tmp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;right) deq.push_back(tmp-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;left) deq.push_back(tmp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp= deq.back(); deq.pop_back();</span><br><span class="line">                    curlevel.push_back(tmp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;left) deq.push_front(tmp-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(tmp-&gt;right) deq.push_front(tmp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = dir^<span class="number">1</span>;</span><br><span class="line">            res.push_back(curlevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p><h3 id="Solution2-BFS-two-stacks"><a href="#Solution2-BFS-two-stacks" class="headerlink" title="Solution2 BFS+ two stacks:"></a>Solution2 BFS+ two stacks:</h3><p>Use two stacks, one for odd layer, the other one for even layer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; odd, even;</span><br><span class="line">        odd.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!odd.empty() || !even.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level_odd;</span><br><span class="line">            <span class="keyword">while</span>(!odd.empty())&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp= odd.top(); odd.pop();</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left) even.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right) even.push(tmp-&gt;right);</span><br><span class="line">                level_odd.push_back(tmp-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!level_odd.empty()) res.push_back(level_odd);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level_even;</span><br><span class="line">            <span class="keyword">while</span>(!even.empty())&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp= even.top(); even.pop();</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right) odd.push(tmp-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left) odd.push(tmp-&gt;left);</span><br><span class="line">                level_even.push_back(tmp-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!level_even.empty()) res.push_back(level_even);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>930. Binary Subarrays With Sum</title>
      <link href="/2018/10/28/930-Binary-Subarrays-With-Sum/"/>
      <url>/2018/10/28/930-Binary-Subarrays-With-Sum/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>In an array A of 0s and 1s, how many non-empty subarrays have sum S?</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,0,1,0,1], S = 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">The 4 subarrays are bolded below:</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>A.length &lt;= 30000<br>0 &lt;= S &lt;= A.length<br>A[i] is either 0 or 1.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>In this question, we can apply the idea of two sum. The difference between this question and the original two sum is, this question is an array of 1 and 0. What we can do is to find all the prefix sum and the total sum on each index <code>i</code>, and then find the <code>complement</code> in the map.</p><p>The reason to use prefix sum is because, if we want to find a subarray <code>sum[i:j]</code>, we can solve it like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum[i:j]= A[i]+ A[i+1]+ ... A[j]</span><br><span class="line">        = sum[0:j]-sum[0:i-1]</span><br><span class="line">        = (A[0]+ ...+ A[i]+ ... + A[j]) - (A[0]+ ...+ A[i-1])</span><br><span class="line">        = sum[i:j]</span><br></pre></td></tr></table></figure></p><p>One thing to notice is that, we need to put every possible <code>complement</code> subarray into consideration. That is the reason why we need to check the following code.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(map.find(cur- S) != map.end())&#123;</span><br><span class="line">  res+= map[cur-S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find all subarray prefix sum using the idea of two sum</span></span><br><span class="line">        <span class="comment">// in two sum, we use unordered_map to recored every appeared number in the array</span></span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>, cur= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; A.size(); i++)&#123;</span><br><span class="line">            cur+= A[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(cur- S) != <span class="built_in">map</span>.end())&#123;</span><br><span class="line">                res+= <span class="built_in">map</span>[cur-S];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur == S) </span><br><span class="line">                res++;</span><br><span class="line">            <span class="built_in">map</span>[cur]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/QXnJ5U" target="_blank" rel="noopener">https://goo.gl/QXnJ5U</a><br><a href="https://goo.gl/tNeBxR" target="_blank" rel="noopener">https://goo.gl/tNeBxR</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode review</title>
      <link href="/2018/10/26/leetcode-review-most-interview-problem/"/>
      <url>/2018/10/26/leetcode-review-most-interview-problem/</url>
      <content type="html"><![CDATA[<p>Oct 26th:<br>1, 2,<br><a href="/2018/06/06/3-Longest-Substring-Without-Repeating-Characters/" title="3. Longest Substring Without Repeating Characters">3. Longest Substring Without Repeating Characters</a>, use a <code>left</code> variable to denote the start<br><a href="/2018/06/26/5-Longest-Palindromic-Substring/" title="5. Longest Palindromic Substring">5. Longest Palindromic Substring</a> </p><p>Oct 31th:<br><a href="/2018/08/25/206-Reverse-Linked-List/" title="206. Reverse Linked List">206. Reverse Linked List</a><br><a href="/2018/07/23/238-Product-of-Array-Except-Self/" title="238. Product of Array Except Self">238. Product of Array Except Self</a><br><a href="/2018/08/16/17-Letter-Combinations-of-a-Phone-Number/" title="17. Letter Combinations of a Phone Number">17. Letter Combinations of a Phone Number</a><br><a href="/2018/06/28/139-Word-Break/" title="139. Word Break">139. Word Break</a></p><p>Nov 1st:<br><a href="/2018/06/06/49-Group-Anagrams/" title="49. Group Anagrams">49. Group Anagrams</a><br><a href="/2018/11/01/380-Insert-Delete-GetRandom-O-1/" title="380. Insert Delete GetRandom O(1)">380. Insert Delete GetRandom O(1)</a><br><a href="/2018/06/16/236-Lowest-Common-Ancestor-of-a-Binary-Tree/" title="236. Lowest Common Ancestor of a Binary Tree">236. Lowest Common Ancestor of a Binary Tree</a></p><p>Jan 17th:<br><a href="/2018/06/06/159-Longest-Substring-with-At-Most-Two-Distinct-Characters/" title="159. Longest Substring with At Most Two Distinct Characters">159. Longest Substring with At Most Two Distinct Characters</a><br><a href="/2018/06/06/3-Longest-Substring-Without-Repeating-Characters/" title="3. Longest Substring Without Repeating Characters">3. Longest Substring Without Repeating Characters</a><br><a href="/2018/05/30/59-Spiral-Matrix-II/" title="59. Spiral Matrix II">59. Spiral Matrix II</a></p><p>Jan 18th<br><a href="/2019/01/18/62-Unique-Paths/" title="62. Unique Paths">62. Unique Paths</a><br><a href="/2018/08/27/63-Unique-Paths-II/" title="63. Unique Paths II">63. Unique Paths II</a><br><a href="/2018/06/04/64-Minimum-Path-Sum/" title="64. Minimum Path Sum">64. Minimum Path Sum</a></p><p>Jan 19th<br><a href="/2018/05/31/73-Set-Matrix-Zeroes/" title="73. Set Matrix Zeroes">73. Set Matrix Zeroes</a><br><a href="/2019/01/19/74-Search-a-2D-Matrix/" title="74. Search a 2D Matrix">74. Search a 2D Matrix</a><br><a href="/2018/06/20/75-Sort-Colors/" title="75. Sort Colors">75. Sort Colors</a></p><p>Jan 20th<br><a href="/2018/08/21/76-Minimum-Window-Substring/" title="76. Minimum Window Substring">76. Minimum Window Substring</a></p><p>Jan 22th<br><a href="/2018/05/12/84-Largest-Rectangle-in-Histogram/" title="84. Largest Rectangle in Histogram">84. Largest Rectangle in Histogram</a><br><a href="/2019/01/22/904-Fruit-Into-Baskets/" title="904. Fruit Into Baskets">904. Fruit Into Baskets</a></p><p>Feb 14th<br><a href="/2018/07/26/60-Permutation-Sequence/" title="60. Permutation Sequence">60. Permutation Sequence</a></p><p>Feb 15th<br>95-Unique-Binary-Search-Trees-II</p><p>Feb 18th</p><ol start="133"><li>Clone Graph</li></ol>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode category</title>
      <link href="/2018/10/25/Leetcode-category/"/>
      <url>/2018/10/25/Leetcode-category/</url>
      <content type="html"><![CDATA[<ul><li><p>Backtracking</p><a href="/2018/05/31/79-Word-Search/" title="79. Word Search">79. Word Search</a><a href="/2018/06/01/39-Combination-Sum/" title="39. Combination Sum">39. Combination Sum</a><a href="/2018/06/01/39-Combination-Sum/" title="39. Combination Sum">39. Combination Sum</a><a href="/2018/08/16/17-Letter-Combinations-of-a-Phone-Number/" title="17. Letter Combinations of a Phone Number">17. Letter Combinations of a Phone Number</a></li></ul><ul><li><p>prefix sum</p><a href="/2018/10/28/930-Binary-Subarrays-With-Sum/" title="930. Binary Subarrays With Sum">930. Binary Subarrays With Sum</a></li><li><p>Tree BFS </p><a href="/2018/10/29/103-Binary-Tree-Zigzag-Level-Order-Traversal/" title="103. Binary Tree Zigzag Level Order Traversal">103. Binary Tree Zigzag Level Order Traversal</a></li><li><p>Palindrome</p><a href="/2018/06/26/5-Longest-Palindromic-Substring/" title="5. Longest Palindromic Substring">5. Longest Palindromic Substring</a></li><li><p>Linkedin list</p><a href="/2018/06/06/138-Copy-List-with-Random-Pointer/" title="138. Copy List with Random Pointer">138. Copy List with Random Pointer</a></li><li><p>Substring search problem<br><a href="https://goo.gl/AJ5Sw7" target="_blank" rel="noopener">https://goo.gl/AJ5Sw7</a></p><a href="/2018/08/21/76-Minimum-Window-Substring/" title="76. Minimum Window Substring">76. Minimum Window Substring</a><a href="/2018/06/06/159-Longest-Substring-with-At-Most-Two-Distinct-Characters/" title="159. Longest Substring with At Most Two Distinct Characters">159. Longest Substring with At Most Two Distinct Characters</a></li></ul>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
          <category> note </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>909. Snakes and Ladders</title>
      <link href="/2018/10/25/909-Snakes-and-Ladders/"/>
      <url>/2018/10/25/909-Snakes-and-Ladders/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:</p><p><img src="snakes.png" alt=""></p><p>You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:</p><p>You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is &lt;= N*N.<br>(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations.)<br>If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.<br>A board square on row r and column c has a “snake or ladder” if board[r][c] != -1.  The destination of that snake or ladder is board[r][c].</p><p>Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving.  (For example, if the board is <code>[[4,-1],[-1,3]]</code>, and on the first move your destination square is <code>2</code>, then you finish your first move at <code>3</code>, because you do not continue moving to <code>4</code>.)</p><p>Return the least number of moves required to reach square N*N.  If it is not possible, return -1.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,35,-1,-1,13,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,15,-1,-1,-1,-1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">At the beginning, you start at square 1 [at row 5, column 0].</span><br><span class="line">You decide to move to square 2, and must take the ladder to square 15.</span><br><span class="line">You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.</span><br><span class="line">You then decide to move to square 14, and must take the ladder to square 35.</span><br><span class="line">You then decide to move to square 36, ending the game.</span><br><span class="line">It can be shown that you need at least 4 moves to reach the N\*N-th square, so the answer is 4.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>2 &lt;= board.length = board[0].length &lt;= 20<br>board[i][j] is between 1 and N*N or is equal to -1.<br>The board square with number 1 has no snake or ladder.<br>The board square with number N*N has no snake or ladder.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The main idea of this question is using BFS to find out how many BFS iteration we need for reaching the goal. </p><ol><li>Calculate the newRow and newCol. Because it starts from left bottom side and will change direction, so we can use two functions to do the math.</li><li>For each iteration of BFS, we should do the following things. First, check if we reach the goal <code>n*n</code>. Second, find out if there’s a bridge or snake in the next slot, then move.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="comment">//use a variable step to calculate how many steps</span></span><br><span class="line">        <span class="comment">//for each iteration, find out if the next step can reach to the end</span></span><br><span class="line">        <span class="comment">//if can not reach to the end, then add i= 1~6 to current pos</span></span><br><span class="line">        <span class="keyword">if</span>(board.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n= board.size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n*n, <span class="literal">false</span>);</span><br><span class="line">        q.push(<span class="number">1</span>);</span><br><span class="line">        visited[<span class="number">0</span>]= <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">int</span> size= q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; size; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> pos= q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= <span class="number">6</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> next= pos+ i;</span><br><span class="line">                    <span class="keyword">if</span>(next == n*n)</span><br><span class="line">                        <span class="keyword">return</span> step;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">int</span> nextRow= getRow(next, n);</span><br><span class="line">                    <span class="keyword">int</span> nextCol= getCol(next, n);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(board[nextRow][nextCol] != <span class="number">-1</span>)&#123;</span><br><span class="line">                        next= board[nextRow][nextCol];</span><br><span class="line">                        <span class="keyword">if</span>(next == n*n)</span><br><span class="line">                            <span class="keyword">return</span> step;</span><br><span class="line">                        nextRow= getRow(next, n);</span><br><span class="line">                        nextCol= getCol(next, n);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[next<span class="number">-1</span>])&#123;</span><br><span class="line">                        q.push(next);</span><br><span class="line">                        visited[next<span class="number">-1</span>]= <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n<span class="number">-1</span>-(v<span class="number">-1</span>)/n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCol</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((v<span class="number">-1</span>)/n) % <span class="number">2</span> == <span class="number">0</span>) ? ((v<span class="number">-1</span>)%n) : (n<span class="number">-1</span>-(v<span class="number">-1</span>)%n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^2)$<br>space complexity: $O(n^2)$<br>reference:<br><a href="https://goo.gl/Zbc7yK" target="_blank" rel="noopener">https://goo.gl/Zbc7yK</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Interview review</title>
      <link href="/2018/10/23/Interview-review/"/>
      <url>/2018/10/23/Interview-review/</url>
      <content type="html"><![CDATA[<h3 id="Thread-vs-Process"><a href="#Thread-vs-Process" class="headerlink" title="Thread vs Process"></a>Thread vs Process</h3><ul><li>Definition<br>A <code>process</code> is an instance of a computer program that is being executed. It contains the program code and its current activity. A process may be made up of multiple threads of execution that execute instructions concurrently. A process has a virtual address space, executable code, open handles to system objects, a security context, a unique process identifier, environment variables, a priority class, minimum and maximum working set sizes, and at least one thread of execution. Each process is started with a single thread, often called the primary thread, but can create additional threads from any of its threads.</li></ul><p>All <code>threads</code> of a process share its virtual address space and system resources. Typical difference is, processes run in separated memory while threads run in shared memory.</p><p>A <code>thread</code> is the entity within a process that can be scheduled for execution. All threads of a process share its virtual address space and system resources. In addition, each thread maintains exception handlers, a scheduling priority, thread local storage, a unique thread identifier, and a set of structures the system will use to save the thread context until it is scheduled. Typical <code>difference</code> is, processes run in separated memory while threads run in shared memory. Processes are typically independent, while threads exist as subsets of a process processes carry considerably more state information than threads, whereas multiple threads within a process share process state as well as memory and other resources processes have separate address spaces, whereas threads share their address space processes interact only through system-provided inter-process communication mechanisms context switching between threads in the same process is typically faster than context switching between processes.</p><ul><li><p>How to switch processes using interrupt<br>Store the state into <code>PCB</code>, process control block. load other process’ PCB from kernel memory, </p><ol><li>When the interrupt comes, the state of the current process is stored in a data structure call process control block(PCB)</li><li>The PCB is stored on a per-process ​stack​ in kernel memory</li><li>A ​handle​ to the PCB is added to a queue of processes that are ready to run, often called the ready queue.</li><li>So when the CPU wants to switch the process back, it simply load the handle of the PCB from the ready queue, and restore the context from the PCB</li></ol></li><li><p>Difference between process switching and thread switching<br>The main distinction between a thread switch and a process switch is that during a thread switch, the virtual <code>memory space</code> remains the same, while it does not during a process switch. Both types involve handing control over to the operating system kernel to perform the context switch. The process of switching in and out of the OS kernel along with the cost of switching out the registers is the largest fixed cost of performing a context switch.</p></li></ul><p>What is the difference between context switching and interrupt handling? <a href="https://goo.gl/RBp7LY" target="_blank" rel="noopener">https://goo.gl/RBp7LY</a><br>UCSD, I/O and Processes <a href="https://goo.gl/4Byzg8" target="_blank" rel="noopener">https://goo.gl/4Byzg8</a><br>thread context switch vs process context switch, <a href="https://goo.gl/CqgHjE" target="_blank" rel="noopener">https://goo.gl/CqgHjE</a></p><h3 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h3><p>Deadlock describes a situation where two or more threads are blocked forever, waiting for each other. A multi-threaded program may suffer from the deadlock condition because the synchronized keyword causes the executing thread to block while waiting for the lock.</p><ul><li>The reason of deadlock:<br>Deadlock can arise if following four conditions hold simultaneously (Necessary Conditions)<br><code>Mutual Exclusion &amp;&amp; Hold and Wait &amp;&amp; No preemption &amp;&amp; Circular wait</code></li></ul><ol><li>Mutual Exclusion: One or more than one resource non-sharable (Only one process can use at a time)</li><li>Hold and Wait: A process is holding at least one resource and waiting for resources.</li><li>No Preemption: A resource cannot be taken from a process unless the process releases the resource.</li><li>Circular Wait: A set of processes are waiting for each other in circular form.</li></ol><ul><li>Deadlock prevention:</li></ul><p>Try to eliminate one of the four condition</p><ol><li><p>Eliminate Mutual Exclusion<br>It is not possible to dis-satisfy the mutual exclusion because some resources, for example, printer, is inherently non-shareable.</p></li><li><p>Eliminate Hold and wait<br>Allocate all required resources to the process before start of its execution, this way “hold and wait” condition is eliminated but it will lead to <code>low device utilization</code>.<br>Process will make new request for resources after releasing the current set of resources. This solution may lead to <code>starvation</code>.</p></li><li><p>Eliminate No Preemption<br>Preempt resources from process when resources required by other high priority process.</p></li><li><p>Eliminate Circular Wait<br>Each resource will be assigned with a numerical number. A process can request for the resources only in increasing order of numbering.</p></li></ol><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p><img src="memory.png" alt=""></p><ul><li><p>Heap vs Stack<br>The capacity of stack is limited but in contrast heap has no limited size until you reach the size of virtual memory.</p><p>You can use the stack if you know exactly how much data you need to allocate before compile time and it is not too big. You can use heap if you don’t know exactly how much data you will need at runtime or if you need to allocate a lot of data.</p></li><li><p>Stack<br>Static memory allocation, variables allocated on the stack are dealt with when the program is compiled.<br>When a function calls another function which in turns calls another function etc., the execution of all those functions remains suspended until the very last function returns its value.<br>The stack is always reserved in a LIFO order, the most recently reserved block is always the next block to be freed.<br>Stack overflow: infinitely function calls exhausted the reserved stack space<br>Because limited capacity of stack plus infinite function calls with ultimately run out of all the memory spaces in stack.</p></li><li><p>Heap<br>Can think of it as a large pool of memory that can freely use.<br>Dynamic memory allocation, variables allocated on the heap have their memory allocated at run time</p><ul><li>In C++:<br>use operator <code>new</code> and <code>delete</code> to manipulate heap memory.<br>In OS machine problem, applied headmap and bitmap to determine a head of allocated memory and used memory frame.</li></ul><p><a href="https://www.youtube.com/watch?v=_8-ht2AKyH4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=_8-ht2AKyH4</a></p></li><li><p>Virtual memory</p><ul><li><p>Any error if two processes writing on the same address?<br>Nothing is wrong. Process uses virtual memory, the same address value in two different processes maps to two different physical address.</p><p>Detailed Explain:<br>virtual memory concept-&gt; addr in vm-&gt; therefore different</p><ol><li>concept of virtual memory<br>Virtual memory is a mechanism used by the operation system to “cheat” the process about the memory space a process can use. What a process can see is a large continuous memory space, so it feels happy about it. The real story is: the main memory(RAM) of a computer is very limited(For mac, it is 8GB).</li><li>The base of virtual memory is a mapping from the virtual address to the real physical address.</li><li>So if 2 processes are both running under the virtual memory mechanism, the real physical address of the OS is invisible to both of them. What they can see is the virtual memory address. Even though the see a same address, that might be mapped to different physical address underlaying.</li></ol></li></ul></li></ul><h3 id="Throughput-amp-Latency"><a href="#Throughput-amp-Latency" class="headerlink" title="Throughput &amp; Latency"></a>Throughput &amp; Latency</h3><p><code>Latency</code> is the amount of time to finish an operation. Latency is the delay from input into a system to desired outcome.<br><code>Throughput</code> is the amount of work we finished in a unit time. Throughput is a measure of how many units of information a system can process in a given amount of time. </p><h3 id="Hash-table"><a href="#Hash-table" class="headerlink" title="Hash table"></a>Hash table</h3><p>time complexity: $O(1)$ average, $O(n)$ in worst case.<br><code>Collision</code>: When two data stored in the same slot, caused the table can only keep one of them.<br>Solution:<br>Chaining: use linked list to link every element in the same slot.<br>Open addressing: use probing method to find empty slot in the table.</p><ul><li>Linear probing</li><li>Quadratic probing</li><li>Double hashing</li></ul><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><ul><li>min heap: always have the smallest element at top. <ul><li>insert new element: add it to the last child, then compare with it’s parent and decide to swap or not.</li><li>remove smallest element from top: take the last element, from top-bottom and left to right, to the root. Then swap it with the smaller element between its children.</li></ul></li></ul><p>Heap sort: sorting technique to find min/max element. </p><h3 id="C-Object-oriented-programming"><a href="#C-Object-oriented-programming" class="headerlink" title="C++, Object oriented programming"></a>C++, Object oriented programming</h3><ul><li>Object vs Class</li></ul><p>A <code>class</code> is a template for objects. A class defines object properties including a valid range of values, and a default value. A class also describes object behavior.<br>An <code>object</code> is a member or an “instance” of a class. An object has a state in which all of its properties have values that you either explicitly define or that are defined by default settings.<br><a href="https://www.geeksforgeeks.org/inheritance-in-c/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/inheritance-in-c/</a></p><ul><li><p>Interface vs Abstract class<br>Interface: define required methods when an object need to collaborate with other objects.<br>Abstract class: define what needs to be inheritance in the whole inheritance system. Child class can override the method or keep the same as father class.</p></li><li><p>Virtual function and Pure Virtual function</p></li></ul><ul><li><p>virtual function</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width, height;</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      Shape( <span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">        width = a;</span><br><span class="line">        height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>A virtual function is a function in a base class that is declared using the keyword virtual. Defining in a base class a virtual function, with another version in a derived class, signals to the compiler that we don’t want static linkage for this function.</p></li><li><p>pure virtual function</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> width, height;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    Shape(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;</span><br><span class="line">       width = a;</span><br><span class="line">       height = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// pure virtual function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The = 0 tells the compiler that the function has no body and above virtual function will be called pure virtual function.</p></li></ul><ul><li><p>mutex<br>A mutex is a lockable object that is designed to signal when critical sections of code need exclusive access, preventing other threads with the same protection from executing concurrently and access the same memory locations.</p></li><li><p>Inheritance</p><ul><li>Base class: The class whose properties are inherited by sub class is called base class</li><li><p>Derived class: The class that inherits properties from another class</p></li><li><p>Diamond problem: lowest level child have several copy after inheritance, and will have ambiguity problem. The way to solve is virtual inheritance.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> A</span><br><span class="line">/ \</span><br><span class="line">B  C</span><br><span class="line">\ /</span><br><span class="line"> D</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Solution:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> _a;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;<span class="keyword">public</span>: <span class="keyword">int</span> _b;&#125;;</span><br></pre></td></tr></table></figure><ul><li>Multi-level inheritance<br><img src="multiple-inheritance.png" alt=""></li></ul><p><a href="https://goo.gl/dPQVum" target="_blank" rel="noopener">https://goo.gl/dPQVum</a><br><a href="https://www.geeksforgeeks.org/inheritance-in-c/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/inheritance-in-c/</a></p></li><li><p>Static/Dynamic binding<br>Static, compile time binding is easy. There’s no polymorphism involved. You know the type of the object when you write and compile and run the code. Sometimes a dog is just a dog.</p><p>Dynamic, runtime binding is where polymorphism comes from.</p><p>If you have a reference that’s of parent type at compile type, you can assign a child type to it at runtime. The behavior of the reference will magically change to the appropriate type at runtime. A virtual table lookup will be done to let the runtime figure out what the dynamic type is.</p></li><li><p>void pointer<br>The void pointer, also known as the generic pointer, is a special type of pointer that can be pointed at objects of any data type!<br>However, because the void pointer does not know what type of object it is pointing to, it cannot be dereferenced directly! Rather, the void pointer must first be explicitly cast to another pointer type before it is dereferenced.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nValue;</span><br><span class="line"><span class="keyword">float</span> fValue;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Something</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Something sValue;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line">ptr = &amp;nValue; <span class="comment">// valid</span></span><br><span class="line">ptr = &amp;fValue; <span class="comment">// valid</span></span><br><span class="line">ptr = &amp;sValue; <span class="comment">// valid</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><ul><li><p>how HTTPS works</p><ol><li>browser initiate HTTPS request to webserver</li><li>webserver have public key and private key. Respond with public key.</li><li>Browser create session key.</li><li>Encrypt the session key with the public key from web server.</li><li>Webserver received the encrypted data, use private key to decrypt and get the session key.</li><li>Use session key to establish SSL connection.<br><a href="https://tiptopsecurity.com/how-does-https-work-rsa-encryption-explained/" target="_blank" rel="noopener">https://tiptopsecurity.com/how-does-https-work-rsa-encryption-explained/</a></li></ol></li><li><p>how packet transmit from one host to another<br><a href="https://www.quora.com/How-does-a-packet-get-from-one-network-to-another" target="_blank" rel="noopener">https://www.quora.com/How-does-a-packet-get-from-one-network-to-another</a></p><ul><li>Local network: A send to B<ol><li>A enter the IP(10.10.10.1) address of B. But it’s not enough, since we need MAC(Media Access Control) to uniquely identify device.</li><li>To find a remote workstation’s MAC address, the Address Resolution Protocol (ARP) is used. </li><li>A send out ARP packets asking who is 10.10.10.1, and only B would response with ARP reply</li><li>A send the packet with IP and MAC address from B</li></ol></li><li></li></ul></li><li><p>TCP, UDP, IP<br><img src="layer_terminology.JPG" alt=""></p><ul><li>What is the point of UDP when we already have IP?</li></ul></li><li><p>TCP three way handshake<br><img src="threeway.png" alt=""></p></li><li><p>OSI model<br><img src="OSI_TCPIP.jpg" alt=""></p></li><li><p>Routing protocol<br>RIP vs OSPF<br>RIP, Routing Internet Protocol, depends on hop counts to determine the best path while OSPF depends on cost (bandwidth) which helps in determining the best path.<br>Convergence in the RIP is slow in contrast it is fast in OSPF.</p><p>Open Shortest Path First is a link state and hierarchical IGP routing algorithm. It is an enhanced version of RIP, which comprises features like multipath routing, least cost routing, and load balancing. Its major metric is the cost to determine the best path.<br>OSPF offers load balancing in which it distributes overall traffic routes equally. It also allows networks and routers partitioned into subsets and areas which enhance the growth and ease of management.</p><p><a href="https://techdifferences.com/difference-between-rip-and-ospf.html" target="_blank" rel="noopener">https://techdifferences.com/difference-between-rip-and-ospf.html</a></p></li><li><p>QoS<br>QoS is defined as the control and management of a network’s data transmission capabilities by giving priority to certain types of time-sensitive and mission-critical data protocols.<br><a href="https://www.comparitech.com/net-admin/what-is-qos/" target="_blank" rel="noopener">https://www.comparitech.com/net-admin/what-is-qos/</a></p></li></ul><h3 id="Graph-Data-structure"><a href="#Graph-Data-structure" class="headerlink" title="Graph- Data structure"></a>Graph- Data structure</h3><ul><li><p>Edge list: To represent an edge, we just have an array of two vertex numbers, or an array of objects containing the vertex numbers of the vertices that the edges are incident on. If edges have weights, add either a third element to the array or more information to the object, giving the edge’s weight. Since each edge contains just two or three numbers, the total space for an edge list is $Θ(E)$.</p></li><li><p>Adjacency matrix: For a graph with $|V|$, an adjacency matrix is a $|V|×∣V∣$ matrix of 0s and 1s, where the entry in row $i$ and column $j$ is 1 if and only if the edge $(i,j)$ is in the graph. If you want to indicate an edge weight, put it in the row $i$, column $j$ entry, and reserve a special value (perhaps null) to indicate an absent edge.<br><img src="ad_matrix.png" alt=""></p></li><li>Adjacency list<br><img src="ad_list.png" alt=""></li></ul><p><a href="https://www.geeksforgeeks.org/graph-and-its-representations/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/graph-and-its-representations/</a><br><a href="https://goo.gl/ZTSF8b" target="_blank" rel="noopener">https://goo.gl/ZTSF8b</a></p><ul><li>Union-Find</li></ul><p><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a><br><a href="https://www.geeksforgeeks.org/union-find/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/union-find/</a></p><p>reference:<br><a href="http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html" target="_blank" rel="noopener">http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html</a><br><a href="https://www.geeksforgeeks.org/heap-sort/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/heap-sort/</a><br><a href="https://goo.gl/1Vf39q" target="_blank" rel="noopener">https://goo.gl/1Vf39q</a><br><a href="https://goo.gl/9G424N" target="_blank" rel="noopener">https://goo.gl/9G424N</a></p>]]></content>
      
      <categories>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>547. Friend Circles</title>
      <link href="/2018/10/23/547-Friend-Circles/"/>
      <url>/2018/10/23/547-Friend-Circles/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</p><p>Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. </span><br><span class="line">The 2nd student himself is in a friend circle. So return 2.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, </span><br><span class="line">so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.</span><br></pre></td></tr></table></figure></p><p>Note:<br>N is in range [1,200].<br>M[i][i] = 1 for all students.<br>If M[i][j] = 1, then M[j][i] = 1.</p><h3 id="Solution-BFS"><a href="#Solution-BFS" class="headerlink" title="Solution BFS:"></a>Solution BFS:</h3><p>The idea is, when we visited a person, traverse all his friends and other related people. THe following solution use BFS concept. <code>if(!visited[j] &amp;&amp; M[tmp][j])</code> means we only need to check a person when it has not been visited yet, and he is a friend of <code>tmp</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="keyword">int</span> n= M.size(), res= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            q.push(i);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp= q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                visited[tmp]= <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; n; j++)&#123;</span><br><span class="line">                    <span class="comment">//if(visited[j] || !M[tmp][j]) continue;</span></span><br><span class="line">                    <span class="keyword">if</span>(visited[j]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[j] &amp;&amp; M[tmp][j])</span><br><span class="line">                        q.push(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^2)$<br>space complexity: $O(n)$</p><h3 id="Solution-DFS"><a href="#Solution-DFS" class="headerlink" title="Solution DFS:"></a>Solution DFS:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, isConnected: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> isConnected[r][i] <span class="keyword">and</span> visited[r] == <span class="keyword">False</span>:</span><br><span class="line">                    visited[r] = <span class="keyword">True</span></span><br><span class="line">                    dfs(r)</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(isConnected)</span><br><span class="line">        visited = [<span class="keyword">False</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> visited[i] == <span class="keyword">False</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                visited[i] = <span class="keyword">True</span></span><br><span class="line">                dfs(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="keyword">int</span> n= M.size(), res= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(M, visited, i);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[index]) <span class="keyword">return</span>;</span><br><span class="line">        visited[index]= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; M.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; M[index][i])</span><br><span class="line">                dfs(M, visited, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^2)$<br>space complexity: $O(n)$</p><h2 id="Solution-Union-Find"><a href="#Solution-Union-Find" class="headerlink" title="Solution Union Find:"></a>Solution Union Find:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, isConnected: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(isConnected)</span><br><span class="line">        parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        rank = [<span class="number">1</span>]*n <span class="comment"># calculate how many node in this group, init is 1 since everyone is own group</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> parent[i] != i:</span><br><span class="line">                <span class="keyword">return</span> find(parent[i])</span><br><span class="line">            <span class="keyword">return</span> parent[i]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            rooti, rootj = find(i), find(j)</span><br><span class="line">            isConnected[i][j], isConnected[j][i] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> rooti == rootj:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            rank_big, rank_small = (rooti, rootj) <span class="keyword">if</span> rank[i] &gt; rank[j] <span class="keyword">else</span> (rootj, rooti)</span><br><span class="line">            parent[rank_small] = rank_big</span><br><span class="line">            rank[rank_big] += rank[rank_small]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> isConnected[i][j]:</span><br><span class="line">                    union(i, j)</span><br><span class="line">        <span class="keyword">return</span> len(set(find(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)))</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> union find </tag>
            
            <tag> linkedin </tag>
            
            <tag> two sigma </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>279. Perfect Squares</title>
      <link href="/2018/10/22/279-Perfect-Squares/"/>
      <url>/2018/10/22/279-Perfect-Squares/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 12</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 = 4 + 9.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>In this question, we can treat every number as combination of two numbers. In the following graph, we can see that we can use a number <code>i</code> and a square number <code>j*j</code> to get the final number <code>i+j*j</code>.<br><img src="20160604170107528.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, INT_MAX);</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i*i&lt;=n; ++i)  <span class="comment">//pre-process, setup all the square number </span></span><br><span class="line">            dp[i*i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= n; ++i)&#123;      <span class="comment">//pick first number i</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i+j*j&lt;=n; ++j)&#123;    <span class="comment">//pick another number j*j  </span></span><br><span class="line">                dp[i+j*j] = min(dp[i]+<span class="number">1</span>, dp[i+j*j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/4R5avB" target="_blank" rel="noopener">https://goo.gl/4R5avB</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> lyft </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>53. Maximum Subarray</title>
      <link href="/2018/10/22/53-Maximum-Subarray/"/>
      <url>/2018/10/22/53-Maximum-Subarray/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:</p><p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p><p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>For this question, we can use an algorithm called <a href="https://www.geeksforgeeks.org/?p=576/" target="_blank" rel="noopener">Kadane’s Algorithm</a>. By maintaining two variables, <code>max_endhere</code> and <code>max_sofar</code>, we can calculate the maximum continuous subarray sum. </p><p>For example:<br>[2,-3,4,5]<br>i= 0: max_endhere= 2,max_sofar= 2<br>i= 1: max_endhere= -1,max_sofar= 2<br>i= 2: max_endhere= 4,max_sofar= 4<br>i= 3: max_endhere= 9,max_sofar= 9</p><p>[-2,-3,-1]<br>i= 0: max_endhere= -2,max_sofar= -2<br>i= 1: max_endhere= -3,max_sofar= -2<br>i= 2: max_endhere= -1,max_sofar= -1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        cur, res = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            cur = max(num, cur+num)</span><br><span class="line">            res = max(res, cur)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_endhere= <span class="number">0</span>, max_sofar= INT_MIN;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_endhere&lt;<span class="number">0</span>)</span><br><span class="line">                max_endhere = nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                max_endhere+= nums[i];</span><br><span class="line">            </span><br><span class="line">            max_sofar= max(max_endhere, max_sofar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sofar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://www.geeksforgeeks.org/?p=576/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/?p=576/</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> linkedin </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>918. Maximum Sum Circular Subarray</title>
      <link href="/2018/10/22/918-Maximum-Sum-Circular-Subarray/"/>
      <url>/2018/10/22/918-Maximum-Sum-Circular-Subarray/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.</p><p>Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 &lt;= i &lt; A.length, and C[i+A.length] = C[i] when i &gt;= 0.)</p><p>Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], …, C[j], there does not exist i &lt;= k1, k2 &lt;= j with k1 % A.length = k2 % A.length.)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [5,-3,5]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [3,-1,2,-1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: [3,-2,2,-3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: [-2,-3,-1]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: Subarray [-1] has maximum sum -1</span><br></pre></td></tr></table></figure><p>Note:</p><p>-30000 &lt;= A[i] &lt;= 30000<br>1 &lt;= A.length &lt;= 30000</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This is a followup question of <a href="/2018/10/22/53-Maximum-Subarray/" title="53. Maximum Subarray">53. Maximum Subarray</a>. We can use a similar idea to solve it.<br>The idea is to remove the biggest negative sum in the array. Then the rest of the elements are the maximum sum in a continuous way.</p><p>Idea:<br>The result will have the following two different cases.<br><img src="image_1538888300.png" alt=""></p><p>For example:<br>[2,3,-6,-7,4,5]<br>total sum= 1: 2+3+4+5= 14, -6+(-7)= -13<br>that is to say, if we can find the elements we want to remove, then we can get the maximum continuous sum.</p><ol><li>Calculate the maximum continuous sum, <code>nocircle</code>, of the original array. If the <code>nocircle</code> is negative, it means all the elements in the array is negative. Therefore, just return the largest negative element. Which is -1 in the above example.</li><li>Sum up the array, and multiply each element with <code>-1</code> in the mean time. By doing this, we can use the same help function to get the smallest continuous sum in the original array, which is <code>[6,7]</code> in above example.</li><li>Compare the <code>nocircle</code> and <code>circle</code>, return the maximum one.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nocircle= help(A), sum= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nocircle &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nocircle;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp= A;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;n: tmp)&#123;</span><br><span class="line">            sum+= n;</span><br><span class="line">            n*= <span class="number">-1</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> circle= sum+ help(tmp);</span><br><span class="line">        <span class="keyword">return</span> max(circle, nocircle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_endhere= <span class="number">0</span>, max_sofar= INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; A.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_endhere &lt; <span class="number">0</span>)</span><br><span class="line">                max_endhere= A[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                max_endhere+= A[i];</span><br><span class="line">            </span><br><span class="line">            max_sofar= max(max_sofar, max_endhere);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_sofar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution-One-pass"><a href="#Solution-One-pass" class="headerlink" title="Solution One pass:"></a>Solution One pass:</h3><p>We can further optimize the code with four variables to record the current minimum/maximum, all tim minimum/maximum as shown below.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>, maxSum = <span class="number">-30000</span>, curMax = <span class="number">0</span>, minSum = <span class="number">30000</span>, curMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            curMax = max(curMax + a, a);</span><br><span class="line">            maxSum = max(maxSum, curMax);</span><br><span class="line">            curMin = min(curMin + a, a);</span><br><span class="line">            minSum = min(minSum, curMin);</span><br><span class="line">            total += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum &gt; <span class="number">0</span> ? max(maxSum, total - minSum) : maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://www.geeksforgeeks.org/maximum-contiguous-circular-sum/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/maximum-contiguous-circular-sum/</a><br><a href="https://goo.gl/na2uyB" target="_blank" rel="noopener">https://goo.gl/na2uyB</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> two sigma </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>716. Max Stack</title>
      <link href="/2018/10/19/716-Max-Stack/"/>
      <url>/2018/10/19/716-Max-Stack/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a max stack that supports push, pop, top, peekMax and popMax.</p><p>push(x) – Push element x onto stack.<br>pop() – Remove the element on top of the stack and return it.<br>top() – Get the element on the top.<br>peekMax() – Retrieve the maximum element in the stack.<br>popMax() – Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MaxStack stack = new MaxStack();</span><br><span class="line">stack.push(5); </span><br><span class="line">stack.push(1);</span><br><span class="line">stack.push(5);</span><br><span class="line">stack.top(); -&gt; 5</span><br><span class="line">stack.popMax(); -&gt; 5</span><br><span class="line">stack.top(); -&gt; 1</span><br><span class="line">stack.peekMax(); -&gt; 5</span><br><span class="line">stack.pop(); -&gt; 1</span><br><span class="line">stack.top(); -&gt; 5</span><br></pre></td></tr></table></figure></p><p>Note:<br>-1e7 &lt;= x &lt;= 1e7<br>Number of operations won’t exceed 10000.<br>The last four operations won’t be called when stack is empty.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This question is similar to </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; total, maxstk;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        total.push(x);</span><br><span class="line">        <span class="keyword">if</span>(maxstk.empty() || x&gt;= maxstk.top())</span><br><span class="line">            maxstk.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxstk.top() == total.top())</span><br><span class="line">            maxstk.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> tmp= total.top();</span><br><span class="line">        total.pop();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peekMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxstk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">popMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(total.top() != maxstk.top())&#123;</span><br><span class="line">            q.push(total.top()); total.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp= maxstk.top();</span><br><span class="line">        maxstk.pop();</span><br><span class="line">        total.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            total.push(q.top());</span><br><span class="line">            <span class="keyword">if</span>(maxstk.empty() || q.top()&gt;= maxstk.top())</span><br><span class="line">                maxstk.push(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxStack obj = new MaxStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.peekMax();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.popMax();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> design </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>155. Min Stack</title>
      <link href="/2018/10/19/155-Min-Stack/"/>
      <url>/2018/10/19/155-Min-Stack/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>getMin() – Retrieve the minimum element in the stack.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This problem is a little different from original stack, because it combines features of <code>minheap</code> and <code>stack</code>.</p><p>We can maintain two stacks. One is to store every element push into the <code>MinStack</code>, the other only stores the <code>minimum</code> element. </p><p>In the <code>push</code> function, whenever we need to push an element, check if it’s smaller than the <code>top</code> element in <code>minstk</code>.</p><p>In <code>pop</code> function, since every element are definitely in the <code>total</code>. We can check if the going-to-be-pop-out element from <code>total</code> is the same as the <code>top</code> element in <code>minstk</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stk = []</span><br><span class="line">        self.min = float(<span class="string">'inf'</span>)</span><br><span class="line">        self.prev_min = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> val &lt;= self.min:</span><br><span class="line">            self.prev_min.append(self.min)</span><br><span class="line">            self.min = val</span><br><span class="line">        self.stk.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stk:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> self.top() == self.min:</span><br><span class="line">            self.min = self.prev_min[<span class="number">-1</span>]</span><br><span class="line">            self.prev_min.pop()</span><br><span class="line">        self.stk.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stk[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stk:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> self.min</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; total;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minstk;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        total.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minstk.empty() || x&lt;= minstk.top())</span><br><span class="line">            minstk.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(total.top() == minstk.top()) minstk.pop();</span><br><span class="line">        total.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstk.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(1)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> stack </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
            <tag> bloomberg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>703. Kth Largest Element in a Stream</title>
      <link href="/2018/10/18/703-Kth-Largest-Element-in-a-Stream/"/>
      <url>/2018/10/18/703-Kth-Largest-Element-in-a-Stream/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.</p><p>Example:</p><p>int k = 3;<br>int[] arr = [4,5,8,2];<br>KthLargest kthLargest = new KthLargest(3, arr);<br>kthLargest.add(3);   // returns 4<br>kthLargest.add(5);   // returns 5<br>kthLargest.add(10);  // returns 5<br>kthLargest.add(9);   // returns 8<br>kthLargest.add(4);   // returns 8<br>Note:<br>You may assume that nums’ length ≥ k-1 and k ≥ 1.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>In the question, it asked us to return the <code>k</code>th largest element(not distinct element). To this kind of question, we can use <code>priority_queue</code> to solve. </p><p>Maintain a <code>priority_queue</code>, minheap, with size <code>k</code>.<br>Whenever we push an element into queue, check if the queue size exceed k.<br>If it exceed k, pop out the top element(the smallest one).</p><p>example:<br>minheap: [], k= 3</p><p>push 4  [4]<br>push 5  [4,5]<br>push 8  [4,5,8]<br>push 2  [2,4,5,8], since the size of queue is <code>4</code> exceed <code>k</code>, pop out the element at top.<br>        [4,5,8]</p><p>push 3  [3,4,5,8]<br>        [4,5,8]</p><p>push 5  [4,5,5,8]<br>        [5,5,8]</p><p>push 10 [5,5,8,10]<br>        [5,8,10]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int, nums: List[int])</span>:</span></span><br><span class="line">        self.pool = nums</span><br><span class="line">        self.k = k</span><br><span class="line">        heapify(self.pool)</span><br><span class="line">        <span class="keyword">while</span> len(self.pool) &gt; k:</span><br><span class="line">            heapq.heappop(self.pool)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.pool) &lt; self.k:</span><br><span class="line">            heapq.heappush(self.pool, val)</span><br><span class="line">        <span class="keyword">elif</span> val &gt; self.pool[<span class="number">0</span>]:</span><br><span class="line">            heapq.heapreplace(self.pool, val)</span><br><span class="line">        <span class="keyword">return</span> self.pool[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">int</span> _k;</span><br><span class="line">    KthLargest(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        _k= k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: nums)&#123;</span><br><span class="line">            pq.push(n);</span><br><span class="line">            <span class="keyword">if</span>(pq.size()&gt; _k)</span><br><span class="line">                pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.push(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.size()&gt; _k)</span><br><span class="line">            pq.pop();</span><br><span class="line">        <span class="keyword">return</span> pq.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * KthLargest obj = new KthLargest(k, nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.add(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$, because the push takes $O(logn)$<br>space complexity: $O(1)$, because only need to keep <code>k</code> elements<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> amazon </tag>
            
            <tag> heap </tag>
            
            <tag> ebay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>240. Search a 2D Matrix II</title>
      <link href="/2018/10/08/240-Search-a-2D-Matrix-II/"/>
      <url>/2018/10/08/240-Search-a-2D-Matrix-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>Example:</p><p>Consider the following matrix:</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>Given target = 5, return true.</p><p>Given target = 20, return false.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find in m*n array</span></span><br><span class="line">        <span class="comment">//pick a row then search each column position in it, then switch to other row</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; <span class="comment">//notice that we start from last position in a row</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt; target)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> binary search </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>295. Find Median from Data Stream</title>
      <link href="/2018/10/08/295-Find-Median-from-Data-Stream/"/>
      <url>/2018/10/08/295-Find-Median-from-Data-Stream/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p><p>For example,<br>[2,3,4], the median is 3</p><p>[2,3], the median is (2 + 3) / 2 = 2.5</p><p>Design a data structure that supports the following two operations:</p><p>void addNum(int num) - Add a integer number from the data stream to the data structure.<br>double findMedian() - Return the median of all elements so far.</p><p>Example:</p><p>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2</p><p>Follow up:</p><p>If all integer numbers from the stream are between 0 and 100, how would you optimize it?<br>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Questions to ask:</p><ul><li>input always integers?</li><li>what kind of output for median, double or round to integer?</li><li>space complexity constraint?</li></ul><p>Use heap to solve this question. Let’s say we have input like this: <code>1 7 3 4 5 8 2 6</code>. If use <code>maxheap</code> to store it, it’ll become <code>1 2 3 4 5 6 7 8</code> where 8 is the top. The trick of this problem is to use two <code>maxheap</code> to store the left half and right half. In the <code>left</code> heap, simply push number in it; however, in <code>right</code> heap, push the negative number in it, so the smallest element will at top.</p><p>For example:<br>input: <code>1 7 3 4 5 8 2 6</code></p><p><code>1 2 3 4</code><br><code>smaller</code>: 4 is the top<br><code>-8 -7 -6 -5</code><br><code>larger</code>: -5 is the top</p><p>Another thing to mention is that, always keep <code>left.size()</code> &gt; <code>right.size()</code>. This is to track if the total number of elements is odd or even.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; left, right;</span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        left.push(num); <span class="comment">//O(logn)</span></span><br><span class="line">        right.push(-left.top());</span><br><span class="line">        left.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left.size() &lt; right.size())&#123; <span class="comment">//make left size always bigger than right, for finding median</span></span><br><span class="line">            left.push(-right.top());</span><br><span class="line">            right.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.size()&gt; right.size()? left.top(): <span class="number">0.5</span>*(left.top()-right.top()); <span class="comment">//in right, numbers are negative</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(logn)$ for insert into heap, $O(1)$ for findMedian<br>space complexity: $O(n)$<br>reference:<br><a href="http://www.cnblogs.com/grandyang/p/4896673.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4896673.html</a><br><a href="https://goo.gl/if9kLS" target="_blank" rel="noopener">https://goo.gl/if9kLS</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> apple </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>146. LRU Cache</title>
      <link href="/2018/10/03/146-LRU-Cache/"/>
      <url>/2018/10/03/146-LRU-Cache/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p><p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>Follow up:<br>Could you do both operations in O(1) time complexity?</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* capacity */ );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // returns 1</span><br><span class="line">cache.put(3, 3);    // evicts key 2</span><br><span class="line">cache.get(2);       // returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    // evicts key 1</span><br><span class="line">cache.get(1);       // returns -1 (not found)</span><br><span class="line">cache.get(3);       // returns 3</span><br><span class="line">cache.get(4);       // returns 4</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Pythonic way is to use <code>OrderedDict()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            val = self.cache[key]</span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># renew the node</span></span><br><span class="line">            <span class="keyword">del</span> self.cache[key]</span><br><span class="line">            self.cache[key] = value</span><br><span class="line">        <span class="keyword">elif</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache <span class="keyword">and</span> len(self.cache) == self.capacity:</span><br><span class="line">            self.cache.popitem(last=<span class="keyword">False</span>)</span><br><span class="line">            self.cache[key] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.cache[key] = value</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k, v)</span>:</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.val = v</span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.dic = dict()</span><br><span class="line">        self.head = Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.tail = Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            n = self.dic[key]</span><br><span class="line">            self._remove(n)</span><br><span class="line">            self._add(n)</span><br><span class="line">            <span class="keyword">return</span> n.val</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            self._remove(self.dic[key])</span><br><span class="line">        n = Node(key, value)</span><br><span class="line">        self._add(n)</span><br><span class="line">        self.dic[key] = n</span><br><span class="line">        <span class="keyword">if</span> len(self.dic) &gt; self.capacity:</span><br><span class="line">            n = self.head.next</span><br><span class="line">            self._remove(n)</span><br><span class="line">            <span class="keyword">del</span> self.dic[n.key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        p = node.prev</span><br><span class="line">        n = node.next</span><br><span class="line">        p.next = n</span><br><span class="line">        n.prev = p</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        p = self.tail.prev</span><br><span class="line">        p.next = node</span><br><span class="line">        self.tail.prev = node</span><br><span class="line">        node.prev = p</span><br><span class="line">        node.next = self.tail</span><br></pre></td></tr></table></figure><h3 id="Solution-C"><a href="#Solution-C" class="headerlink" title="Solution: C++"></a>Solution: C++</h3><p>For this question, we need to think how to track a memory block by a <code>key</code> value.<br><code>list&lt;pair&lt;int, int&gt;&gt;</code> represents the memory queue, &lt;key, value&gt;<br><code>unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;</code> can help us find position of memory block in list<br><code>size</code> denotes the memory capacity</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//need three variable to store information</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; l;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; <span class="built_in">map</span>;</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        size= capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find if this key exist in the map</span></span><br><span class="line">        <span class="comment">// if exist, move it to the beginning in the list</span></span><br><span class="line">        <span class="keyword">auto</span> it= <span class="built_in">map</span>.find(key);</span><br><span class="line">        <span class="keyword">if</span>(it == <span class="built_in">map</span>.end()) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//can not find, return -1</span></span><br><span class="line">        l.splice(l.begin(), l, it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second-&gt;second; <span class="comment">//the value corresponding to the key is in list</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it= <span class="built_in">map</span>.find(key);</span><br><span class="line">        <span class="keyword">if</span>(it != <span class="built_in">map</span>.end()) <span class="comment">//exist in the map and list, erase and make a new one</span></span><br><span class="line">            l.erase(it-&gt;second);</span><br><span class="line">        </span><br><span class="line">        l.push_front(make_pair(key, value));</span><br><span class="line">        <span class="built_in">map</span>[key]= l.begin(); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.size() &gt; size)&#123;</span><br><span class="line">            <span class="keyword">auto</span> index= l.rbegin()-&gt;first;</span><br><span class="line">            l.pop_back();</span><br><span class="line">            <span class="built_in">map</span>.erase(index);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(1)$<br>space complexity: $O(n)$<br>reference:<br><a href="http://www.cnblogs.com/grandyang/p/4587511.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4587511.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> apple </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>220. Contains Duplicate III</title>
      <link href="/2018/10/01/220-Contains-Duplicate-III/"/>
      <url>/2018/10/01/220-Contains-Duplicate-III/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.</p><p>Example 1:</p><p>Input: nums = [1,2,3,1], k = 3, t = 0<br>Output: true<br>Example 2:</p><p>Input: nums = [1,0,1,1], k = 1, t = 2<br>Output: true<br>Example 3:</p><p>Input: nums = [1,5,9,1,5,9], k = 2, t = 3<br>Output: false</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question to ask:</p><ol><li>the range of input number. INT_MIN, INT_MAX?</li><li>negative should also be considered?</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Find abs(nums[i]-nums[j]) &lt;= t</span></span><br><span class="line">        <span class="comment">//abs(i-j) &lt;= k</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; m; <span class="comment">//map&lt;nums[i], i&gt;</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - j &gt; k)&#123; </span><br><span class="line">                m.erase(nums[j]); <span class="comment">//this is to make sure every (i, j) difference will not exceed k</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> a = m.lower_bound((<span class="keyword">long</span> <span class="keyword">long</span>)nums[i] - t); <span class="comment">//lower_bound takes O(logn)</span></span><br><span class="line">            <span class="keyword">if</span> (a != m.end() &amp;&amp; <span class="built_in">abs</span>(a-&gt;first - nums[i]) &lt;= t) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/TXon4t" target="_blank" rel="noopener">https://goo.gl/TXon4t</a><br><a href="https://goo.gl/gc6Dg7" target="_blank" rel="noopener">https://goo.gl/gc6Dg7</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
            <tag> binary search tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>c++ map bound</title>
      <link href="/2018/10/01/c-map-bound/"/>
      <url>/2018/10/01/c-map-bound/</url>
      <content type="html"><![CDATA[<p>It’s a very useful function to find elements in map.</p><p>iterator <code>lower_bound</code> (const key_type&amp; k);<br>Returns an iterator pointing to the first element in the container whose key is not considered to go before k (i.e., either it is equivalent or goes after).</p><p>iterator <code>upper_bound</code> (const key_type&amp; k);<br>Returns an iterator pointing to the first element in the container whose key is considered to go after k.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator itlow,itup;   </span><br><span class="line">  </span><br><span class="line">mymap[<span class="string">'a'</span>]=<span class="number">0</span>;</span><br><span class="line">mymap[<span class="string">'b'</span>]=<span class="number">0</span>;  </span><br><span class="line">mymap[<span class="string">'d'</span>]=<span class="number">0</span>;  </span><br><span class="line">mymap[<span class="string">'t'</span>]=<span class="number">0</span>;</span><br><span class="line">mymap[<span class="string">'x'</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">itlow=mymap.lower_bound (<span class="string">'c'</span>);  </span><br><span class="line"><span class="comment">// find the first key element that is at least greater(&gt;=) than 'c'</span></span><br><span class="line"><span class="comment">// in this case, it's 'd'</span></span><br><span class="line">  </span><br><span class="line">itlow=mymap.lower_bound (<span class="string">'b'</span>);  </span><br><span class="line"><span class="comment">// find the first key element that is at least greater(&gt;=) than 'c'</span></span><br><span class="line"><span class="comment">// in this case, it's 'd'</span></span><br><span class="line"></span><br><span class="line">itup=mymap.upper_bound (<span class="string">'d'</span>);   </span><br><span class="line"><span class="comment">// find the first element that is definite greater than 'd'</span></span><br><span class="line"><span class="comment">// point to something &gt; 'd' and not including 'd', so it's 't'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; itlow-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; itlow-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; itup-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; itup-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/BkfLdA" target="_blank" rel="noopener">https://goo.gl/BkfLdA</a><br><a href="https://goo.gl/TXon4t" target="_blank" rel="noopener">https://goo.gl/TXon4t</a></p>]]></content>
      
      <categories>
          
          <category> programming language </category>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
            <tag> c++ </tag>
            
            <tag> lower_bound </tag>
            
            <tag> upper_bound </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>219. Contains Duplicate II</title>
      <link href="/2018/10/01/219-Contains-Duplicate-II/"/>
      <url>/2018/10/01/219-Contains-Duplicate-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p><p>Example 1:</p><p>Input: nums = [1,2,3,1], k = 3<br>Output: true<br>Example 2:</p><p>Input: nums = [1,0,1,1], k = 1<br>Output: true<br>Example 3:</p><p>Input: nums = [1,2,3,1,2,3], k = 2<br>Output: false</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(nums[i]) != <span class="built_in">map</span>.end())&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - <span class="built_in">map</span>[nums[i]] &lt;= k)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]]= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>217. Contains Duplicate</title>
      <link href="/2018/10/01/217-Contains-Duplicate/"/>
      <url>/2018/10/01/217-Contains-Duplicate/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of integers, find if the array contains any duplicates.</p><p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><p>Example 1:</p><p>Input: [1,2,3,1]<br>Output: true<br>Example 2:</p><p>Input: [1,2,3,4]<br>Output: false<br>Example 3:</p><p>Input: [1,1,1,3,3,4,3,2,4,2]<br>Output: true</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Simply use a set to recorder any number that are already appeared.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>.find(n) != <span class="built_in">set</span>.end())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">set</span>.insert(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.size() &gt; <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;(nums.begin(), nums.end()).size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
            <tag> adobe </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>71. Simplify Path</title>
      <link href="/2018/09/21/71-Simplify-Path/"/>
      <url>/2018/09/21/71-Simplify-Path/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an absolute path for a file (Unix-style), simplify it. </p><p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”<br>path = “/a/../../b/../c//.//“, =&gt; “/c”<br>path = “/a//b////c/d//././/..”, =&gt; “/a/b/c”</p><p>In a UNIX-style file system, a period (‘.’) refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period (“..”) moves up a directory, so it cancels out whatever the last directory was. For more information, look here: <a href="https://en.wikipedia.org/wiki/Path_(computing)#Unix_style" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Path_(computing)#Unix_style</a></p><p>Corner Cases:</p><p>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.<br>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.<br>In this case, you should ignore redundant slashes and return “/home/foo”.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to think of we need to keep the visited paths in a way that we could easily find the last one(need to go back one directory if we meet <code>..</code>).<br>Then we can make the pushing to stack more strict, ie: only pushing the things we want into stack. So we don’t need to push <code>.</code> into stack.<br>Another thing to mention in python is the <code>join</code>, <code>separator.join(iterable)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path: str)</span> -&gt; str:</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> path.split(<span class="string">'/'</span>):</span><br><span class="line">            <span class="keyword">if</span> p == <span class="string">'..'</span>:</span><br><span class="line">                <span class="keyword">if</span> stk:</span><br><span class="line">                    stk.pop()</span><br><span class="line">            <span class="keyword">elif</span> p <span class="keyword">and</span> p != <span class="string">'.'</span>:</span><br><span class="line">                stk.append(p)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span>+<span class="string">'/'</span>.join(stk)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(getline(ss, tmp, <span class="string">'/'</span>))&#123; <span class="comment">//use '/' as separator and get string from ss to tmp</span></span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="string">""</span> || tmp == <span class="string">"."</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="string">".."</span> &amp;&amp; !stk.empty()) stk.pop_back(); <span class="comment">// ".." so remove last path in stack</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp != <span class="string">".."</span>) stk.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str: stk) res+= <span class="string">"/"</span>+str;</span><br><span class="line">        <span class="keyword">return</span> res.empty()? <span class="string">"/"</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>674. Longest Continuous Increasing Subsequence</title>
      <link href="/2018/09/21/674-Longest-Continuous-Increasing-Subsequence/"/>
      <url>/2018/09/21/674-Longest-Continuous-Increasing-Subsequence/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,4,7]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. </span><br><span class="line">Even though [1,3,5,7] is also an increasing subsequence, it&apos;s not a continuous one where 5 and 7 are separated by 4.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,2,2,2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The longest continuous increasing subsequence is [2], its length is 1.</span><br></pre></td></tr></table></figure></p><p>Note: Length of the array will not exceed 10,000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count= <span class="number">0</span>, res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || nums[i<span class="number">-1</span>]&lt; nums[i])</span><br><span class="line">                res= max(res, ++count);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>210. Course Schedule II</title>
      <link href="/2018/09/21/210-Course-Schedule-II/"/>
      <url>/2018/09/21/210-Course-Schedule-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p><p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p><p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   </span><br><span class="line">             course 0. So the correct course order is [0,1] .</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     </span><br><span class="line">             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. </span><br><span class="line">             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p><h3 id="Solution-Topological-sort"><a href="#Solution-Topological-sort" class="headerlink" title="Solution Topological sort:"></a>Solution Topological sort:</h3><p>follow up question for <a href="/2018/08/08/207-Course-Schedule/" title="%. Use a vector to store the element that we pop out from the queue. If eventually the size of result vector is equal to numCourses, then there’s no cycle in the graph.</p> <figure class=highlight python><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre></td><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span>:</span></span><br><span class=line> <span class=function><span class=keyword>def</span> <span class=title>findOrder</span><span class=params>(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=line> sortedorder = []</span><br><span class=line> <span class=keyword>if</span> numCourses &lt;= <span class=number>0</span>:</span><br><span class=line> <span class=keyword>return</span> <span class=keyword>False</span></span><br><span class=line> inDegree = &#123;i : <span class=number>0</span> <span class=keyword>for</span> i <span class=keyword>in</span> range(numCourses)&#125;</span><br><span class=line> graph = &#123;i : [] <span class=keyword>for</span> i <span class=keyword>in</span> range(numCourses)&#125;</span><br><span class=line> </span><br><span class=line> <span class=keyword>for</span> child, parent <span class=keyword>in</span> prerequisites:</span><br><span class=line> graph[parent].append(child)</span><br><span class=line> inDegree[child] += <span class=number>1</span></span><br><span class=line></span><br><span class=line> sources = deque()</span><br><span class=line> </span><br><span class=line> <span class=keyword>for</span> key <span class=keyword>in</span> inDegree:</span><br><span class=line> <span class=keyword>if</span> inDegree[key] == <span class=number>0</span>:</span><br><span class=line> sources.append(key)</span><br><span class=line> <span class=comment>#visited = 0 </span></span><br><span class=line> <span class=keyword>while</span> sources:</span><br><span class=line> vertex = sources.popleft()</span><br><span class=line> <span class=comment>#visited += 1</span></span><br><span class=line> sortedorder.append(vertex)</span><br><span class=line> <span class=keyword>for</span> child <span class=keyword>in</span> graph[vertex]:</span><br><span class=line> inDegree[child] -= <span class=number>1</span></span><br><span class=line> <span class=keyword>if</span> inDegree[child] == <span class=number>0</span>:</span><br><span class=line> sources.append(child)</span><br><span class=line> </span><br><span class=line> <span class=keyword>if</span> len(sortedorder) != numCourses:</span><br><span class=line> <span class=keyword>return</span> []</span><br><span class=line> <span class=keyword>return</span> sortedorder</span><br></pre></td></tr></table></figure> <figure class=highlight c++><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre></td><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span> &#123;</span></span><br><span class=line><span class=keyword>public</span>:</span><br><span class=line> <span class=built_in>vector</span>&lt;<span class=keyword>int</span>&gt; findOrder(<span class=keyword>int</span> numCourses, <span class=built_in>vector</span>&lt;pair&lt;<span class=keyword>int</span>, <span class=keyword>int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class=line> <span class=built_in>vector</span>&lt;<span class=keyword>int</span>&gt; res;</span><br><span class=line> <span class=built_in>vector</span>&lt;<span class=built_in>vector</span>&lt;<span class=keyword>int</span>&gt; &gt; graph(numCourses, <span class=built_in>vector</span>&lt;<span class=keyword>int</span>&gt;(<span class=number>0</span>));</span><br><span class=line> <span class=built_in>vector</span>&lt;<span class=keyword>int</span>&gt; in(numCourses, <span class=number>0</span>);</span><br><span class=line> <span class=keyword>for</span> (<span class=keyword>auto</span> &amp;a : prerequisites) &#123;</span><br><span class=line> graph[a.second].push_back(a.first);</span><br><span class=line> ++in[a.first];</span><br><span class=line> &#125;</span><br><span class=line> <span class=built_in>queue</span>&lt;<span class=keyword>int</span>&gt; q;</span><br><span class=line> <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class=line> <span class=keyword>if</span> (in[i] == <span class=number>0</span>) q.push(i);</span><br><span class=line> &#125;</span><br><span class=line> <span class=keyword>while</span> (!q.empty()) &#123;</span><br><span class=line> <span class=keyword>int</span> t = q.front();</span><br><span class=line> res.push_back(t);</span><br><span class=line> q.pop();</span><br><span class=line> <span class=keyword>for</span> (<span class=keyword>auto</span> &amp;a : graph[t]) &#123;</span><br><span class=line> --in[a];</span><br><span class=line> <span class=keyword>if</span> (in[a] == <span class=number>0</span>) q.push(a);</span><br><span class=line> &#125;</span><br><span class=line> &#125;</span><br><span class=line> <span class=keyword>if</span> (res.size() != numCourses) res.clear();</span><br><span class=line> <span class=keyword>return</span> res;</span><br><span class=line> &#125;</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure> <h2 id=Solution-DFS><a href=#Solution-DFS class=headerlink title=Solution DFS:></a>Solution DFS:</h2><figure class=highlight python><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre></td><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Solution</span>:</span></span><br><span class=line> <span class=function><span class=keyword>def</span> <span class=title>findOrder</span><span class=params>(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class=line> <span class=comment># build indegree map, use result array to keep all visited nodes</span></span><br><span class=line> <span class=comment># visit status: -1 visiting, 0 not visit, 1 visited</span></span><br><span class=line> <span class=comment># if there's cycle(need to visit visiting node), then return []</span></span><br><span class=line> res = []</span><br><span class=line> graph = [[] <span class=keyword>for</span> _ <span class=keyword>in</span> range(numCourses)]</span><br><span class=line> visited = [<span class=number>0</span> <span class=keyword>for</span> i <span class=keyword>in</span> range(numCourses)]</span><br><span class=line> </span><br><span class=line> <span class=keyword>for</span> pre <span class=keyword>in</span> prerequisites:</span><br><span class=line> graph[pre[<span class=number>1</span>]].append(pre[<span class=number>0</span>])</span><br><span class=line> </span><br><span class=line> <span class=keyword>for</span> i <span class=keyword>in</span> range(numCourses):</span><br><span class=line> <span class=keyword>if</span> <span class=keyword>not</span> self.dfs(graph, visited, i, res):</span><br><span class=line> <span class=keyword>return</span> []</span><br><span class=line> <span class=keyword>return</span> res[::<span class=number>-1</span>]</span><br><span class=line> <span class=function><span class=keyword>def</span> <span class=title>dfs</span><span class=params>(self, graph, visited, i, res)</span>:</span></span><br><span class=line> <span class=keyword>if</span> visited[i] == <span class=number>1</span>:</span><br><span class=line> <span class=keyword>return</span> <span class=keyword>True</span></span><br><span class=line> <span class=keyword>if</span> visited[i] == <span class=number>-1</span>:</span><br><span class=line> <span class=keyword>return</span> <span class=keyword>False</span></span><br><span class=line> visited[i] = <span class=number>-1</span></span><br><span class=line> <span class=keyword>for</span> nextCourse <span class=keyword>in</span> graph[i]:</span><br><span class=line> <span class=keyword>if</span> <span class=keyword>not</span> self.dfs(graph, visited, nextCourse, res):</span><br><span class=line> <span class=keyword>return</span> <span class=keyword>False</span></span><br><span class=line> visited[i] = <span class=number>1</span></span><br><span class=line> res.append(i)</span><br><span class=line> <span class=keyword>return</span> <span class=keyword>True</span></span><br></pre></td></tr></table></figure> <p>time complexity: $O(VE)$<br>space complexity: $O(V+E)$<br>reference:</p>">%. Use a vector to store the element that we pop out from the queue. If eventually the size of result vector is equal to numCourses, then there’s no cycle in the graph.</a></p> <figure class="highlight" python=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line"> sortedorder = []</span><br><span class="line"> <span class="keyword">if</span> numCourses &lt;= <span class="number">0</span>:</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"> inDegree = &#123;i : <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses)&#125;</span><br><span class="line"> graph = &#123;i : [] <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses)&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> child, parent <span class="keyword">in</span> prerequisites:</span><br><span class="line"> graph[parent].append(child)</span><br><span class="line"> inDegree[child] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"> sources = deque()</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> key <span class="keyword">in</span> inDegree:</span><br><span class="line"> <span class="keyword">if</span> inDegree[key] == <span class="number">0</span>:</span><br><span class="line"> sources.append(key)</span><br><span class="line"> <span class="comment">#visited = 0 </span></span><br><span class="line"> <span class="keyword">while</span> sources:</span><br><span class="line"> vertex = sources.popleft()</span><br><span class="line"> <span class="comment">#visited += 1</span></span><br><span class="line"> sortedorder.append(vertex)</span><br><span class="line"> <span class="keyword">for</span> child <span class="keyword">in</span> graph[vertex]:</span><br><span class="line"> inDegree[child] -= <span class="number">1</span></span><br><span class="line"> <span class="keyword">if</span> inDegree[child] == <span class="number">0</span>:</span><br><span class="line"> sources.append(child)</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> len(sortedorder) != numCourses:</span><br><span class="line"> <span class="keyword">return</span> []</span><br><span class="line"> <span class="keyword">return</span> sortedorder</span><br></pre></td></tr></table></figure> <figure class="highlight" c++=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; graph(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in(numCourses, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : prerequisites) &#123;</span><br><span class="line"> graph[a.second].push_back(a.first);</span><br><span class="line"> ++in[a.first];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line"> <span class="keyword">if</span> (in[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"> <span class="keyword">int</span> t = q.front();</span><br><span class="line"> res.push_back(t);</span><br><span class="line"> q.pop();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : graph[t]) &#123;</span><br><span class="line"> --in[a];</span><br><span class="line"> <span class="keyword">if</span> (in[a] == <span class="number">0</span>) q.push(a);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (res.size() != numCourses) res.clear();</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <h2 id="Solution-DFS"><a href="#Solution-DFS" class="headerlink" title="Solution" dfs:=""></a>Solution DFS:</h2><figure class="highlight" python=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line"> <span class="comment"># build indegree map, use result array to keep all visited nodes</span></span><br><span class="line"> <span class="comment"># visit status: -1 visiting, 0 not visit, 1 visited</span></span><br><span class="line"> <span class="comment"># if there's cycle(need to visit visiting node), then return []</span></span><br><span class="line"> res = []</span><br><span class="line"> graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line"> visited = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses)]</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> pre <span class="keyword">in</span> prerequisites:</span><br><span class="line"> graph[pre[<span class="number">1</span>]].append(pre[<span class="number">0</span>])</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(graph, visited, i, res):</span><br><span class="line"> <span class="keyword">return</span> []</span><br><span class="line"> <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, graph, visited, i, res)</span>:</span></span><br><span class="line"> <span class="keyword">if</span> visited[i] == <span class="number">1</span>:</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"> <span class="keyword">if</span> visited[i] == <span class="number">-1</span>:</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"> visited[i] = <span class="number">-1</span></span><br><span class="line"> <span class="keyword">for</span> nextCourse <span class="keyword">in</span> graph[i]:</span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> self.dfs(graph, visited, nextCourse, res):</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"> visited[i] = <span class="number">1</span></span><br><span class="line"> res.append(i)</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure> <p>time complexity: $O(VE)$<br>space complexity: $O(V+E)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
            <tag> topological sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>272. Closest Binary Search Tree Value II</title>
      <link href="/2018/09/18/272-Closest-Binary-Search-Tree-Value-II/"/>
      <url>/2018/09/18/272-Closest-Binary-Search-Tree-Value-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.</p><p>Note:</p><p>Given target value is a floating point.<br>You may assume k is always valid, that is: k ≤ total nodes.<br>You are guaranteed to have only one unique set of k values in the BST that are closest to the target.<br>Example:</p><p>Input: root = [4,2,5,1,3], target = 3.714286, and k = 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure></p><p>Output: [4,3]<br>Follow up:<br>Assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use dfs+ heap to get overall minimum distance nodes.</p><p>Notice python is min heap, every time when heap size exceed <code>k</code> , would pop out the smallest element, so we add negative to keep the closest node(it would be largest distance after negative).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestKValues</span><span class="params">(self, root: TreeNode, target: float, k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> len(heap) == k:</span><br><span class="line">                heapq.heappushpop(heap, (-abs(root.val-target), root.val))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(heap, (-abs(root.val-target), root.val))</span><br><span class="line">                </span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">            </span><br><span class="line">        heap, res = [], []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            res.append(heapq.heappop(heap)[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>My first idea is to use priority queue to solve this question. Since every time we push an element into the priority_queue, it will automatically sort the elements inside the queue in an ascending order, we can track the size of priority_queue to determine whether if we need to pop out some elements.</p><p>The reason he uses max heap is that when <code>pq.size() &gt; k</code>, we do <code>pq.pop()</code>. This pops out the largest value, which is equivalent to saying keeping the k smallest elements measured in terms of distance to the target value.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; closestKValues(TreeNode* root, <span class="keyword">double</span> target, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        helper(root, target, k, pq);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            res.push_back(pq.top().second);</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target, <span class="keyword">int</span> k, priority_queue&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;&gt;&amp; pq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        pq.push(make_pair(<span class="built_in">fabs</span>(<span class="keyword">double</span>(root-&gt;val)- target), root-&gt;val));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pq.size()&gt; k)</span><br><span class="line">            pq.pop();</span><br><span class="line">        </span><br><span class="line">        helper(root-&gt;left, target, k, pq);</span><br><span class="line">        helper(root-&gt;right, target, k, pq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: $O(nlogk)$<br>space complexity: $O(k)$<br>reference:<br><a href="http://www.cnblogs.com/grandyang/p/5247398.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5247398.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> stack </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>270. Closest Binary Search Tree Value</title>
      <link href="/2018/09/17/270-Closest-Binary-Search-Tree-Value/"/>
      <url>/2018/09/17/270-Closest-Binary-Search-Tree-Value/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</p><p>Note:</p><p>Given target value is a floating point.<br>You are guaranteed to have only one unique value in the BST that is closest to the target.<br>Example:</p><p>Input: root = [4,2,5,1,3], target = 3.714286<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure></p><p>Output: 4</p><h3 id="Solution-DFS"><a href="#Solution-DFS" class="headerlink" title="Solution DFS:"></a>Solution DFS:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> curmin= (<span class="keyword">double</span>)root-&gt;val;</span><br><span class="line">        helper(root, target, curmin);</span><br><span class="line">        <span class="keyword">return</span> curmin;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">double</span> target, <span class="keyword">double</span> &amp;curmin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">double</span>)root-&gt;val == target)&#123;</span><br><span class="line">            curmin= (<span class="keyword">double</span>)root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>((<span class="keyword">double</span>)root-&gt;val-target) &lt; <span class="built_in">abs</span>(curmin-target))</span><br><span class="line">            curmin= (<span class="keyword">double</span>)root-&gt;val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target&lt; (<span class="keyword">double</span>)root-&gt;val)</span><br><span class="line">            helper(root-&gt;left, target, curmin);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            helper(root-&gt;right, target, curmin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution-BFS"><a href="#Solution-BFS" class="headerlink" title="Solution BFS:"></a>Solution BFS:</h3><p>time complexity: $O(h)$<br>space complexity: $O(h)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>304. Range Sum Query 2D - Immutable</title>
      <link href="/2018/09/05/304-Range-Sum-Query-2D-Immutable/"/>
      <url>/2018/09/05/304-Range-Sum-Query-2D-Immutable/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p><p><img src="range_sum_query_2d.png" alt=""><br>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given matrix = [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure></p><p>Note:<br>You may assume that the matrix does not change.<br>There are many calls to sumRegion function.<br>You may assume that row1 ≤ row2 and col1 ≤ col2.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Construct a 2D array sums[row+1][col+1]</p><p>(notice: we add additional blank row sums[0][col+1]={0} and blank column sums[row+1][0]={0} to remove the edge case checking), so, we can have the following definition</p><p>sums[i+1][j+1] represents the sum of area from matrix[0][0] to matrix[i][j]</p><p>To calculate sums, the ideas as below</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br><span class="line">|               |   |         |    |   |   |           |   |         |    |   |   |          |</span><br><span class="line">|   (r1,c1)     |   |         |    |   |   |           |   |         |    |   |   |          |</span><br><span class="line">|   +------+    |   |         |    |   |   |           |   +---------+    |   +---+          |</span><br><span class="line">|   |      |    | = |         |    | - |   |           | - |      (r1,c2) | + |   (r1,c1)    |</span><br><span class="line">|   |      |    |   |         |    |   |   |           |   |              |   |              |</span><br><span class="line">|   +------+    |   +---------+    |   +---+           |   |              |   |              |</span><br><span class="line">|        (r2,c2)|   |       (r2,c2)|   |   (r2,c1)     |   |              |   |              |</span><br><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; aux;</span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty()) <span class="keyword">return</span>;</span><br><span class="line">        aux.clear();</span><br><span class="line">        aux.resize(matrix.size()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">1</span>; r&lt;= matrix.size(); r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">1</span>; c&lt;= matrix[<span class="number">0</span>].size(); c++)&#123;</span><br><span class="line">                aux[r][c]= matrix[r<span class="number">-1</span>][c<span class="number">-1</span>]+ aux[r][c<span class="number">-1</span>]+ aux[r<span class="number">-1</span>][c]- aux[r<span class="number">-1</span>][c<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aux[row2+<span class="number">1</span>][col2+<span class="number">1</span>]- aux[row1][col2+<span class="number">1</span>]- aux[row2+<span class="number">1</span>][col1]+ aux[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: preprocess: $O(mn)$, query: $O(1)$<br>space complexity: $O(mn)$<br>reference:<br><a href="https://goo.gl/t9pi4v" target="_blank" rel="noopener">https://goo.gl/t9pi4v</a><br><a href="https://goo.gl/jDo3CY" target="_blank" rel="noopener">https://goo.gl/jDo3CY</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>160. Intersection of Two Linked Lists</title>
      <link href="/2018/09/03/160-Intersection-of-Two-Linked-Lists/"/>
      <url>/2018/09/03/160-Intersection-of-Two-Linked-Lists/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br><span class="line">begin to intersect at node c1.</span><br></pre></td></tr></table></figure></p><p>Notes:</p><ul><li>If the two linked lists have no intersection at all, return null.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question to ask:</p><ol><li>If one of them is NULL? both NULL? should return NULL?</li></ol><p>If two linked list have intersetion, we can divide it into two situation.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example 1: same length of A, B</span><br><span class="line">    A1-&gt;A2-&gt;C1-&gt;C2-&gt;C3</span><br><span class="line">    B1-&gt;B2-&gt;C1-&gt;C2-&gt;C3</span><br><span class="line">    will meet in first iteration</span><br><span class="line">    </span><br><span class="line">example 2: diff length of A, B</span><br><span class="line">    A1-&gt;A2-&gt;A3-&gt;C1-&gt;C2-&gt;C3</span><br><span class="line">    B1-&gt;B2-&gt;C1-&gt;C2-&gt;C3</span><br><span class="line">    </span><br><span class="line">    let B go from A after it meets NULL,</span><br><span class="line">    A1-&gt;A2-&gt;A3-&gt;C1-&gt;C2-&gt;C3-&gt;B1-&gt;B2-&gt;C1-&gt;C2-&gt;C3</span><br><span class="line">    B1-&gt;B2-&gt;C1-&gt;C2-&gt;C3-&gt;A1-&gt;A2-&gt;A3-&gt;C1-&gt;C2-&gt;C3</span><br><span class="line">                                    |</span><br><span class="line">                                    will meet in second iteration</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *p1= headA, *p2= headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2 &amp;&amp; p1!=p2)&#123; <span class="comment">//this contains if they are intersect in first node</span></span><br><span class="line">            p1= p1-&gt;next;</span><br><span class="line">            p2= p2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p1 == p2) <span class="keyword">return</span> p1;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!p1) p1= headA;</span><br><span class="line">            <span class="keyword">if</span>(!p2) p2= headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/gu3Huw" target="_blank" rel="noopener">https://goo.gl/gu3Huw</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> linked list </tag>
            
            <tag> linkedin </tag>
            
            <tag> bloomberg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>403. Frog Jump</title>
      <link href="/2018/09/03/403-Frog-Jump/"/>
      <url>/2018/09/03/403-Frog-Jump/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p><p>Given a list of stones’ positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.</p><p>If the frog’s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.</p><p>Note:</p><p>The number of stones is ≥ 2 and is &lt; 1,100.<br>Each stone’s position will be a non-negative integer &lt; 231.<br>The first stone’s position is always 0.<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0,1,3,5,6,8,12,17]</span><br><span class="line"></span><br><span class="line">There are a total of 8 stones.</span><br><span class="line">The first stone at the 0th unit, second stone at the 1st unit,</span><br><span class="line">third stone at the 3rd unit, and so on...</span><br><span class="line">The last stone at the 17th unit.</span><br><span class="line"></span><br><span class="line">Return true. The frog can jump to the last stone by jumping </span><br><span class="line">1 unit to the 2nd stone, then 2 units to the 3rd stone, then </span><br><span class="line">2 units to the 4th stone, then 3 units to the 6th stone, </span><br><span class="line">4 units to the 7th stone, and 5 units to the 8th stone.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0,1,2,3,4,8,9,11]</span><br><span class="line"></span><br><span class="line">Return false. There is no way to jump to the last stone as </span><br><span class="line">the gap between the 5th and 6th stone is too large.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Try to go with the brute-force solution first. Then use memorization to reduce function stack as improved solution.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Design recursive function to solve this question</span></span><br><span class="line"><span class="comment">        This is brute-force, will TLE. But can be improved</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> helper(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> index, <span class="keyword">int</span> jump)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == stones.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= index+<span class="number">1</span>; i&lt; stones.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> gap= stones[i]- stones[index];</span><br><span class="line">            <span class="keyword">if</span>(gap &gt;= jump<span class="number">-1</span> &amp;&amp; gap &lt;= jump+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(helper(stones, i, gap))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> index == stones.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(3^n)$, because every step can have k-1, k, or k+1 ways to go<br>space complexity: $O(n)$, recursion of depth n</p><h3 id="Better-Solution"><a href="#Better-Solution" class="headerlink" title="Better Solution:"></a>Better Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canCross</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(stones, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> pos, <span class="keyword">int</span> jump)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key= pos | jump &lt;&lt; <span class="number">11</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        The number of stones is less than 1100 so pos will always be less than 2^11 (2048).</span></span><br><span class="line"><span class="comment">Stone positions could be theoretically up to 2^31 but k is practically not possible to be that big for the parameter as the steps must start from 0 and 1 and at the 1100th step the greatest valid k would be 1100. So combining pos and k is safe here.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp.count(key) &gt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> dp[key];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= pos+<span class="number">1</span>; i&lt; stones.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> gap= stones[i]- stones[pos];</span><br><span class="line">            <span class="keyword">if</span>(gap &lt; jump<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(gap &gt; jump+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> dp[key]= <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfs(stones, i, gap))</span><br><span class="line">                <span class="keyword">return</span> dp[key]= <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[key]= (pos == stones.size()- <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^2)$<br>space complexity: $O(n^2)$<br>reference:<br><a href="https://goo.gl/dqrsov" target="_blank" rel="noopener">https://goo.gl/dqrsov</a><br><a href="https://goo.gl/j6phxY" target="_blank" rel="noopener">https://goo.gl/j6phxY</a><br><a href="https://goo.gl/GcKWYV" target="_blank" rel="noopener">https://goo.gl/GcKWYV</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> apple </tag>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flatten a multilevel linked list</title>
      <link href="/2018/09/03/Flatten-a-multilevel-linked-list/"/>
      <url>/2018/09/03/Flatten-a-multilevel-linked-list/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a linked list where in addition to the next pointer, each node has a child pointer, which may or may not point to a separate list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in below figure.You are given the head of the first level of the list. </p><p>Flatten the list so that all the nodes appear in a single-level linked list. You need to flatten the list in way that all nodes at first level should come first, then nodes of second level, and so on.</p><p><img src="flattenList.png" alt=""></p><p>The above list should be converted to<br><code>10-&gt;5-&gt;12-&gt;7-&gt;11-&gt;4-&gt;20-&gt;13-&gt;17-&gt;6-&gt;2-&gt;16-&gt;9-&gt;8-&gt;3-&gt;19-&gt;15</code></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The problem clearly say that we need to flatten level by level. The idea of solution is, we start from first level, process all nodes one by one, if a node has a child, then we append the child at the end of list, otherwise we don’t do anything. </p><p>After the first level is processed, all next level nodes will be appended after first level. Same process is followed for the appended nodes.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1) Take &quot;cur&quot; pointer, which will point to head of the fist level of the list</span><br><span class="line">2) Take &quot;tail&quot; pointer, which will point to end of the first level of the list</span><br><span class="line">3) Repeat the below procedure while &quot;curr&quot; is not NULL.</span><br><span class="line">    I) if current node has a child then</span><br><span class="line">a) append this new child list to the &quot;tail&quot;</span><br><span class="line">tail-&gt;next = cur-&gt;child</span><br><span class="line">b) find the last node of new child list and update &quot;tail&quot;</span><br><span class="line">tmp = cur-&gt;child;</span><br><span class="line">while (tmp-&gt;next != NULL)</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">tail = tmp;</span><br><span class="line">    II) move to the next node. i.e. cur = cur-&gt;next </span><br><span class="line">Following is the implementation of the above algorithm.</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* The main function that flattens a multilevel linked list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flattenList</span><span class="params">(struct Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find tail node of first level linked list */</span></span><br><span class="line">    Node *tail = head;</span><br><span class="line">    <span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// One by one traverse through all nodes of first level</span></span><br><span class="line">    <span class="comment">// linked list till we reach the tail node</span></span><br><span class="line">    Node *cur = head;</span><br><span class="line">    Node *tmp;</span><br><span class="line">    <span class="keyword">while</span> (cur != tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If current node has a child</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;child)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// then append the child at the end of current list</span></span><br><span class="line">            tail-&gt;next = cur-&gt;child;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// and update the tail to new last node</span></span><br><span class="line">            tmp = cur-&gt;child;</span><br><span class="line">            <span class="keyword">while</span> (tmp-&gt;next)</span><br><span class="line">                tmp = tmp-&gt;next;</span><br><span class="line">            tail = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Change current node</span></span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/fFhM5L" target="_blank" rel="noopener">https://goo.gl/fFhM5L</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>157. Read N Characters Given Read4</title>
      <link href="/2018/09/03/157-Read-N-Characters-Given-Read4/"/>
      <url>/2018/09/03/157-Read-N-Characters-Given-Read4/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>The API: int read4(char *buf) reads 4 characters at a time from a file.</p><p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p><p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: buf = &quot;abc&quot;, n = 4</span><br><span class="line">Output: &quot;abc&quot;</span><br><span class="line">Explanation: The actual number of characters read is 3, which is &quot;abc&quot;.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: buf = &quot;abcde&quot;, n = 5 </span><br><span class="line">Output: &quot;abcde&quot;</span><br></pre></td></tr></table></figure></p><p>Note:<br>The read function will only be called once for each test case.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question to ask:</p><ol><li>read4 can be use multiple times?</li><li>output type</li></ol><p>One thing to notice is that the <code>read</code> will only be called once. The <code>read4</code> will return how many characters it read from the input <code>char *buf</code>. So we can use a variable to cumulate the sum of characters that read by <code>read4</code>. Once the return value of <code>read4</code> is smaller than 4, that means we reached the last position. </p><p>Make sure to move the position in <code>char *buf</code> for <code>read4</code> to read next position.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the read4 API.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read4</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Maximum number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> complete= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = min(read4(buf), n);</span><br><span class="line">            complete+= tmp;</span><br><span class="line">            buf+= tmp; <span class="comment">//move the char pointer to next position</span></span><br><span class="line">            <span class="keyword">if</span>(tmp&lt; <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            n-= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> complete;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>129. Sum Root to Leaf Numbers</title>
      <link href="/2018/09/02/129-Sum-Root-to-Leaf-Numbers/"/>
      <url>/2018/09/02/129-Sum-Root-to-Leaf-Numbers/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p><p>Find the total sum of all root-to-leaf numbers.</p><p>Note: A leaf is a node with no children.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum = 12 + 13 = 25.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>A simple DFS solution, use an integer to store the current sum. For every node, update the val as val*10 plus node’s data.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right &amp;&amp; !root-&gt;left)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span> * x + root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">            val += helper(root-&gt;left, <span class="number">10</span> * x + root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">            val += helper(root-&gt;right, <span class="number">10</span> * x + root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: $O(n)$<br>space complexity: $O(logn)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>30. Substring with Concatenation of All Words</title>
      <link href="/2018/09/01/30-Substring-with-Concatenation-of-All-Words/"/>
      <url>/2018/09/01/30-Substring-with-Concatenation-of-All-Words/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">Output: [0,9]</span><br><span class="line">Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.</span><br><span class="line">The output order does not matter, returning [9,0] is fine too.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;wordgoodstudentgoodword&quot;,</span><br><span class="line">  words = [&quot;word&quot;,&quot;student&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two hash table. </p><ol><li>First hash table, <code>map</code>, stores every words.</li><li>Second hash table, <code>seen</code>, determine if a substring is in the <code>map</code> or not. If the substring is not in the map, it means the substring is not a word in given words. In addition, it can only appear once in current search, so if the count in <code>seen</code> is greater than in the <code>map</code>, we should break the loop.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(s.empty() || words.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word: words)</span><br><span class="line">            <span class="built_in">map</span>[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n= s.length(), num= words.size(), len= words[<span class="number">0</span>].length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n- num*len+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; seen;</span><br><span class="line">            <span class="keyword">int</span> j= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j&lt; num; j++)&#123;</span><br><span class="line">                <span class="built_in">string</span> word= s.substr(i+j*len, len);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.find(word) != <span class="built_in">map</span>.end())&#123;</span><br><span class="line">                    seen[word]++;</span><br><span class="line">                    <span class="keyword">if</span>(seen[word]&gt; <span class="built_in">map</span>[word])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == num) res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n*num)$<br>space complexity: $O(words.size())$<br>reference:<br><a href="https://goo.gl/wy6wAq" target="_blank" rel="noopener">https://goo.gl/wy6wAq</a><br><a href="https://goo.gl/MAkUfJ" target="_blank" rel="noopener">https://goo.gl/MAkUfJ</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> hash table </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>23. Merge k Sorted Lists</title>
      <link href="/2018/09/01/23-Merge-k-Sorted-Lists/"/>
      <url>/2018/09/01/23-Merge-k-Sorted-Lists/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure></p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>Use the concept of merge two list. Divide the <code>n</code> lists into <code>n/2</code> parts and merge every 2 lists until only one list left.<br>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">totally 10 lists</span><br><span class="line">  1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">merge i and i+k together, which k= (n+1)/2</span><br><span class="line"></span><br><span class="line">merge(1,6) merge(2,7), merge(3,8), merge(4,9), merge(5,10)</span><br><span class="line"></span><br><span class="line">merge(1,4), merge(2,5), 3</span><br><span class="line"></span><br><span class="line">merge(1,3), 2</span><br><span class="line"></span><br><span class="line">merge(1,2)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># merge sort, divide until it's two list then merge bottom up</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> len(lists) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">        mid = len(lists) // <span class="number">2</span></span><br><span class="line">        l, r = self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:])</span><br><span class="line">        <span class="keyword">return</span> self.merge(l, r)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> l <span class="keyword">and</span> r:</span><br><span class="line">            <span class="keyword">if</span> l.val &lt; r.val:</span><br><span class="line">                p.next = l</span><br><span class="line">                l = l.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = r</span><br><span class="line">                r = r.next</span><br><span class="line">            p = p.next</span><br><span class="line">        p.next = l <span class="keyword">or</span> r</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//divide lists into half, merge every two list together until only one left</span></span><br><span class="line">        <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n= lists.size();</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k= (n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n/<span class="number">2</span>; i++)&#123;</span><br><span class="line">                lists[i]= mergeList(lists[i], lists[i+k]);</span><br><span class="line">            &#125;</span><br><span class="line">            n= k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* head= <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur= head;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next= l1;</span><br><span class="line">                l1= l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next= l2;</span><br><span class="line">                l2= l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur= cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">            cur-&gt;next= l1;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">            cur-&gt;next= l2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nklog(k))$, n: average length of lists, there are k lists.<br>firstly, merge every two list need nk/2; in the next round, the length of list becomes 2n, the number of lists becomes k/2, so the complexity is still nk/2. Keep such rounds until k == 1, that would be log(k) rounds. so the total complexity is $O(nklog(k))$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/wUqWfW" target="_blank" rel="noopener">https://goo.gl/wUqWfW</a></p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h3><p>Use a priority_queue to implement. Put every head of the list into the priority_queue, it will sort the value automatically. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        ListNode.__eq__ = <span class="keyword">lambda</span> self, other: self.val == other.val</span><br><span class="line">        ListNode.__lt__ = <span class="keyword">lambda</span> self, other: self.val &lt; other.val</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> l:</span><br><span class="line">                heappush(heap, l)</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            node = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> node.next:</span><br><span class="line">                heapq.heappush(heap, node.next)</span><br><span class="line">            p.next = node</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, comp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; lists.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i]) q.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* head= <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur= head, *tmp= <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            tmp= q.top(); <span class="comment">//it's the smallest element right now</span></span><br><span class="line">            q.pop();</span><br><span class="line">            cur-&gt;next= tmp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;next) q.push(tmp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogk)$, n: average length of lists, there are k lists. The height of the priority_queue would be $logk$.<br>space complexity: $O(logk)$<br>reference:<br><a href="https://goo.gl/nM8sHt" target="_blank" rel="noopener">https://goo.gl/nM8sHt</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> linked list </tag>
            
            <tag> heap </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>399. Evaluate Division</title>
      <link href="/2018/09/01/399-Evaluate-Division/"/>
      <url>/2018/09/01/399-Evaluate-Division/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given a / b = 2.0, b / c = 3.0. </span><br><span class="line">queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . </span><br><span class="line">return [6.0, 0.5, -1.0, 1.0, -1.0 ].</span><br></pre></td></tr></table></figure></p><p>The input is: vector&lt;pair&lt;string, string&gt;&gt; equations, vector<double>&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector<double>.</double></double></p><p>According to the example above:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],</span><br><span class="line">values = [2.0, 3.0],</span><br><span class="line">queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].</span><br></pre></td></tr></table></figure></p><p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Think every character as a node, the equation result would be the weight between them. In addition, if we have a equation from a to b, then we can also get b to a.<br>ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if we know</span><br><span class="line"> a-&gt;b, weight= 2.0</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"> b-&gt;a, would be (1/2.0)= 0.5</span><br><span class="line"> a-&gt;a, would be 1</span><br><span class="line"> b-&gt;b, 1</span><br></pre></td></tr></table></figure></p><p>After we generate the graph, we can use BFS to scan the graph. Use an unordered_set to store every node that already visited.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; calcEquation(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; g; <span class="comment">//vertex, &lt;vertex, weight&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; equations.size(); i++)&#123;</span><br><span class="line">            </span><br><span class="line">            g[equations[i].first].emplace(equations[i].second, values[i]); <span class="comment">//from A-&gt;B, weight value[i]</span></span><br><span class="line">            g[equations[i].first].emplace(equations[i].first, <span class="number">1.0</span>); <span class="comment">//from A-&gt;A, weight 1</span></span><br><span class="line">            g[equations[i].second].emplace(equations[i].first, <span class="number">1.0</span>/values[i]); <span class="comment">//from B-&gt;A, weight (1.0/value[i])</span></span><br><span class="line">            g[equations[i].second].emplace(equations[i].second, <span class="number">1.0</span>); <span class="comment">//from B-&gt;B, weight 1</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //use insert will be generate extra template element</span></span><br><span class="line"><span class="comment">            g[equations[i].first].insert(make_pair(equations[i].second, values[i])); //from A-&gt;B, weight value[i]</span></span><br><span class="line"><span class="comment">            g[equations[i].first].insert(make_pair(equations[i].first, 1.0)); //from A-&gt;A, weight 1</span></span><br><span class="line"><span class="comment">            g[equations[i].second].insert(make_pair(equations[i].first, 1.0/values[i])); //from B-&gt;A, weight (1.0/value[i])</span></span><br><span class="line"><span class="comment">            g[equations[i].second].insert(make_pair(equations[i].second, 1.0)); //from B-&gt;B, weight 1</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> query: queries)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!g.count(query.first) || !g.count(query.second)) res.push_back(<span class="number">-1.0</span>); <span class="comment">//can not find one of the vertex, return -1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; q;</span><br><span class="line">                <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; used&#123;query.first&#125;;</span><br><span class="line">                <span class="keyword">bool</span> find= <span class="literal">false</span>;</span><br><span class="line">                q.push(&#123;query.first, <span class="number">1.0</span>&#125;);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(!q.empty() &amp;&amp; !find)&#123;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; next;</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty() &amp;&amp; !find)&#123;</span><br><span class="line">                        pair&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; t= q.front(); q.pop();</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;"tmp: "&lt;&lt;t.first&lt;&lt;": "&lt;&lt;t.second&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(t.first == query.second)&#123;</span><br><span class="line">                            find = <span class="literal">true</span>;</span><br><span class="line">                            <span class="comment">//cout&lt;&lt;" res: "&lt;&lt; t.first&lt;&lt; ": "&lt;&lt;t.second&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">                            res.push_back(t.second);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor: g[t.first])&#123; <span class="comment">//call by value, so does not affect original neighbor list</span></span><br><span class="line">                            <span class="keyword">if</span>(!used.count(neighbor.first))&#123; </span><br><span class="line">                                <span class="comment">//cout&lt;&lt;t.first&lt;&lt; "-&gt;" &lt;&lt; neighbor.first&lt;&lt; ": "&lt;&lt;neighbor.second&lt;&lt; endl;</span></span><br><span class="line">                                neighbor.second *= t.second; </span><br><span class="line">                                <span class="comment">//cout&lt;&lt;" "&lt;&lt;t.first&lt;&lt; "-&gt;" &lt;&lt; neighbor.first&lt;&lt; ": "&lt;&lt;neighbor.second&lt;&lt; endl;</span></span><br><span class="line">                                next.push(neighbor);</span><br><span class="line">                                used.insert(neighbor.first);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q= next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!find) res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(N+E)$, N: number of variables, E: number of equations.<br>building the graph takes O(E), each query takes O(N)<br>space complexity: $O(E)$<br>reference:<br><a href="https://goo.gl/XWzasp" target="_blank" rel="noopener">https://goo.gl/XWzasp</a><br><a href="https://goo.gl/C4au3C" target="_blank" rel="noopener">https://goo.gl/C4au3C</a><br><a href="https://goo.gl/Hcce9D" target="_blank" rel="noopener">https://goo.gl/Hcce9D</a></p><h3 id="Solution-2-DFS"><a href="#Solution-2-DFS" class="headerlink" title="Solution 2 DFS:"></a>Solution 2 DFS:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">float</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; calcEquation(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; equations.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[equations[i].first][equations[i].second]= values[i];</span><br><span class="line">            <span class="built_in">map</span>[equations[i].second][equations[i].first]= <span class="number">1.0</span>/values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> query: queries)&#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">            <span class="keyword">double</span> tmp= dfs(query.first, query.second, visited);</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> up, <span class="built_in">string</span> down, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[up].count(down)) <span class="keyword">return</span> <span class="built_in">map</span>[up][down];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a: <span class="built_in">map</span>[up])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.count(a.first)) <span class="keyword">continue</span>;</span><br><span class="line">            visited.insert(a.first);</span><br><span class="line">            <span class="keyword">double</span> tmp= dfs(a.first, down, visited);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0.0</span>) <span class="keyword">return</span> tmp* a.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>491. Increasing Subsequences</title>
      <link href="/2018/08/31/491-Increasing-Subsequences/"/>
      <url>/2018/08/31/491-Increasing-Subsequences/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 6, 7, 7]</span><br><span class="line">Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure></p><p>Note:<br>The length of the given array will not exceed 15.<br>The range of integer in the given array is [-100,100].<br>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We can use dfs template to solve this question.<br>The tricky part is to use an unordered_set to store the numbers that already in current layer to avoid duplicate elements.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSubsequences(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(res, nums, tmp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size() &gt;= <span class="number">2</span>) res.push_back(tmp);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; dict;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= index; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tmp.empty() &amp;&amp; tmp.back()&gt; nums[i] || dict.count(nums[i])) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            dict.insert(nums[i]);</span><br><span class="line">            dfs(res, nums, tmp, i+<span class="number">1</span>);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(2^n))$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/wp2sbS" target="_blank" rel="noopener">https://goo.gl/wp2sbS</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>636. Exclusive Time of Functions</title>
      <link href="/2018/08/31/636-Exclusive-Time-of-Functions/"/>
      <url>/2018/08/31/636-Exclusive-Time-of-Functions/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.</p><p>Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.</p><p>A log is a string has this format : function_id:start_or_end:timestamp. For example, “0:start:0” means function 0 starts from the very beginning of time 0. “0:end:0” means function 0 ends to the very end of time 0.</p><p>Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function’s exclusive time. You should return the exclusive time of each function sorted by their function id.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">n = 2</span><br><span class="line">logs = </span><br><span class="line">[&quot;0:start:0&quot;,</span><br><span class="line"> &quot;1:start:2&quot;,</span><br><span class="line"> &quot;1:end:5&quot;,</span><br><span class="line"> &quot;0:end:6&quot;]</span><br><span class="line">Output:[3, 4]</span><br><span class="line">Explanation:</span><br><span class="line">Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. </span><br><span class="line">Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.</span><br><span class="line">Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. </span><br><span class="line">So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.</span><br></pre></td></tr></table></figure></p><p>Note:</p><ol><li>Input logs will be sorted by timestamp, NOT log id.</li><li>Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.</li><li>Two functions won’t start or end at the same time.</li><li>Functions could be called recursively, and will always end.</li><li>1 &lt;= n &lt;= 100</li></ol><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The exclusive time of function means how many times that CPU spent on this function.<br>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[&quot;A:start:0&quot;,&quot;A:start:2&quot;,&quot;A:end:5&quot;,&quot;B:start:7&quot;,&quot;B:end:7&quot;,&quot;A:end:8&quot;]</span><br><span class="line"></span><br><span class="line">   time 0</span><br><span class="line">        |---|---|---|---|---|---|---|---|---|---|---|---|</span><br><span class="line">process A------&gt;             -------   &gt;A</span><br><span class="line">                A----------&gt;A           </span><br><span class="line">                                    B--&gt;B</span><br><span class="line">       start   start       end   start  end</span><br><span class="line"></span><br><span class="line">The answer would be [8,1], A has exclusive 8 slots, B has exclusive 1 slot.</span><br></pre></td></tr></table></figure></p><p>With this example, we can know that if a function hasn’t end, we need to keep it until it ends. So we can use a <code>stack</code> to store the functions. The stack only needs to store the index of each function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; exclusiveTime(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; logs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> preTime= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="built_in">log</span>: logs)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//extract information from log, which function, start or end, happened time</span></span><br><span class="line">            <span class="keyword">int</span> found1= <span class="built_in">log</span>.find(<span class="string">":"</span>); <span class="comment">//get index of function</span></span><br><span class="line">            <span class="keyword">int</span> found2= <span class="built_in">log</span>.find_last_of(<span class="string">":"</span>); <span class="comment">//time frame</span></span><br><span class="line">            <span class="keyword">int</span> idx= stoi(<span class="built_in">log</span>.substr(<span class="number">0</span>, found1));</span><br><span class="line">            <span class="built_in">string</span> type= <span class="built_in">log</span>.substr(found1+<span class="number">1</span>, found2-found1<span class="number">-1</span>); <span class="comment">//"start" or "end"</span></span><br><span class="line">            <span class="keyword">int</span> time = stoi(<span class="built_in">log</span>.substr(found2+<span class="number">1</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!stk.empty())&#123;</span><br><span class="line">                res[stk.top()]+= time-preTime;</span><br><span class="line">            &#125;</span><br><span class="line">            preTime = time;</span><br><span class="line">            <span class="keyword">if</span>(type == <span class="string">"start"</span>) stk.push(idx);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp= stk.top(); stk.pop();</span><br><span class="line">                ++res[tmp];</span><br><span class="line">                ++preTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/63GMUn" target="_blank" rel="noopener">https://goo.gl/63GMUn</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> uber </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>429. N-ary Tree Level Order Traversal</title>
      <link href="/2018/08/31/429-N-ary-Tree-Level-Order-Traversal/"/>
      <url>/2018/08/31/429-N-ary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an n-ary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example, given a 3-ary tree:</p><p><img src="NaryTreeExample.png" alt=""></p><p>We should return its level order traversal:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">     [3,2,4],</span><br><span class="line">     [5,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>The depth of the tree is at most 1000.<br>The total number of nodes is at most 5000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val = NULL;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="comment">//BFS traversal</span></span><br><span class="line">            <span class="keyword">int</span> size= q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; size; i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp= q.front(); q.pop();</span><br><span class="line">                level.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> n: tmp-&gt;children)</span><br><span class="line">                    q.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>251. Flatten 2D Vector</title>
      <link href="/2018/08/30/251-Flatten-2D-Vector/"/>
      <url>/2018/08/30/251-Flatten-2D-Vector/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Implement an iterator to flatten a 2d vector.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 2d vector =</span><br><span class="line">[</span><br><span class="line">  [1,2],</span><br><span class="line">  [3],</span><br><span class="line">  [4,5,6]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,5,6]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, </span><br><span class="line">             the order of elements returned by next should be: [1,2,3,4,5,6].</span><br></pre></td></tr></table></figure></p><p>Follow up:<br>As an added challenge, try to code it using only iterators in C++ or iterators in Java.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two iterator to denote the begin and end of the row of 2D vector. Another integer variable for the current position in the vector column.</p><p>Another thing to notice is that we need to use (*cur) to get the value in the vector.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         pos</span><br><span class="line">       [ |</span><br><span class="line">cur -&gt;  [1,2],</span><br><span class="line">        [3],</span><br><span class="line">        [4,5,6]</span><br><span class="line">end -&gt; ]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector2D(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; vec2d) &#123;</span><br><span class="line">        cur= vec2d.begin();</span><br><span class="line">        end= vec2d.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*cur)[pos++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != end &amp;&amp; pos == (*cur).size())&#123;</span><br><span class="line">            cur++;</span><br><span class="line">            pos= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur != end; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator cur, end;</span><br><span class="line">    <span class="keyword">int</span> pos= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Vector2D object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Vector2D i(vec2d);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/HAhXuq" target="_blank" rel="noopener">https://goo.gl/HAhXuq</a><br><a href="https://goo.gl/cJtZ2Y" target="_blank" rel="noopener">https://goo.gl/cJtZ2Y</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
            <tag> airbnb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>281. Zigzag Iterator</title>
      <link href="/2018/08/30/281-Zigzag-Iterator/"/>
      <url>/2018/08/30/281-Zigzag-Iterator/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two 1d vectors, implement an iterator to return their elements alternately.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">v1 = [1,2]</span><br><span class="line">v2 = [3,4,5,6] </span><br><span class="line"></span><br><span class="line">Output: [1,3,2,4,5,6]</span><br></pre></td></tr></table></figure></p><p>Explanation: By calling next repeatedly until hasNext returns false,<br>             the order of elements returned by next should be: [1,3,2,4,5,6].<br>Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?</p><p>Clarification for the follow up question:<br>The “Zigzag” order is not clearly defined and is ambiguous for k &gt; 2 cases. If “Zigzag” does not look right to you, replace “Zigzag” with “Cyclic”. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line">[4,5,6,7]</span><br><span class="line">[8,9]</span><br><span class="line"></span><br><span class="line">Output: [1,4,8,2,5,9,3,6,7].</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea of this problem is to use a queue to store the current iterator of each vector. At start, we need to store the <code>begin</code> and <code>end</code> iterator of each vector. Every time we need to output a value, we take the <code>pair&lt;begin, end&gt;</code> from the queue. After we get the <code>pair</code>, we can use the <code>begin</code> iterator to find next element in that vector.</p><ol><li>Use a queue to store iterators of each vector, push pairs of iterators with the zigzag order.</li><li>Take the front element of the queue, pop it out. If we add 1 to the begin iterator, then we can get to the next element in the vector. However, if the begin iterator is equal to the end iterator, that means we reach to the end. And we don’t need to push the pair in to queue again.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZigzagIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZigzagIterator(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v1.empty()) q.push(make_pair(v1.begin(), v1.end()));</span><br><span class="line">        <span class="keyword">if</span>(!v2.empty()) q.push(make_pair(v2.begin(), v2.end()));</span><br><span class="line">        <span class="comment">//if there're multiple vectors, then push it into the queue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it= q.front().first, end= q.front().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(it+<span class="number">1</span> != end) q.push(make_pair(it+<span class="number">1</span>, end));</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !q.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt;&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ZigzagIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ZigzagIterator i(v1, v2);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>825. Friends Of Appropriate Ages</title>
      <link href="/2018/08/29/825-Friends-Of-Appropriate-Ages/"/>
      <url>/2018/08/29/825-Friends-Of-Appropriate-Ages/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. </p><p>Person A will NOT friend request person B (B != A) if any of the following conditions are true:</p><p>age[B] &lt;= 0.5 * age[A] + 7<br>age[B] &gt; age[A]<br>age[B] &gt; 100 &amp;&amp; age[A] &lt; 100<br>Otherwise, A will friend request B.</p><p>Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.</p><p>How many total friend requests are made?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [16,16]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 2 people friend request each other.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [16,17,18]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [20,30,100,110,120]</span><br><span class="line">Output: </span><br><span class="line">Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.</span><br></pre></td></tr></table></figure></p><p>Notes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= ages.length &lt;= 20000.</span><br><span class="line">1 &lt;= ages[i] &lt;= 120.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a map to gather all the same ages together, then use a function to check whether if the input ages will send request.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numFriendRequests</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a: ages)</span><br><span class="line">            count[a]++; <span class="comment">//calculate the same ages together</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: count)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> y: count)&#123;</span><br><span class="line">                <span class="keyword">if</span>(request(x.first, y.first))</span><br><span class="line">                    res += x.second * (y.second - (x.first == y.first ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">request</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(b &lt;= <span class="number">0.5</span> * a + <span class="number">7</span> || b &gt; a || (b &gt; <span class="number">100</span> &amp;&amp; a &lt; <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^2)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/XQgtCY" target="_blank" rel="noopener">https://goo.gl/XQgtCY</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>311. Sparse Matrix Multiplication</title>
      <link href="/2018/08/29/311-Sparse-Matrix-Multiplication/"/>
      <url>/2018/08/29/311-Sparse-Matrix-Multiplication/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two sparse matrices A and B, return the result of AB.</p><p>You may assume that A’s column number is equal to B’s row number.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">A = [</span><br><span class="line">  [ 1, 0, 0],</span><br><span class="line">  [-1, 0, 3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">B = [</span><br><span class="line">  [ 7, 0, 0 ],</span><br><span class="line">  [ 0, 0, 0 ],</span><br><span class="line">  [ 0, 0, 1 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |</span><br><span class="line">AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |</span><br><span class="line">                  | 0 0 1 |</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Matrix multiply: </p><ul><li>A[i][k]* B[k][j]= C[i][j]</li><li>C[i][j]= A[i][0]<em>B[0][j]+ A[i][1]</em>B[1][j]+ … +A[i][k]*B[k][j]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; multiply(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(A.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(B[<span class="number">0</span>].size(), <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; A.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k= <span class="number">0</span>; k&lt; A[<span class="number">0</span>].size(); k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][k] != <span class="number">0</span>)&#123; <span class="comment">//it's sparse matrix, this can reduce redundant calculation</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; B[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(B[k][j] != <span class="number">0</span>) res[i][j]+= A[i][k]* B[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(AB)$, $A: A.size()*A[0].size(), B: B.size()*B[0].size()$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/yDQCx2" target="_blank" rel="noopener">https://goo.gl/yDQCx2</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>819. Most Common Word</title>
      <link href="/2018/08/29/819-Most-Common-Word/"/>
      <url>/2018/08/29/819-Most-Common-Word/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn’t banned, and that the answer is unique.</p><p>Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: </span><br><span class="line">paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;</span><br><span class="line">banned = [&quot;hit&quot;]</span><br><span class="line">Output: &quot;ball&quot;</span><br><span class="line">Explanation: </span><br><span class="line">&quot;hit&quot; occurs 3 times, but it is a banned word.</span><br><span class="line">&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. </span><br><span class="line">Note that words in the paragraph are not case sensitive,</span><br><span class="line">that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;), </span><br><span class="line">and that &quot;hit&quot; isn&apos;t the answer even though it occurs more because it is banned.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>1 &lt;= paragraph.length &lt;= 1000.<br>1 &lt;= banned.length &lt;= 100.<br>1 &lt;= banned[i].length &lt;= 10.<br>The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.)<br>paragraph only consists of letters, spaces, or the punctuation symbols !?’,;.<br>Different words in paragraph are always separated by a space.<br>There are no hyphens or hyphenated words.<br>Words only consist of letters, never apostrophes or other punctuation symbols.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a unordered_set to store the banned strings, so that we can have <code>O(1)</code> on searching.<br>Since the <code>paragraph</code> would contain upper case letter and symbols, we need to</p><ul><li>convert every character to lower case</li><li>remove every symbols and use <code>&#39; &#39;</code> instead.</li></ul><p>For string handling, we can use <code>stringstream</code>, because it can spilt words by whitespaces.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mostCommonWord</span><span class="params">(<span class="built_in">string</span> paragraph, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; banned)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(banned.begin(), banned.end());</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c: paragraph)</span><br><span class="line">            c= <span class="built_in">isalpha</span>(c)? <span class="built_in">tolower</span>(c): <span class="string">' '</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(paragraph)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; res&#123;<span class="string">""</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(is&gt;&gt; tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dict.find(tmp) == dict.end() &amp;&amp; ++count[tmp] &gt; res.second)&#123;</span><br><span class="line">                res= make_pair(tmp, count[tmp]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/tzoaYC" target="_blank" rel="noopener">https://goo.gl/tzoaYC</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> string </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4. Median of Two Sorted Arrays</title>
      <link href="/2018/08/28/4-Median-of-Two-Sorted-Arrays/"/>
      <url>/2018/08/28/4-Median-of-Two-Sorted-Arrays/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p>Example 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>The median is 2.0<br>Example 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The median is used for dividing a set into <code>two equal length</code> subsets, that one subset is always greater than the other</p><p>If the total number of elements are odd, then what we have to do is to find the <code>K</code>th number of element.<br>If the total number of elements are even, then what we have to do is to find the <code>K</code>th and <code>K+1</code> number of element, then divided it to half to get the median.<br>For example:<br><code>3 4 5 6 7 8</code>, the median is <code>5.5</code><br><code>3 4 5 6 7 8 9</code>, the median is <code>6</code></p><ol><li>find the total length</li><li></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = nums1.size()+ nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(total %<span class="number">2</span> == <span class="number">1</span>) <span class="comment">//the array have odd number of elements, can find a middle one</span></span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total/<span class="number">2</span> +<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//can not find a middle one, so need to find two numbers and divide by 2</span></span><br><span class="line">            <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total/<span class="number">2</span>)+ findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total/<span class="number">2</span> +<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size()- i &gt; nums2.size()- j) <span class="keyword">return</span> findKth(nums2, j, nums1, i, k);</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() == i) <span class="keyword">return</span> nums2[j+k<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[i], nums2[j]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pa= min(i+k/<span class="number">2</span>, <span class="keyword">int</span>(nums1.size()) );</span><br><span class="line">        <span class="keyword">int</span> pb= j+k-pa+i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums1[pa<span class="number">-1</span>] &lt; nums2[pb<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, pa, nums2, j, k-pa+i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[pa<span class="number">-1</span>]&gt; nums2[pb<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i, nums2, pb, k-pb+j);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> nums1[pa<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
            <tag> divide and conquer </tag>
            
            <tag> adobe facebook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>721. Accounts Merge</title>
      <link href="/2018/08/27/721-Accounts-Merge/"/>
      <url>/2018/08/27/721-Accounts-Merge/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.</p><p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p><p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">Output: [[&quot;John&quot;, &apos;john00@mail.com&apos;, &apos;john_newyork@mail.com&apos;, &apos;johnsmith@mail.com&apos;],  [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">Explanation: </span><br><span class="line">The first and third John&apos;s are the same person as they have the common email &quot;johnsmith@mail.com&quot;.</span><br><span class="line">The second John and Mary are different people as none of their email addresses are used by other accounts.</span><br><span class="line">We could return these lists in any order, for example the answer [[&apos;Mary&apos;, &apos;mary@mail.com&apos;], [&apos;John&apos;, &apos;johnnybravo@mail.com&apos;], </span><br><span class="line">[&apos;John&apos;, &apos;john00@mail.com&apos;, &apos;john_newyork@mail.com&apos;, &apos;johnsmith@mail.com&apos;]] would still be accepted.</span><br></pre></td></tr></table></figure></p><p>Note:<br>The length of accounts will be in the range [1, 1000].<br>The length of accounts[i] will be in the range [1, 10].<br>The length of accounts[i][j] will be in the range [1, 30].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Union find: make every node it’s root. traverse all connection and make it in a union.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        root = defaultdict() <span class="comment"># union find nodes, default each email would be its root</span></span><br><span class="line">        owner = defaultdict() <span class="comment"># this email belongs to who</span></span><br><span class="line">        <span class="keyword">for</span> name, *emails <span class="keyword">in</span> accounts:</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> emails:</span><br><span class="line">                root[email] = email</span><br><span class="line">                owner[email] = name</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(s)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root[s] == s:</span><br><span class="line">                <span class="keyword">return</span> s</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> find(root[s])</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line">            p = find(account[<span class="number">1</span>]) <span class="comment"># first email of the account</span></span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> account[<span class="number">2</span>:]:</span><br><span class="line">                root[find(email)] = p <span class="comment"># make first email to be every rest email's root </span></span><br><span class="line">        <span class="comment"># merge accounts together</span></span><br><span class="line">        merge = defaultdict(set)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> accounts: </span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> account[<span class="number">1</span>:]:</span><br><span class="line">                merge[find(email)].add(email)</span><br><span class="line">                </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> merge.keys():</span><br><span class="line">            res.append([owner[k]]+ sorted(list(merge[k])))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; root; <span class="comment">//"john00@mail.com", "johnsmith@mail.com", </span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; owner; <span class="comment">//email, Name. ex: "johnsmith@mail.com", "John"</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> account: accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; account.size(); i++)&#123;</span><br><span class="line">                root[account[i]]= account[i];  <span class="comment">//let every email in different group "johnsmith@mail.com", "johnsmith@mail.com".</span></span><br><span class="line">                owner[account[i]]= account[<span class="number">0</span>]; <span class="comment">//every account[i] owners is the first one</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> account: accounts)&#123;</span><br><span class="line">            <span class="built_in">string</span> p= find(account[<span class="number">1</span>], root);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">2</span>; i&lt; account.size(); i++)&#123;</span><br><span class="line">                root[find(account[i], root)]= p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> account: accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; account.size(); i++)&#123;</span><br><span class="line">                m[find(account[i], root)].insert(account[i]); <span class="comment">//put into same set</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : m) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v(a.second.begin(), a.second.end());</span><br><span class="line">            v.insert(v.begin(), owner[a.first]);</span><br><span class="line">            res.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&amp; root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// to check if s is in the same root group </span></span><br><span class="line">        <span class="keyword">return</span> root[s]== s? s: find(root[s], root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="IMG_5723.jpg" alt=""></p><h3 id="Solution-BFS"><a href="#Solution-BFS" class="headerlink" title="Solution BFS:"></a>Solution BFS:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) &#123;</span><br><span class="line">        <span class="comment">//use BFS to solve</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n= accounts.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span>; j&lt; accounts[i].size(); j++)&#123;</span><br><span class="line">                m[accounts[i][j]].push_back(i); <span class="comment">// store where every email belong to user i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) </span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//already visited</span></span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q&#123;&#123;i&#125;&#125;;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                <span class="keyword">auto</span> t= q.front(); q.pop();</span><br><span class="line">                visited[t]= <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; emails(accounts[t].begin()+<span class="number">1</span>, accounts[t].end());</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> email: emails)&#123;</span><br><span class="line">                    s.insert(email);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> user: m[email])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(visited[user])</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        q.push(user);</span><br><span class="line">                        visited[user]= <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; out(s.begin(), s.end());</span><br><span class="line">            out.insert(out.begin(), accounts[i][<span class="number">0</span>]);</span><br><span class="line">            res.push_back(out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Python-DFS"><a href="#Python-DFS" class="headerlink" title="Python DFS"></a>Python DFS</h2><p>We give each account an ID, based on the index of it within the list of accounts.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], # Account 0</span><br><span class="line">[&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], # Account 1</span><br><span class="line">[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;],  # Account 2</span><br><span class="line">[&quot;Mary&quot;, &quot;mary@mail.com&quot;] # Account 3</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Next, build an <code>emails_accounts_map</code> that maps an email to a list of accounts, which can be used to track which email is linked to which account. This is essentially our graph.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># emails_accounts_map of email to account ID</span><br><span class="line">&#123;</span><br><span class="line">  &quot;johnsmith@mail.com&quot;: [0, 2],</span><br><span class="line">  &quot;john00@mail.com&quot;: [0],</span><br><span class="line">  &quot;johnnybravo@mail.com&quot;: [1],</span><br><span class="line">  &quot;john_newyork@mail.com&quot;: [2],</span><br><span class="line">  &quot;mary@mail.com&quot;: [3]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next we do a DFS on each account in accounts list and look up <code>emails_accounts_map</code> to tell us which accounts are linked to that particular account via common emails. This will make sure we visit each account only once. This is a recursive process and we should collect all the emails that we encounter along the way.</p><p>Lastly, sort the collected emails and add it to final results, <code>res</code> along with the name.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accountsMerge</span><span class="params">(self, accounts: List[List[str]])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        visited_accounts = [<span class="keyword">False</span>] * len(accounts)</span><br><span class="line">        emails_accounts_map = defaultdict(list)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># Build up the graph.</span></span><br><span class="line">        <span class="keyword">for</span> i, account <span class="keyword">in</span> enumerate(accounts):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(account)):</span><br><span class="line">                email = account[j]</span><br><span class="line">                emails_accounts_map[email].append(i)</span><br><span class="line">        <span class="comment"># DFS code for traversing accounts.</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, emails)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> visited_accounts[i]:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            visited_accounts[i] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(accounts[i])):</span><br><span class="line">                email = accounts[i][j]</span><br><span class="line">                emails.add(email)</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> emails_accounts_map[email]:</span><br><span class="line">                    dfs(neighbor, emails)</span><br><span class="line">        <span class="comment"># Perform DFS for accounts and add to results.</span></span><br><span class="line">        <span class="keyword">for</span> i, account <span class="keyword">in</span> enumerate(accounts):</span><br><span class="line">            <span class="keyword">if</span> visited_accounts[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            name, emails = account[<span class="number">0</span>], set()</span><br><span class="line">            dfs(i, emails)</span><br><span class="line">            res.append([name] + sorted(emails))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> union find </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>13. Roman to Integer</title>
      <link href="/2018/08/27/13-Roman-to-Integer/"/>
      <url>/2018/08/27/13-Roman-to-Integer/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: C = 100, L = 50, XXX = 30 and III = 3.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; T = &#123; &#123; <span class="string">'I'</span> , <span class="number">1</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'V'</span> , <span class="number">5</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'X'</span> , <span class="number">10</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'L'</span> , <span class="number">50</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'C'</span> , <span class="number">100</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'D'</span> , <span class="number">500</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'M'</span> , <span class="number">1000</span> &#125; &#125;;</span><br><span class="line">                                   </span><br><span class="line">        <span class="keyword">int</span> sum = T[s.back()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T[s[i]] &lt; T[s[i + <span class="number">1</span>]])&#123;</span><br><span class="line">                sum -= T[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum += T[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>99. Recover Binary Search Tree</title>
      <link href="/2018/08/27/99-Recover-Binary-Search-Tree/"/>
      <url>/2018/08/27/99-Recover-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Two elements of a binary search tree (BST) are swapped by mistake.</p><p>Recover the tree without changing its structure.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  /</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  3</span><br></pre></td></tr></table></figure></p><p>Follow up:</p><p>A solution using O(n) space is pretty straight forward.<br>Could you devise a constant space solution?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *first, *second; <span class="comment">//store the position that needs to be swap</span></span><br><span class="line">    TreeNode *prev; <span class="comment">// store the previous position in tree</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        first = second = prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//inorder traversal</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">NULL</span> &amp;&amp; second != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = first -&gt; val;</span><br><span class="line">            first -&gt; val = second -&gt; val;</span><br><span class="line">            second -&gt; val = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// check left first</span></span><br><span class="line">        <span class="keyword">if</span> (root -&gt; left != <span class="literal">NULL</span>) dfs(root -&gt; left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if there's any disorder, store the position. </span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; prev -&gt; val &gt; root -&gt; val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">NULL</span>) </span><br><span class="line">                first = prev;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">NULL</span>) </span><br><span class="line">                second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// current root become prev</span></span><br><span class="line">        prev = root;</span><br><span class="line">        <span class="comment">// right subtree</span></span><br><span class="line">        <span class="keyword">if</span> (root -&gt; right != <span class="literal">NULL</span>) dfs(root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(logn)$</p><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *first= <span class="literal">NULL</span>, *second= <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode *prev= <span class="keyword">new</span> TreeNode(INT_MIN);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        swap(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val) first= prev;</span><br><span class="line">        <span class="keyword">if</span>(first != <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val) second= root;</span><br><span class="line">        <span class="comment">//end do something</span></span><br><span class="line">        prev= root;</span><br><span class="line">        inorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/35YynW" target="_blank" rel="noopener">https://goo.gl/35YynW</a><br><a href="https://goo.gl/SVX1A6" target="_blank" rel="noopener">https://goo.gl/SVX1A6</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>63. Unique Paths II</title>
      <link href="/2018/08/27/63-Unique-Paths-II/"/>
      <url>/2018/08/27/63-Unique-Paths-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p><img src="robot_maze.png" alt=""></p><p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p><p>Note: m and n will be at most 100.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the 3x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid.empty() || obstacleGrid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size(), n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[j] += dp[j - <span class="number">1</span>]; <span class="comment">//current cell = top cell + left cell</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(mn)$<br>space complexity: $O(m)$<br>reference:<br><a href="https://goo.gl/KXyXji" target="_blank" rel="noopener">https://goo.gl/KXyXji</a><br><a href="https://goo.gl/oQm7Qe" target="_blank" rel="noopener">https://goo.gl/oQm7Qe</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>In-place conversion of Sorted DLL to Balanced BST</title>
      <link href="/2018/08/27/In-place-conversion-of-Sorted-DLL-to-Balanced-BST/"/>
      <url>/2018/08/27/In-place-conversion-of-Sorted-DLL-to-Balanced-BST/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a Doubly Linked List which has data members sorted in ascending order. Construct a Balanced Binary Search Tree which has same data members as the given Doubly Linked List. The tree must be constructed in-place (No new node should be allocated for tree conversion)</p><p>Examples:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Input:  Doubly Linked List 1  2  3</span><br><span class="line">Output: A Balanced BST </span><br><span class="line">     2   </span><br><span class="line">   /  \  </span><br><span class="line">  1    3 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: Doubly Linked List 1  2 3  4 5  6  7</span><br><span class="line">Output: A Balanced BST</span><br><span class="line">        4</span><br><span class="line">      /   \</span><br><span class="line">     2     6</span><br><span class="line">   /  \   / \</span><br><span class="line">  1   3  4   7  </span><br><span class="line"></span><br><span class="line">Input: Doubly Linked List 1  2  3  4</span><br><span class="line">Output: A Balanced BST</span><br><span class="line">      3   </span><br><span class="line">    /  \  </span><br><span class="line">   2    4 </span><br><span class="line"> / </span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Input:  Doubly Linked List 1  2  3  4  5  6</span><br><span class="line">Output: A Balanced BST</span><br><span class="line">      4   </span><br><span class="line">    /   \  </span><br><span class="line">   2     6 </span><br><span class="line"> /  \   / </span><br><span class="line">1   3  5</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ul><li><p>Naive solution:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) Get the Middle of the linked list and make it root.</span><br><span class="line">2) Recursively do same for left half and right half.</span><br><span class="line">       a) Get the middle of left half and make it left child of the root</span><br><span class="line">          created in step 1.</span><br><span class="line">       b) Get the middle of right half and make it right child of the</span><br><span class="line">          root created in step 1.</span><br></pre></td></tr></table></figure></li><li><p>Better run time solution:<br>Construct from leaves to root. The idea is to insert nodes in BST in the same order as the appear in Doubly Linked List, so that the tree can be constructed in O(n) time complexity. We first count the number of nodes in the given Linked List. Let the count be n. After counting nodes, we take left n/2 nodes and recursively construct the left subtree. After left subtree is constructed, we assign middle node to root and link the left subtree with root. Finally, we recursively construct the right subtree and link it with root.<br>While constructing the BST, we also keep moving the list head pointer to next so that we have the appropriate pointer in each recursive call.</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A Doubly Linked List node that will also be used as a tree node */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; </span><br><span class="line">    <span class="comment">// For tree, next pointer can be used as right subtree pointer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// For tree, prev pointer can be used as left subtree pointer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//to count nodes in a Linked List, so we can know when is half</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(struct Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(temp)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">struct Node* <span class="title">sortedListToBSTRecur</span><span class="params">(struct Node **head_ref, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">struct Node* <span class="title">sortedListToBST</span><span class="params">(struct Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = countNodes(head);</span><br><span class="line">    <span class="keyword">return</span> sortedListToBSTRecur(&amp;head, n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The main function that constructs balanced BST and returns root of it.</span></span><br><span class="line"><span class="comment">       head_ref --&gt;  Pointer to pointer to head node of Doubly linked list</span></span><br><span class="line"><span class="comment">       n  --&gt; No. of nodes in the Doubly Linked List */</span></span><br><span class="line"><span class="function">struct Node* <span class="title">sortedListToBSTRecur</span><span class="params">(struct Node **head_ref, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Base Case */</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Recursively construct the left subtree */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span> = <span class="title">sortedListToBSTRecur</span>(<span class="title">head_ref</span>, <span class="title">n</span>/2);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* head_ref now refers to middle node, make middle node as root of BST*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">root</span> = *<span class="title">head_ref</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Set pointer to left subtree</span></span><br><span class="line">    root-&gt;prev = left;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Change head pointer of Linked List for parent recursive calls */</span></span><br><span class="line">    *head_ref = (*head_ref)-&gt;next;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Recursively construct the right subtree and link it with root</span></span><br><span class="line"><span class="comment">      The number of nodes in right subtree  is total nodes - nodes in</span></span><br><span class="line"><span class="comment">      left subtree - 1 (for root) */</span></span><br><span class="line">    root-&gt;next = sortedListToBSTRecur(head_ref, n-n/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/jEcKjy" target="_blank" rel="noopener">https://goo.gl/jEcKjy</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> double linked list </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/2018/08/26/42-Trapping-Rain-Water/"/>
      <url>/2018/08/26/42-Trapping-Rain-Water/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p><img src="rainwatertrap.png" alt=""></p><p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p><p>Example:</p><p>Input: [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>An element of array can store water if there’re higher bar on left and right.<br>Use two variables to store the left_max and right_max. The reason doing this is because the water trapped at any element= <code>min(left_max, right_max)- height[i]</code>. So we can calculate the water trapped on smaller element out of height[left] and height[right] first, then move the pointers with condition <code>left &lt;= right</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># keep left_max, right_max to know if there's a higher bar </span></span><br><span class="line">        <span class="comment"># only move left pointer when height[left] is smaller than height[right]</span></span><br><span class="line">        <span class="comment"># only move right pointer when height[right] is smaller than height[left]</span></span><br><span class="line">        res, left, right = <span class="number">0</span>, <span class="number">0</span>, len(height)<span class="number">-1</span></span><br><span class="line">        left_max, right_max = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;= right:</span><br><span class="line">            <span class="keyword">if</span> height[left]&lt; height[right]:</span><br><span class="line">                <span class="keyword">if</span> height[left]&gt; left_max:</span><br><span class="line">                    left_max= height[left]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += left_max-height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> height[right]&gt; right_max:</span><br><span class="line">                    right_max= height[right]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res+= right_max-height[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if an element of the array can store water, if has a bar on it's left and right</span></span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left_max= <span class="number">0</span>, right_max= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt; height[right])&#123;</span><br><span class="line">                <span class="comment">// this means height[right] is definitely a bar, so just consider left side below</span></span><br><span class="line">                <span class="keyword">if</span>(height[left]&gt; left_max)</span><br><span class="line">                    left_max= height[left];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res += left_max-height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[right]&gt; right_max)</span><br><span class="line">                    right_max= height[right];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res+= right_max-height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution-DP"><a href="#Solution-DP" class="headerlink" title="Solution DP"></a>Solution DP</h2><p>The idea is to know what the max height is, to the left and right of every index. Think about it- at any given index, there can only be trapped rain water above it if the <code>min(max_height_to_the_left, max_height_to_the_right)</code> is bigger than the height at this particular index.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        tmp_left, tmp_right, n = <span class="number">0</span>, <span class="number">0</span>, len(height)</span><br><span class="line">        max_left, max_right = [<span class="number">0</span>]*n, [<span class="number">0</span>]*n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            max_left[i] = tmp_left  <span class="comment"># index i's left boundary is tmp_left</span></span><br><span class="line">            <span class="keyword">if</span> height[i] &gt; tmp_left: <span class="comment"># current height is greater, update the tmp_left so it could be coundary for upcoming indexes</span></span><br><span class="line">                tmp_left = height[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            max_right[i] = tmp_right</span><br><span class="line">            <span class="keyword">if</span> height[i] &gt; tmp_right:</span><br><span class="line">                tmp_right = height[i]</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; min(max_left[i], max_right[i]):</span><br><span class="line">                res += min(max_left[i], max_right[i])-height[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/rNJVRc" target="_blank" rel="noopener">https://goo.gl/rNJVRc</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> stack </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>158. Read N Characters Given Read4 II - Call multiple times</title>
      <link href="/2018/08/26/158-Read-N-Characters-Given-Read4-II-Call-multiple-times/"/>
      <url>/2018/08/26/158-Read-N-Characters-Given-Read4-II-Call-multiple-times/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>The API: int read4(char *buf) reads 4 characters at a time from a file.</p><p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p><p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p><p>Note:<br>The read function may be called multiple times.</p><p>Example 1: </p><p>Given buf = “abc”<br>read(“abc”, 1) // returns “a”<br>read(“abc”, 2); // returns “bc”<br>read(“abc”, 1); // returns “”<br>Example 2: </p><p>Given buf = “abc”<br>read(“abc”, 4) // returns “abc”<br>read(“abc”, 1); // returns “”</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two variable, readPos and writePos to store the position of read and write. Scanning from 0…n, if the position of read and write are equal, the call <code>read4</code> and give the return value to writePos because it’s the number characters read from input buffer. One thing to notice is that, if <code>writePos == 0</code>, it means input buffer is empty, we should return current location <code>i</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the read4 API.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read4</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Maximum number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (readPos == writePos) &#123;</span><br><span class="line">                writePos = read4(buff); <span class="comment">//return 3 if only 3 char left</span></span><br><span class="line">                readPos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (writePos == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = buff[readPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> readPos = <span class="number">0</span>, writePos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Another-solution"><a href="#Another-solution" class="headerlink" title="Another solution:"></a>Another solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the read4 API.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read4</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Maximum number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> buffPtr= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buffCnt= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ptr= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptr&lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buffPtr== <span class="number">0</span>)&#123;</span><br><span class="line">                buffCnt= read4(buff);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">while</span>(ptr&lt; n &amp;&amp; buffPtr&lt; buffCnt)&#123;</span><br><span class="line">                buf[ptr++]= buff[buffPtr++];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// all chars in buff used up, set pointer to 0</span></span><br><span class="line">            <span class="keyword">if</span>(buffPtr== buffCnt) buffPtr= <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// read4 returns less than 4, end of file</span></span><br><span class="line">            <span class="keyword">if</span>(buffCnt &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> uber </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>128. Longest Consecutive Sequence</title>
      <link href="/2018/08/26/128-Longest-Consecutive-Sequence/"/>
      <url>/2018/08/26/128-Longest-Consecutive-Sequence/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p><p>Your algorithm should run in O(n) complexity.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is, when we have a number <code>n</code>, check it’s <code>n+1</code> and <code>n-1</code> to get the maximum length, and erase them from the set. Because if they’re consecutive, only need to count once.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; record(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!record.count(n)) <span class="keyword">continue</span>;</span><br><span class="line">            record.erase(n);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//use two pointer search toward left and right to find the largest range</span></span><br><span class="line">            <span class="keyword">int</span> left= n<span class="number">-1</span>, right= n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(record.count(left)) record.erase(left--);</span><br><span class="line">            <span class="keyword">while</span>(record.count(right)) record.erase(right++);</span><br><span class="line">            </span><br><span class="line">            res= max(res, right-left<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> union find </tag>
            
            <tag> uber </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>161. One Edit Distance</title>
      <link href="/2018/08/26/161-One-Edit-Distance/"/>
      <url>/2018/08/26/161-One-Edit-Distance/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two strings s and t, determine if they are both one edit distance apart.</p><p>Note: </p><p>There are 3 possiblities to satisify one edit distance apart:</p><p>Insert a character into s to get t<br>Delete a character from s to get t<br>Replace a character of s to get t<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ab&quot;, t = &quot;acb&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We can insert &apos;c&apos; into s to get t.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;cab&quot;, t = &quot;ad&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We cannot get t from s by only one step.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;1203&quot;, t = &quot;1213&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We can replace &apos;0&apos; with &apos;1&apos; to get t.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneEditDistance</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        discussed into two parts, same length or diff length</span></span><br><span class="line"><span class="comment">        1. same length</span></span><br><span class="line"><span class="comment">            check if only one char is different</span></span><br><span class="line"><span class="comment">        2. diff length</span></span><br><span class="line"><span class="comment">            check if w/o the first one different character, the remain is equal or not.</span></span><br><span class="line"><span class="comment">            Once thing to notice is that, we should use longer string to be the delete character one.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> m= s.length(), n= t.length();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(m-n) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == t.length()) <span class="keyword">return</span> sizeEqual(s, t);</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; t.length()) <span class="keyword">return</span> sizeDiff(s, t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sizeDiff(t, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sizeDiff</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>, j= <span class="number">0</span>; i&lt; s.length()&amp;&amp; j&lt; t.length(); i++, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!= t[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> s.substr(i+<span class="number">1</span>) == t.substr(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sizeEqual</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != t[i]) diff++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> yelp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>114. Flatten Binary Tree to Linked List</title>
      <link href="/2018/08/26/114-Flatten-Binary-Tree-to-Linked-List/"/>
      <url>/2018/08/26/114-Flatten-Binary-Tree-to-Linked-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example, given the following tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure></p><p>The flattened tree should look like:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Recursive solution:</p><p>Use a global variable to store a previous node, and traverse the tree with post-order traversal.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">prev= NULL</span><br><span class="line"></span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">prev= 3</span><br><span class="line"></span><br><span class="line">  1</span><br><span class="line"> / </span><br><span class="line">2 </span><br><span class="line"> \</span><br><span class="line">  3</span><br><span class="line"></span><br><span class="line">prev= 2</span><br><span class="line">  1</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">     \</span><br><span class="line">      3</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* prev= <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) flatten(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) flatten(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        root-&gt;right= prev;</span><br><span class="line">        root-&gt;left= <span class="literal">NULL</span>;</span><br><span class="line">        prev= root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>463. Island Perimeter</title>
      <link href="/2018/08/25/463-Island-Perimeter/"/>
      <url>/2018/08/25/463-Island-Perimeter/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p><p>Example:</p><p>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]</p><p>Answer: 16<br>Explanation: The perimeter is the 16 yellow stripes in the image below:<br><img src="island.png" alt=""></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Count the total number of grid that is 1 from <code>top to down</code> and from <code>left to right</code>.</p><p>When we’re counting the perimeter, if there’s any neighbor of a grid, it will cancel off two edges.<br>ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> ---</span><br><span class="line">|   |  perimeter: 4</span><br><span class="line"> ---</span><br><span class="line"></span><br><span class="line"> ---</span><br><span class="line">|   |  perimeter: 6, 4*2-2</span><br><span class="line">|   |</span><br><span class="line"> ---</span><br></pre></td></tr></table></figure></p><p>While we’re scanning the grid, we need to know how many neighbor does this grid have. Since we’re scanning from top to down, we only need to count the neighbor its row is above the grid. </p><p>Same thing about the neighbor that has different column, only need to count neighbor that is on the left side.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> neighbor= <span class="number">0</span>, count= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">0</span>; r&lt; grid.size(); r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">0</span>; c&lt; grid[<span class="number">0</span>].size(); c++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[r][c] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//this is 1, search how many neighbor around it.</span></span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span>(r != <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c]== <span class="number">1</span>) neighbor++;</span><br><span class="line">                    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>]== <span class="number">1</span>) neighbor++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count*<span class="number">4</span>-neighbor*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(mn)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/5rZHRg" target="_blank" rel="noopener">https://goo.gl/5rZHRg</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> bloomberg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="/2018/08/25/206-Reverse-Linked-List/"/>
      <url>/2018/08/25/206-Reverse-Linked-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Reverse a singly linked list.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure></p><p>Follow up:</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h3 id="Solution-iterative-better"><a href="#Solution-iterative-better" class="headerlink" title="Solution iterative better:"></a>Solution iterative better:</h3><p>Use two variables, <code>pre</code> and <code>cur</code>. Another local variable to keep the swapping node.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre= <span class="literal">NULL</span>, *cur= head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* tmp= cur-&gt;next;</span><br><span class="line">            cur-&gt;next= pre;</span><br><span class="line">            pre= cur;</span><br><span class="line">            cur= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Iteratively solution:<br>Create a dummy node in front of the <code>head</code> node. Use <code>pre</code> and <code>cur</code> to do the swap. But when we do the swapping, we need to use a <code>tmp</code> node to store the <code>cur</code> to avoid dropping nodes in between.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dummy-A-B-C-D-E-F</span><br><span class="line">        </span><br><span class="line">dummy-E-D-C-B-A-F</span><br><span class="line">dummy-F-E-D-C-B-A</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy= <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next= head;</span><br><span class="line">        ListNode *pre= dummy, *cur= head;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;next)&#123;</span><br><span class="line">            ListNode* tmp= pre-&gt;next;</span><br><span class="line">            pre-&gt;next= cur-&gt;next;</span><br><span class="line">            cur-&gt;next= cur-&gt;next-&gt;next;</span><br><span class="line">            pre-&gt;next-&gt;next= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = head.next;</span><br><span class="line">            head.next = dummy.next;</span><br><span class="line">            dummy.next = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n))$<br>space complexity: $O(1)$</p><p>Recursive solution:<br>Try to think the end state for recursion. When the recursion reaches to <code>5</code>, it would return node <code>5</code> to previous recursion. And previous recursion stack would look like this.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4-&gt;5-&gt;null</span><br></pre></td></tr></table></figure></p><p>And what we want is to reverse the list, so we could put <code>4</code> to the back of <code>5</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head -&gt; next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* node = reverseList(head -&gt; next);</span><br><span class="line">        head -&gt; next -&gt; next = head;</span><br><span class="line">        head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode node = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/HSqym3" target="_blank" rel="noopener">https://goo.gl/HSqym3</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>252. Meeting Rooms</title>
      <link href="/2018/08/25/252-Meeting-Rooms/"/>
      <url>/2018/08/25/252-Meeting-Rooms/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,30],[5,10],[15,20]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[7,10],[2,4]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use lambda function to sort, if previous meeting is longer than the latter meeting, then the person can not attend all meetings.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [&amp;](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start&lt; b.start;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i<span class="number">-1</span>].end &gt; intervals[i].start)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$, sorting<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> amazon </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>34. Find First and Last Position of Element in Sorted Array</title>
      <link href="/2018/08/25/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/"/>
      <url>/2018/08/25/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>If the target is not found in the array, return [-1, -1].</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>First, let’s find the left boundary of the range. We initialize the range to <code>[left=0, right=n-1]</code>. In each step, calculate the middle element <code>mid = left+(right-left)/2</code>. Now according to the relative value of A[mid] to target, there are three possibilities:</p><ol><li>If <code>A[mid] &lt; target</code>, the target range must begins on the right of mid (hence <code>left = mid+1</code> for the next iteration)</li><li>If <code>A[mid] &gt; target</code>, it means the range must begins on the left of mid (<code>right = mid-1</code>)</li><li>If <code>A[mid] = target</code>, then the range must begins on the left of or at mid (<code>right= mid</code>)</li></ol><p>With above mid finding way, the mid will always biased toward left. So we can find the <code>left boundary</code> of target.</p><p>That is to say, if we make <code>mid</code> biased toward right, we can find <code>right boundary</code> of target.<br>We can use <code>mid = left+(right-left)/2 +1</code>. </p><ol><li>If A[mid] &gt; target, then the range must begins on the left of mid (<code>right = mid-1</code>)</li><li>If A[mid] &lt; target, then the range must begins on the right of mid (hence <code>left = mid+1</code> for the next iteration)</li><li>If A[mid] = target, then the range must begins on the right of or at mid (<code>left= mid</code>)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> high= nums.size()<span class="number">-1</span>, low= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(nums.size()== <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//search for left side</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= low+(high-low)/<span class="number">2</span>; <span class="comment">//with this mid finding, the mid will always biased toward left </span></span><br><span class="line">            <span class="keyword">if</span>(target&gt; nums[mid])</span><br><span class="line">                low= mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high= mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res[<span class="number">0</span>] = (target == nums[low])? low: <span class="number">-1</span>;</span><br><span class="line">        high= nums.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low&lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= low+(high-low)/<span class="number">2</span> +<span class="number">1</span>; <span class="comment">//notice for the mid value, add one so it will biased toward right</span></span><br><span class="line">            <span class="keyword">if</span>(target&gt;=nums[mid])</span><br><span class="line">                low= mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high= mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = (target == nums[high])? high: <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(logn)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/hL7qEx" target="_blank" rel="noopener">https://goo.gl/hL7qEx</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> uber </tag>
            
            <tag> linkedin </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>269. Alien Dictionary</title>
      <link href="/2018/08/24/269-Alien-Dictionary/"/>
      <url>/2018/08/24/269-Alien-Dictionary/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;wrt&quot;,</span><br><span class="line">  &quot;wrf&quot;,</span><br><span class="line">  &quot;er&quot;,</span><br><span class="line">  &quot;ett&quot;,</span><br><span class="line">  &quot;rftt&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output: &quot;wertf&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;z&quot;,</span><br><span class="line">  &quot;x&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output: &quot;zx&quot;</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;z&quot;,</span><br><span class="line">  &quot;x&quot;,</span><br><span class="line">  &quot;z&quot;</span><br><span class="line">] </span><br><span class="line"></span><br><span class="line">Output: &quot;&quot; </span><br><span class="line"></span><br><span class="line">Explanation: The order is invalid, so return &quot;&quot;.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>You may assume all letters are in lowercase.<br>You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.<br>If the order is invalid, return an empty string.<br>There may be multiple valid order of letters, return any one of them is fine.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>find characters in words</li><li>build graph and indegree, graph contains all neighbors of a characters <code>c</code>, indegree is how many prerequisite need to complete before this character <code>c</code></li><li>find character if it’s indegree is <code>0</code></li><li>topological sort, remove indegree count for neighbor when we complete <code>c</code></li><li>if the result length is not equal to indegree size, then return <code>&quot;&quot;</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alienOrder</span><span class="params">(self, words: List[str])</span> -&gt; str:</span></span><br><span class="line">        graph = defaultdict(list)</span><br><span class="line">        indegree = defaultdict(int)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">                graph[c] = []</span><br><span class="line">                indegree[c] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(words)):</span><br><span class="line">            word1 = words[i<span class="number">-1</span>]</span><br><span class="line">            word2 = words[i]</span><br><span class="line">            </span><br><span class="line">            index, l = <span class="number">0</span>, min(len(word1), len(word2))</span><br><span class="line">            <span class="keyword">while</span> index &lt; l <span class="keyword">and</span> word1[index] == word2[index]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># edge case for ["abc", "ab"]</span></span><br><span class="line">            <span class="keyword">if</span> index == l <span class="keyword">and</span> len(word1) &gt; len(word2):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> index &lt; l:</span><br><span class="line">                graph[word1[index]].append(word2[index])</span><br><span class="line">                indegree[word2[index]] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> indegree.items():</span><br><span class="line">            <span class="keyword">if</span> val == <span class="number">0</span>:</span><br><span class="line">                queue.append(key)</span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            result.append(cur)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> nei <span class="keyword">in</span> graph[cur]:</span><br><span class="line">                indegree[nei] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> indegree[nei] == <span class="number">0</span>:</span><br><span class="line">                    queue.append(nei)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(result) <span class="keyword">if</span> len(result) == len(indegree) <span class="keyword">else</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>First, build a degree map for each character in all the words:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w:0</span><br><span class="line">r:0</span><br><span class="line">t:0</span><br><span class="line">f:0</span><br><span class="line">e:0</span><br></pre></td></tr></table></figure></p><p>Then build the hashmap by comparing the adjacent words, the first character that is different between two adjacent words reflect the lexicographical order. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;wrt&quot;,</span><br><span class="line">&quot;wrf&quot;,</span><br><span class="line">   first different character is 3rd letter, so t comes before f</span><br><span class="line"></span><br><span class="line">&quot;wrf&quot;,</span><br><span class="line">&quot;er&quot;,</span><br><span class="line">   first different character is 1rd letter, so w comes before e</span><br></pre></td></tr></table></figure></p><p>The characters in set come after the key. x-&gt;y means letter x comes before letter y. x -&gt; set: y,z,t,w means x comes before all the letters in the set. The final HashMap “map” looks like.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t -&gt; set: f    </span><br><span class="line">w -&gt; set: e</span><br><span class="line">r -&gt; set: t</span><br><span class="line">e -&gt; set: r</span><br></pre></td></tr></table></figure></p><p>and final HashMap “degree” looks like, the number means “how many letters come before the key”:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w:0</span><br><span class="line">r:1</span><br><span class="line">t:1</span><br><span class="line">f:1</span><br><span class="line">e:1</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">alienOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; indegree;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">multiset</span>&lt;<span class="keyword">char</span>&gt;&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word: words)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ch: word)</span><br><span class="line">                indegree[ch]= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; words.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k= <span class="number">0</span>, len1= words[i<span class="number">-1</span>].length(), len2= words[i].length();</span><br><span class="line">            <span class="comment">//example: wrt, wrf</span></span><br><span class="line">            <span class="keyword">while</span>(words[i<span class="number">-1</span>][k] == words[i][k]) <span class="comment">//skip same characters</span></span><br><span class="line">                k++; <span class="comment">//ex: wrt, wrf. skip 'w', 'r'</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(k&gt;= min(len1, len2)) <span class="keyword">continue</span>; <span class="comment">//exceed one of the length</span></span><br><span class="line">            indegree[words[i][k]]++; <span class="comment">//ex: 'f' comes after 't', so indegree[f]++.</span></span><br><span class="line">            hash[words[i<span class="number">-1</span>][k]].insert(words[i][k]); <span class="comment">//since wrf is after wrt. hash[t]= [f, ...]</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; indegree.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch= <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> val: indegree)&#123; <span class="comment">//ex: indegree[t]= 0, indegree[f]= 1</span></span><br><span class="line">                <span class="keyword">if</span>(!val.second)&#123; <span class="comment">//find node that indegree == 0</span></span><br><span class="line">                    ch= val.first;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">' '</span>) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">//no one is indegree 0, that means have a cycle and is invalid</span></span><br><span class="line">            ans+= ch; <span class="comment">//append character with indegree= 0 to result</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;"ch: "&lt;&lt;ch&lt;&lt;" ,"&lt;&lt;indegree[ch];</span></span><br><span class="line">            indegree[ch]--; </span><br><span class="line">            <span class="comment">//cout&lt;&lt;", "&lt;&lt;indegree[ch]&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> val: hash[ch]) </span><br><span class="line">                indegree[val]--; <span class="comment">//every string comes after </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n+V))$, n: words averge length, V: alpha number of characters in given alphabet<br>space complexity: $O(V)$</p><p>The first step to create a graph takes O(n + alhpa) time where n is number of given words and alpha is number of characters in given alphabet. The second step is also topological sorting. Note that there would be alpha vertices and at-most (n-1) edges in the graph. The time complexity of topological sorting is O(V+E) which is O(n + aplha) here. So overall time complexity is O(n + aplha) + O(n + aplha) which is O(n + aplha).</p><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><p>Question to ask:</p><ul><li>word in same length?</li><li>contain duplicate?</li><li>only character?</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">alienOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. construct graph</span></span><br><span class="line"><span class="comment">            indegree table</span></span><br><span class="line"><span class="comment">            edge table</span></span><br><span class="line"><span class="comment">        2. use graph to output dictionary</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(words.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; indegree;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">multiset</span>&lt;<span class="keyword">char</span>&gt;&gt; edge;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. construct graph</span></span><br><span class="line">        <span class="comment">//1.1 init every character as 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word: words)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c: word)</span><br><span class="line">                indegree[c]= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; words.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l1= words[i<span class="number">-1</span>].length(), l2= words[i].length(), k= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(words[i<span class="number">-1</span>][k] == words[i][k])</span><br><span class="line">                k++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//stop at the first position with different characters</span></span><br><span class="line">            <span class="keyword">if</span>(k&gt;= min(l1, l2)) <span class="keyword">continue</span>; <span class="comment">//if all the same but one of them reaches end</span></span><br><span class="line">            indegree[words[i][k]]++;</span><br><span class="line">            edge[words[i<span class="number">-1</span>][k]].insert(words[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: edge[<span class="string">'a'</span>])</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: edge[<span class="string">'b'</span>])</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: edge[<span class="string">'z'</span>])</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: edge[<span class="string">'c'</span>])</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: indegree)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;x.first&lt;&lt;<span class="string">" "</span>&lt;&lt;x.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; indegree.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp= <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c: indegree)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c.second == <span class="number">0</span>)&#123; <span class="comment">//no indegree, process it first</span></span><br><span class="line">                    tmp= c.first;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;c.first&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="string">' '</span>) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">//can not find a valid character</span></span><br><span class="line">            res+= tmp;</span><br><span class="line">            indegree[tmp]--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c: edge[tmp])&#123;</span><br><span class="line">                indegree[c]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/fKXTmg" target="_blank" rel="noopener">https://goo.gl/fKXTmg</a><br><a href="https://goo.gl/DDsvde" target="_blank" rel="noopener">https://goo.gl/DDsvde</a><br><a href="https://goo.gl/Lb26cZ" target="_blank" rel="noopener">https://goo.gl/Lb26cZ</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> graph </tag>
            
            <tag> topological sort </tag>
            
            <tag> airbnb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>33. Search in Rotated Sorted Array</title>
      <link href="/2018/08/24/33-Search-in-Rotated-Sorted-Array/"/>
      <url>/2018/08/24/33-Search-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We can use binary search to solve this question. The important part is to find the ascending part in the array.</p><p>For a Rotated Sorted Array, it must at some point follow the ascending order. We can check if <code>nums[mid] &gt;= nums[left]</code>, the first half would be a sorted array if it’s true. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= nums.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left])  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt; target &amp;&amp; nums[left] &lt;= target)  </span><br><span class="line">                    right = mid - <span class="number">1</span>;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                    left = mid + <span class="number">1</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(logn)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> apple </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> linkedin </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>346. Moving Average from Data Stream</title>
      <link href="/2018/08/23/346-Moving-Average-from-Data-Stream/"/>
      <url>/2018/08/23/346-Moving-Average-from-Data-Stream/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MovingAverage m = new MovingAverage(3);</span><br><span class="line">m.next(1) = 1</span><br><span class="line">m.next(10) = (1 + 10) / 2</span><br><span class="line">m.next(3) = (1 + 10 + 3) / 3</span><br><span class="line">m.next(5) = (10 + 3 + 5) / 3</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use a queue to store the input and check if the size exceed the limit.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MovingAverage(<span class="keyword">int</span> size): sum(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;size= size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.size()&gt;= size)&#123;</span><br><span class="line">            sum-= q.front(); q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(val);</span><br><span class="line">        sum+= val;</span><br><span class="line">        <span class="keyword">return</span> q.size() == size? (sum/size): (sum/q.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj.next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(1)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/R1YzHh" target="_blank" rel="noopener">https://goo.gl/R1YzHh</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>348. Design Tic-Tac-Toe</title>
      <link href="/2018/08/23/348-Design-Tic-Tac-Toe/"/>
      <url>/2018/08/23/348-Design-Tic-Tac-Toe/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a Tic-tac-toe game that is played between two players on a n x n grid.</p><p>You may assume the following rules:</p><p>A move is guaranteed to be valid and is placed on an empty block.<br>Once a winning condition is reached, no more moves is allowed.<br>A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Given n = 3, assume that player 1 is &quot;X&quot; and player 2 is &quot;O&quot; in the board.</span><br><span class="line"></span><br><span class="line">TicTacToe toe = new TicTacToe(3);</span><br><span class="line"></span><br><span class="line">toe.move(0, 0, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| | |</span><br><span class="line">| | | |    // Player 1 makes a move at (0, 0).</span><br><span class="line">| | | |</span><br><span class="line"></span><br><span class="line">toe.move(0, 2, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| | | |    // Player 2 makes a move at (0, 2).</span><br><span class="line">| | | |</span><br><span class="line"></span><br><span class="line">toe.move(2, 2, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| | | |    // Player 1 makes a move at (2, 2).</span><br><span class="line">| | |X|</span><br><span class="line"></span><br><span class="line">toe.move(1, 1, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| |O| |    // Player 2 makes a move at (1, 1).</span><br><span class="line">| | |X|</span><br><span class="line"></span><br><span class="line">toe.move(2, 0, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| |O| |    // Player 1 makes a move at (2, 0).</span><br><span class="line">|X| |X|</span><br><span class="line"></span><br><span class="line">toe.move(1, 0, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">|O|O| |    // Player 2 makes a move at (1, 0).</span><br><span class="line">|X| |X|</span><br><span class="line"></span><br><span class="line">toe.move(2, 1, 1); -&gt; Returns 1 (player 1 wins)</span><br><span class="line">|X| |O|</span><br><span class="line">|O|O| |    // Player 1 makes a move at (2, 1).</span><br><span class="line">|X|X|X|</span><br></pre></td></tr></table></figure></p><p>Follow up:<br>Could you do better than O(n2) per move() operation?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>If a player wins a Tic-Tac-Toe, it will achieve one of the following conditions:</p><ol><li>Totally <code>n</code> move on the same row.</li><li>Totally <code>n</code> move on the same column.</li><li>Totally <code>n</code> move on diagonal line.</li><li>Totally <code>n</code> move on anti-diagonal line.</li></ol><p>Therefore, we can use two 1D array and two variable to solve this question.<br>For each move, add the value to rows, columns, diagonal and anti-diagonal. If at any time a row or column matches the size of the board then that player has won.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicTacToe</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rows;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">    <span class="keyword">int</span> diagonal= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> antiDiagonal= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    TicTacToe(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        rows.resize(n, <span class="number">0</span>);</span><br><span class="line">        cols.resize(n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;).</span></span><br><span class="line"><span class="comment">        @param row The row of the board.</span></span><br><span class="line"><span class="comment">        @param col The column of the board.</span></span><br><span class="line"><span class="comment">        @param player The player, can be either 1 or 2.</span></span><br><span class="line"><span class="comment">        @return The current winning condition, can be either:</span></span><br><span class="line"><span class="comment">                0: No one wins.</span></span><br><span class="line"><span class="comment">                1: Player 1 wins.</span></span><br><span class="line"><span class="comment">                2: Player 2 wins. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> toAdd= player == <span class="number">1</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">        rows[row]+= toAdd;</span><br><span class="line">        cols[col]+= toAdd;</span><br><span class="line">        <span class="keyword">if</span>(row == col)</span><br><span class="line">            diagonal+= toAdd;</span><br><span class="line">        <span class="keyword">if</span>(col == cols.size()- row<span class="number">-1</span>)</span><br><span class="line">            antiDiagonal+= toAdd;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(rows[row]) == rows.size() ||</span><br><span class="line">           <span class="built_in">abs</span>(cols[col]) == rows.size() ||</span><br><span class="line">           <span class="built_in">abs</span>(diagonal) == rows.size() ||</span><br><span class="line">           <span class="built_in">abs</span>(antiDiagonal) == rows.size())</span><br><span class="line">            <span class="keyword">return</span> player;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TicTacToe object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TicTacToe obj = new TicTacToe(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.move(row,col,player);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/YR2JYd" target="_blank" rel="noopener">https://goo.gl/YR2JYd</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>785. Is Graph Bipartite?</title>
      <link href="/2018/08/23/785-Is-Graph-Bipartite/"/>
      <url>/2018/08/23/785-Is-Graph-Bipartite/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an undirected graph, return true if and only if it is bipartite.</p><p>Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p><p>The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn’t contain any element twice.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">graph will have length in range [1, 100].</span><br><span class="line">graph[i] will contain integers in range [0, graph.length - 1].</span><br><span class="line">graph[i] will not contain i or duplicate values.</span><br><span class="line">The graph is undirected: if any element j is in graph[i], then i will be in graph[j].</span><br><span class="line"></span><br><span class="line">### Solution:</span><br><span class="line"></span><br><span class="line">The goal is to use two colors to paint the graph and see if there are any adjacent nodes having the same color.</span><br><span class="line">Initialize a color[] array for each node. Here are three states for colors[] array:</span><br><span class="line">1: color 1</span><br><span class="line">0: Haven&apos;t been colored.</span><br><span class="line">-1: color 2</span><br><span class="line"></span><br><span class="line">For each node,</span><br><span class="line">1. If it hasn&apos;t been colored, use a color to color it. Then use the other color to color all its adjacent nodes (DFS).</span><br><span class="line">2. If it has been colored, check if the current color is the same as the color that is going to be used to color it.</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        int n= graph.size();</span><br><span class="line">        vector&lt;int&gt; colors(n, 0); </span><br><span class="line">        //three states</span><br><span class="line">        //0: not painted</span><br><span class="line">        //1: color 1</span><br><span class="line">        //-1: color 2</span><br><span class="line">        for(int i= 0; i&lt; n; i++)&#123;</span><br><span class="line">            if(colors[i] == 0 &amp;&amp; !paint(graph, colors, i, 1))</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool paint(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; colors, int index, int color)&#123;</span><br><span class="line">        if(colors[index] != 0)</span><br><span class="line">            return colors[index] == color;</span><br><span class="line">        </span><br><span class="line">        //color = 0, means not painted yet. Assign color to node[index]</span><br><span class="line">        colors[index]= color;</span><br><span class="line">        </span><br><span class="line">        for(int i= 0; i&lt; graph[index].size(); i++)&#123;</span><br><span class="line">            if(!paint(graph, colors, graph[index][i], -color)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(V+E)$<br>space complexity: $O(E)$<br>reference:<br><a href="https://goo.gl/w53FV8" target="_blank" rel="noopener">https://goo.gl/w53FV8</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>211. Add and Search Word - Data structure design</title>
      <link href="/2018/08/23/211-Add-and-Search-Word-Data-structure-design/"/>
      <url>/2018/08/23/211-Add-and-Search-Word-Data-structure-design/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a data structure that supports the following two operations:</p><p>void addWord(word)<br>bool search(word)<br>search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure></p><p>Note:<br>You may assume that all words are consist of lowercase letters a-z.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Most of the part is similar to <a href="/2018/08/23/208-Implement-Trie-Prefix-Tree/" title="208. Implement Trie (Prefix Tree)">208. Implement Trie (Prefix Tree)</a>. The only thing we need to modify is the search part.</p><p>Since we now have <code>&#39;.&#39;</code> to check, we can use DFS to check whether if the trie tree contains the string after the <code>&#39;.&#39;</code>. If there’s at least one subtree return true, that means we can find a word in trie.</p><p>Another follow up for this question is adding <code>&#39;*&#39;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//design a TrieNode class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    TrieNode(): isWord(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c: child)</span><br><span class="line">            c= <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* root; <span class="comment">//global variable root</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode* tmp= root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: word)&#123;</span><br><span class="line">            <span class="keyword">int</span> i= c- <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!tmp-&gt;child[i]) </span><br><span class="line">                tmp-&gt;child[i]= <span class="keyword">new</span> TrieNode();</span><br><span class="line">            </span><br><span class="line">            tmp = tmp-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;isWord= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//need to consider the '.'</span></span><br><span class="line">        <span class="comment">//follow up: '*'</span></span><br><span class="line">        <span class="keyword">return</span> searchWord(word, root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchWord</span><span class="params">(<span class="built_in">string</span> &amp;word, TrieNode *p, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == word.length()) <span class="keyword">return</span> p-&gt;isWord;</span><br><span class="line">        <span class="keyword">if</span>(word[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c: p-&gt;child)&#123;</span><br><span class="line">                <span class="comment">//DFS, if child c is existed and we can find next character in trie, return true</span></span><br><span class="line">                <span class="keyword">if</span>(c &amp;&amp; searchWord(word, c, i+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* follow up for '*'</span></span><br><span class="line"><span class="comment">        else if (word[i] == '*') &#123;</span></span><br><span class="line"><span class="comment">            if (i + 1 == word.size()) return true; //this * is the last character, * can treat as empty</span></span><br><span class="line"><span class="comment">            if (searchWord(word, p, i + 1)) return true; // Skip *</span></span><br><span class="line"><span class="comment">            for (auto &amp;a : p-&gt;child) &#123;</span></span><br><span class="line"><span class="comment">                if (a &amp;&amp; (a-&gt;child[word[i + 1] - 'a'] || word[i + 1] == '.' || word[i + 1] == '*') &amp;&amp; searchWord(word, a, i + 1)) return true;</span></span><br><span class="line"><span class="comment">                if (a &amp;&amp; searchWord(word, a, i)) return true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index= word[i]- <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;child[index] &amp;&amp; searchWord(word, p-&gt;child[index], i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj.addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>addWord:<br>time complexity: $O(l)$, l is the average length of word<br>space complexity: $O(l)$</p><p>search:<br>time complexity: $O(26^l)$, l is the average length of word<br>space complexity: $O(1)$</p><p>Overall space Complexity - $O(26^l)$, l is the average length of word</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)</span><br><span class="line">        self.isWord = <span class="keyword">False</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addWord</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            node = node.children[w]</span><br><span class="line">        node.isWord = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        node = self.root</span><br><span class="line">        self.res = <span class="keyword">False</span></span><br><span class="line">        self.dfs(node, word)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node, word)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">if</span> node.isWord:</span><br><span class="line">                self.res = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> word[<span class="number">0</span>] == <span class="string">"."</span>:</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> node.children.values():</span><br><span class="line">                self.dfs(n, word[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = node.children.get(word[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            self.dfs(node, word[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/2AQFjo" target="_blank" rel="noopener">https://goo.gl/2AQFjo</a><br><a href="https://goo.gl/pihuH1" target="_blank" rel="noopener">https://goo.gl/pihuH1</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
            <tag> trie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>208. Implement Trie (Prefix Tree)</title>
      <link href="/2018/08/23/208-Implement-Trie-Prefix-Tree/"/>
      <url>/2018/08/23/208-Implement-Trie-Prefix-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Implement a trie with insert, search, and startsWith methods.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // returns true</span><br><span class="line">trie.search(&quot;app&quot;);     // returns false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // returns true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     // returns true</span><br></pre></td></tr></table></figure></p><p>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.<br>All inputs are guaranteed to be non-empty strings.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Trie is an important data structure that frequently appeared in interviews. To design a <code>TrieNode</code>, we need a word collection <code>child[26]</code>, which is from a-z, and a boolean value <code>isWord</code> that denotes whether this node is a word or not.</p><p>Insertion in trie<br><img src="1.png" alt=""></p><p>Searching in trie<br><img src="2.png" width="60%"></p><p>Searching prefix in trie<br><img src="3.png" width="60%"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.child = defaultdict(TrieNode)</span><br><span class="line">        self.is_word = <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            p = p.child[c]</span><br><span class="line">        p.is_word = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> p.child:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.child[c]</span><br><span class="line">        <span class="keyword">return</span> p.is_word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        p = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> p.child:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.child[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">        </span><br><span class="line">    TrieNode(): isWord(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c: child)</span><br><span class="line">            c= <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    TrieNode* root;</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root= <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode* p= root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a: word)&#123;</span><br><span class="line">            <span class="keyword">int</span> i= a-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[i]) </span><br><span class="line">                p-&gt;child[i]= <span class="keyword">new</span> TrieNode();</span><br><span class="line">            </span><br><span class="line">            p= p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isWord= <span class="literal">true</span>; <span class="comment">//!!!!!!!!!!!!!! important!!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">        TrieNode* p= root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: key)&#123;</span><br><span class="line">            <span class="keyword">int</span> i= c- <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p= p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* p= root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: prefix)&#123;</span><br><span class="line">            <span class="keyword">int</span> i= c- <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p= p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>Insertion:<br>  time complexity: $O(m)$, m is key length<br>  space complexity: $O(m)$, m is key length</p><p>Search:<br>  time complexity: $O(m)$, m is key length<br>  space complexity: $O(1)$</p><p>Search prefix:<br>  time complexity: $O(m)$, m is key length<br>  space complexity: $O(1)</p><p>reference:<br><a href="https://goo.gl/JjdfdH" target="_blank" rel="noopener">https://goo.gl/JjdfdH</a><br><a href="https://goo.gl/oYnq3P" target="_blank" rel="noopener">https://goo.gl/oYnq3P</a><br><a href="https://goo.gl/QvAJQx" target="_blank" rel="noopener">https://goo.gl/QvAJQx</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> design </tag>
            
            <tag> trie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>88. Merge Sorted Array</title>
      <link href="/2018/08/23/88-Merge-Sorted-Array/"/>
      <url>/2018/08/23/88-Merge-Sorted-Array/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p>Note:</p><p>The number of elements initialized in nums1 and nums2 are m and n respectively.<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two pointers to solve this question.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">round 0:</span><br><span class="line">     m     i</span><br><span class="line">[1,2,3,0,0,0]</span><br><span class="line">[2,5,6]</span><br><span class="line">     n</span><br><span class="line"></span><br><span class="line">round 1:</span><br><span class="line">     m   i  </span><br><span class="line">[1,2,3,0,0,6]</span><br><span class="line">[2,5,6]</span><br><span class="line">   n</span><br><span class="line"></span><br><span class="line">round 2:</span><br><span class="line">     m i    </span><br><span class="line">[1,2,3,0,5,6]</span><br><span class="line">[2,5,6]</span><br><span class="line"> n      </span><br><span class="line"></span><br><span class="line">round 3:</span><br><span class="line">   m i    </span><br><span class="line">[1,2,3,3,5,6]</span><br><span class="line">[2,5,6]</span><br><span class="line"> n      </span><br><span class="line"></span><br><span class="line">round 4:</span><br><span class="line">  mi    </span><br><span class="line">[1,2,2,3,5,6]</span><br><span class="line">[2,5,6]</span><br><span class="line"> n</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = m<span class="number">-1</span>, b= n<span class="number">-1</span>, i=m+n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(a&gt;=<span class="number">0</span> &amp;&amp; b&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i--] = (nums1[a] &gt; nums2[b]) ? nums1[a--] : nums2[b--];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(b&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i--] = nums2[b--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>278. First Bad Version</title>
      <link href="/2018/08/23/278-First-Bad-Version/"/>
      <url>/2018/08/23/278-First-Bad-Version/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given n = 5, and version = 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use binary search to solve this question.</p><p>example1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">x x x v v</span><br><span class="line"></span><br><span class="line">left= 1, right= 5</span><br><span class="line">  mid= 3, badVersion, left= 4</span><br><span class="line"></span><br><span class="line">left= 4, right= 5</span><br><span class="line">  mid= 4, goodVersion, right= 4</span><br><span class="line"></span><br><span class="line">left== right</span><br><span class="line">  stop while loop</span><br><span class="line"></span><br><span class="line">the first bad version is right= 4</span><br></pre></td></tr></table></figure></p><p>example2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">x v v v v</span><br><span class="line"></span><br><span class="line">left= 1, right= 5</span><br><span class="line">  mid= 3, goodVersion, right= 3</span><br><span class="line"></span><br><span class="line">left= 1, right= 3</span><br><span class="line">  mid= 2, goodVersion, right= 2</span><br><span class="line"></span><br><span class="line">left= 1, right= 2</span><br><span class="line">  mid= 1, badVersion, left= 2</span><br><span class="line"></span><br><span class="line">left== right</span><br><span class="line">  stop while loop</span><br><span class="line"></span><br><span class="line">the first bad version is right= 2</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">1</span>, right= n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= left+ (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right= mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left= mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(logn)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>325. Maximum Size Subarray Sum Equals k</title>
      <link href="/2018/08/23/325-Maximum-Size-Subarray-Sum-Equals-k/"/>
      <url>/2018/08/23/325-Maximum-Size-Subarray-Sum-Equals-k/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn’t one, return 0 instead.</p><p>Note:<br>The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, -1, 5, -2, 3], k = 3</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.</p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2, -1, 2, 1], k = 1</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Explanation: The subarray [-1, 2] sums to 1 and is the longest.</p><p>Follow Up:<br>Can you do it in O(n) time?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use an unordered_map with current sum as index, and index in the array as value.</p><p>But to construct <code>k</code> might not be straightforward, so we can see this example.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6], k= 9</span><br><span class="line">-------|</span><br><span class="line">sum= 6</span><br><span class="line">-------------|</span><br><span class="line">      sum= 15</span><br></pre></td></tr></table></figure><p>We want to find <code>k=9</code> in the above example. When we get to 5, we can see that 15-6= 9. That is to say, if we have a current sum equals to <code>y</code>, and we can find a previous sum <code>x</code> equals to <code>y-k</code>, then we find a subarray that can construct <code>k</code>.</p><p>In the above example.y= 15, k= 9, x= 6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">//sum, index</span></span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>, cur_sum= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            cur_sum+= nums[i];</span><br><span class="line">            <span class="keyword">if</span>(cur_sum == k)</span><br><span class="line">                res= i+<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(cur_sum-k) != <span class="built_in">map</span>.end()) <span class="comment">//can construct a k with some part of the array</span></span><br><span class="line">                res= max(res, i-<span class="built_in">map</span>[cur_sum-k]); <span class="comment">//compare current maximum result with the new one</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(cur_sum) == <span class="built_in">map</span>.end()) <span class="comment">//can not find cur_sum in map</span></span><br><span class="line">                <span class="built_in">map</span>[cur_sum]= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/JNXSBp" target="_blank" rel="noopener">https://goo.gl/JNXSBp</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>277. Find the Celebrity</title>
      <link href="/2018/08/22/277-Find-the-Celebrity/"/>
      <url>/2018/08/22/277-Find-the-Celebrity/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.</p><p>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: “Hi, A. Do you know B?” to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).</p><p>You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.</p><p>Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity’s label if there is a celebrity in the party. If there is no celebrity, return -1.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to first find a person that does not know everyone.</p><p>Since celebrity don’t know anyone else, so if candidate knows i, candidate is definitely not celebrity.</p><ol><li>If A knows B: A must not be celebrity, B possible</li><li>If A doesn’t know B: A possible, B must not be celebrity.</li></ol><p>After we got a candidate like this, we need to check two things.</p><ol><li>This candidate does not know any one else</li><li>Everyone knows the candidate</li></ol><p>One thing to improve is that we can use the index to help. Since we’ve already did the <code>knows(candidate, i)</code> in previous loop, we only need to check <code>!knows(i, candidate)</code> if <code>i&gt; candidate</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the knows API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">knows</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">0</span>; <span class="comment">//set first person as candidate</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(knows(candidate, i))&#123; </span><br><span class="line">                candidate = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">// speed up the searching process, because part of the check did it before.</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;candidate &amp;&amp; knows(candidate, i) || !knows(i, candidate)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;candidate &amp;&amp; !knows(i, candidate)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/tyBj1e" target="_blank" rel="noopener">https://goo.gl/tyBj1e</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>133. Clone Graph</title>
      <link href="/2018/08/22/133-Clone-Graph/"/>
      <url>/2018/08/22/133-Clone-Graph/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p><p>OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.</p><p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p><p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p><p>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.<br>Second node is labeled as 1. Connect node 1 to node 2.<br>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.<br>Visually, the graph looks like the following:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line">  / \</span><br><span class="line"> /   \</span><br><span class="line">0 --- 2</span><br><span class="line">     / \</span><br><span class="line">     \_/</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a map to store every node that has already been copied. While adding every neighbor, call recursive function to apply dfs.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        visited = &#123;node: Node(node.val)&#125;</span><br><span class="line">        self.dfs(node, visited)</span><br><span class="line">        <span class="keyword">return</span> visited[node]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node, visited)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                visited[neighbor] = Node(neighbor.val)</span><br><span class="line">                self.dfs(neighbor, visited)</span><br><span class="line">            visited[node].neighbors.append(visited[neighbor])</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for undirected graph.</span></span><br><span class="line"><span class="comment"> * struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//use map to store the nodes that have already been copied</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; <span class="built_in">map</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.find(node) == <span class="built_in">map</span>.end())&#123; <span class="comment">//not cloned yet</span></span><br><span class="line">            UndirectedGraphNode* tmp= <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);</span><br><span class="line">            <span class="built_in">map</span>[node]= tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n: node-&gt;neighbors)&#123;</span><br><span class="line">                tmp-&gt;neighbors.push_back(cloneGraph(n));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution-BFS"><a href="#Solution-BFS" class="headerlink" title="Solution BFS:"></a>Solution BFS:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        queue = deque([node])</span><br><span class="line">        visited = &#123;node: Node(node.val)&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            front = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> front.neighbors:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    newNode = Node(neighbor.val)</span><br><span class="line">                    visited[neighbor] = newNode</span><br><span class="line">                    queue.append(neighbor)</span><br><span class="line">                visited[front].neighbors.append(visited[neighbor])</span><br><span class="line">        <span class="keyword">return</span> visited[node]</span><br></pre></td></tr></table></figure><p>time complexity: $O(V+E)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/BGsAmT" target="_blank" rel="noopener">https://goo.gl/BGsAmT</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>791. Custom Sort String</title>
      <link href="/2018/08/22/791-Custom-Sort-String/"/>
      <url>/2018/08/22/791-Custom-Sort-String/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>S and T are strings composed of lowercase letters. In S, no letter occurs more than once.</p><p>S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string.</p><p>Return any permutation of T (as a string) that satisfies this property.</p><p>Example :<br>Input:<br>S = “cba”<br>T = “abcd”<br>Output: “cbad”<br>Explanation:<br>“a”, “b”, “c” appear in S, so the order of “a”, “b”, “c” should be “c”, “b”, and “a”.<br>Since “d” does not appear in S, it can be at any position in T. “dcba”, “cdba”, “cbda” are also valid outputs.</p><p>Note:</p><p>S has length at most 26, and no character is repeated in S.<br>T has length at most 200.<br>S and T consist of lowercase letters only.</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>Use STL to solve this question.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">customSortString</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        sort(T.begin(), T.end(),</span><br><span class="line">             [&amp;](<span class="keyword">char</span> a, <span class="keyword">char</span> b) &#123; <span class="keyword">return</span> S.find(a) &lt; S.find(b); &#125;);</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>space complexity: $O(1)$</p><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><p>S: customer order<br>T: string to be sorted</p><ol><li>Use bucket sort to store all the characters in <code>bucket</code>. </li><li>Walk through <code>customer order</code>, the bucket[c] contains the number of occurrence in T. We need to append that many times of <code>c</code> in the result string.</li><li>Append remaining characters in result string. </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">customSortString</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        bucket sort</span></span><br><span class="line"><span class="comment">        1. put the string into the bucket</span></span><br><span class="line"><span class="comment">        2. append every same character into string</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//S: cba</span></span><br><span class="line">        <span class="comment">//T: abcd</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: T)</span><br><span class="line">            bucket[c-<span class="string">'a'</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res= <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: S)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; bucket[c-<span class="string">'a'</span>]; i++)&#123;</span><br><span class="line">                res+= c;</span><br><span class="line">            &#125;</span><br><span class="line">            bucket[c-<span class="string">'a'</span>]= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; bucket.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; bucket[i]; j++)</span><br><span class="line">                res+= (i+<span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/Lef54y" target="_blank" rel="noopener">https://goo.gl/Lef54y</a><br><a href="https://goo.gl/aX25f1" target="_blank" rel="noopener">https://goo.gl/aX25f1</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="/2018/08/22/125-Valid-Palindrome/"/>
      <url>/2018/08/22/125-Valid-Palindrome/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p><p>Example 1:<br>Input: “A man, a plan, a canal: Panama”<br>Output: true</p><p>Example 2:<br>Input: “race a car”<br>Output: false</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two pointers to solve this question.<br><code>isalnum</code> can check if the character is numeric or alphabetic.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= s.length()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(s[left])) left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(s[right])) right--;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[left])!= <span class="built_in">tolower</span>(s[right]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left++; right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Python solution, also use two pointers to solve.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        p, q = <span class="number">0</span>, len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; q:</span><br><span class="line">            <span class="keyword">while</span> p&lt; q <span class="keyword">and</span> <span class="keyword">not</span> s[p].isalnum():</span><br><span class="line">                p+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> p&lt; q <span class="keyword">and</span> <span class="keyword">not</span> s[q].isalnum():</span><br><span class="line">                q-=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> s[p].lower() != s[q].lower():</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            p+=<span class="number">1</span>; q-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/vyjCpj" target="_blank" rel="noopener">https://goo.gl/vyjCpj</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> apple </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>257. Binary Tree Paths</title>
      <link href="/2018/08/22/257-Binary-Tree-Paths/"/>
      <url>/2018/08/22/257-Binary-Tree-Paths/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, return all root-to-leaf paths.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure></p><p>Output: <code>[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</code></p><p>Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use dfs to find every leaf. The definition for leaf is it does not have left child or right child.</p><p>DFS<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, tmp, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(tmp + str(root.val))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left: dfs(root.left, tmp+ str(root.val) + <span class="string">"-&gt;"</span>, res)</span><br><span class="line">            <span class="keyword">if</span> root.right: dfs(root.right, tmp+ str(root.val)+ <span class="string">"-&gt;"</span>, res)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        dfs(root, <span class="string">""</span>, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>BFS<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        q = collections.deque([(root, <span class="string">""</span>)])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node, tmp = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                res.append(tmp + str(node.val))</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append([node.left, tmp+str(node.val)+<span class="string">"-&gt;"</span>])</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append([node.right, tmp+str(node.val)+<span class="string">"-&gt;"</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">string</span> tmp= <span class="string">""</span>;</span><br><span class="line">        helper(res, tmp, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span> tmp, TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="comment">//reach a leaf</span></span><br><span class="line">            res.push_back(tmp+to_string(root-&gt;val));</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) helper(res, tmp+to_string(root-&gt;val)+<span class="string">"-&gt;"</span>, root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) helper(res, tmp+to_string(root-&gt;val)+<span class="string">"-&gt;"</span>, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$, because visit every node once<br>space complexity: $O(logn)$, height of the tree<br>reference:<br><a href="https://goo.gl/RvfssD" target="_blank" rel="noopener">https://goo.gl/RvfssD</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>247. Strobogrammatic Number II</title>
      <link href="/2018/08/22/247-Strobogrammatic-Number-II/"/>
      <url>/2018/08/22/247-Strobogrammatic-Number-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p><p>Find all strobogrammatic numbers that are of length = n.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  n = 2</span><br><span class="line">Output: [&quot;11&quot;,&quot;69&quot;,&quot;88&quot;,&quot;96&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>First, we use some example to find the pattern. If given n= 4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = 0:   none</span><br><span class="line"></span><br><span class="line">n = 1:   0, 1, 8</span><br><span class="line"></span><br><span class="line">n = 2:   11, 69, 88, 96</span><br><span class="line"></span><br><span class="line">n = 3:   101, 609, 808, 906, 111, 619, 818, 916, 181, 689, 888, 986</span><br><span class="line"></span><br><span class="line">n = 4:   1001, 6009, 8008, 9006, 1111, 6119, 8118, 9116, 1691, 6699, 8698, 9696, 1881, 6889, 8888, 9886, 1961, 6969, 8968, 9966</span><br></pre></td></tr></table></figure><p>Observe <code>n == 0</code> and <code>n == 2</code>, we can see that the latter one is base on the previous one with [1 1], [6 9], [8 8], [9 6] on both side. The same thing happens on <code>n==1</code> and <code>n==3</code>.</p><p>One thing to notice is that when <code>n == 4</code>, we can not put <code>0</code> on each side.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findStrobogrammatic(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> find(n, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; find(<span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123; <span class="comment">//m: which layer currently at. n: which layer need to reach</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"8"</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t = find(m - <span class="number">2</span>, n), res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m != n) res.push_back(<span class="string">"0"</span> + a + <span class="string">"0"</span>); <span class="comment">//0 and 0 can not be in the front and end</span></span><br><span class="line">            res.push_back(<span class="string">"1"</span> + a + <span class="string">"1"</span>);</span><br><span class="line">            res.push_back(<span class="string">"6"</span> + a + <span class="string">"9"</span>);</span><br><span class="line">            res.push_back(<span class="string">"8"</span> + a + <span class="string">"8"</span>);</span><br><span class="line">            res.push_back(<span class="string">"9"</span> + a + <span class="string">"6"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(5^n))$, for every recursive call, there will be 5 different result for every string.<br>space complexity: $O(n/2))$, stack space</p><p>reference:<br><a href="https://goo.gl/oiRqCY" target="_blank" rel="noopener">https://goo.gl/oiRqCY</a><br><a href="https://goo.gl/mr3grV" target="_blank" rel="noopener">https://goo.gl/mr3grV</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>426. Convert Binary Search Tree to Sorted Doubly Linked List</title>
      <link href="/2018/08/22/426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/"/>
      <url>/2018/08/22/426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list.</p><p>Let’s take the following BST as an example, it may help you understand the problem better:</p><p><img src="1.png" width="60%"></p><p>We want to transform this BST into a circular doubly linked list. Each node in a doubly linked list has a predecessor and successor. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.</p><p>The figure below shows the circular doubly linked list for the BST above. The “head” symbol means the node it points to is the smallest element of the linked list.</p><p><img src="2.png" alt=""></p><p>Specifically, we want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. We should return the pointer to the first element of the linked list.</p><p>The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.</p><p><img src="3.png" width="70%"></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a stack to help us traverse the tree. When we reach to left most node, which is the head node, we need to store it for the last element point to its successor. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        Node* cur= root;</span><br><span class="line">        Node* head= <span class="literal">NULL</span>;</span><br><span class="line">        Node* prev= <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; stk;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur || !stk.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">                stk.push(cur);</span><br><span class="line">                cur= cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur= stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">if</span>(!head) head= cur; <span class="comment">//find the left most, it is the head</span></span><br><span class="line">                <span class="keyword">if</span>(prev)&#123;</span><br><span class="line">                    prev-&gt;right= cur; </span><br><span class="line">                    cur-&gt;left= prev;</span><br><span class="line">                &#125;</span><br><span class="line">                prev= cur;</span><br><span class="line">                cur= cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;left= prev;</span><br><span class="line">        prev-&gt;right= head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/5WuMah" target="_blank" rel="noopener">https://goo.gl/5WuMah</a><br><a href="https://goo.gl/AMsfU3" target="_blank" rel="noopener">https://goo.gl/AMsfU3</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>124. Binary Tree Maximum Path Sum</title>
      <link href="/2018/08/22/124-Binary-Tree-Maximum-Path-Sum/"/>
      <url>/2018/08/22/124-Binary-Tree-Maximum-Path-Sum/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-empty binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br></pre></td></tr></table></figure></p><p>Output: 6<br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure></p><p>Output: 42</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea of this question is to do dfs with a global variable. We design a dfs function that help to </p><ol><li>computes the maximum path sum with highest node is the input node, update maximum if necessary.</li><li>returns the maximum sum of the path that can be extended to input node’s parent.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        self.res = float(<span class="string">"-inf"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            right = max(dfs(root.right), <span class="number">0</span>)</span><br><span class="line">            left = max(dfs(root.left), <span class="number">0</span>)</span><br><span class="line">            self.res = max(self.res, root.val + right + left)</span><br><span class="line">            <span class="keyword">return</span> root.val + max(right, left)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result= INT_MIN;</span><br><span class="line">        dfs(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left= max(<span class="number">0</span>, dfs(root-&gt;left, result));</span><br><span class="line">        <span class="keyword">int</span> right= max(<span class="number">0</span>, dfs(root-&gt;right, result));</span><br><span class="line">        </span><br><span class="line">        result= max(result, left+right+root-&gt;val); <span class="comment">//use root as the lowest common ancestor, which is the highest node to compare with current maximum result</span></span><br><span class="line">        <span class="keyword">return</span> max(left, right)+root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/NGnBtX" target="_blank" rel="noopener">https://goo.gl/NGnBtX</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> amazon </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>560. Subarray Sum Equals K</title>
      <link href="/2018/08/21/560-Subarray-Sum-Equals-K/"/>
      <url>/2018/08/21/560-Subarray-Sum-Equals-K/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p><p>Example 1:<br>Input:nums = [1,1,1], k = 2<br>Output: 2<br>Note:<br>The length of the array is in range [1, 20,000].<br>The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The key of solving this problem is to find <code>SUM[i, j]</code>. So if we know <code>SUM[0, i - 1]</code> and <code>SUM[0, j]</code>, then we can easily get <code>SUM[i, j]</code>. To achieve this, we just need to go through the array, calculate the current sum and save number of all seen PreSum to a HashMap. </p><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[2,3,2,5,8]</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">init state:</span><br><span class="line">0, 1</span><br><span class="line"></span><br><span class="line">round 1:</span><br><span class="line">cur_sum: 2, ans: 0, cur-k: -3, count: 0 after_count: 0</span><br><span class="line"> 2, 1</span><br><span class="line"> -3, 0</span><br><span class="line"> 0, 1</span><br><span class="line"></span><br><span class="line">round 2:</span><br><span class="line">cur_sum: 5, ans: 1, cur-k: 0, count: 1 after_count: 1</span><br><span class="line"> 2, 1</span><br><span class="line"> -3, 0</span><br><span class="line"> 5, 1</span><br><span class="line"> 0, 1</span><br><span class="line"></span><br><span class="line">round 3:</span><br><span class="line">cur_sum: 7, ans: 2, cur-k: 2, count: 1 after_count: 1</span><br><span class="line"> 7, 1</span><br><span class="line"> 0, 1</span><br><span class="line"> 5, 1</span><br><span class="line"> -3, 0</span><br><span class="line"> 2, 1</span><br><span class="line"></span><br><span class="line">round 4:</span><br><span class="line">cur_sum: 12, ans: 3, cur-k: 7, count: 1 after_count: 1</span><br><span class="line"> 12, 1</span><br><span class="line"> 7, 1</span><br><span class="line"> 0, 1</span><br><span class="line"> 5, 1</span><br><span class="line"> -3, 0</span><br><span class="line"> 2, 1</span><br><span class="line"></span><br><span class="line">round 5:</span><br><span class="line">cur_sum: 20, ans: 3, cur-k: 15, count: 0 after_count: 0</span><br><span class="line"> 20, 1</span><br><span class="line"> 15, 0</span><br><span class="line"> 12, 1</span><br><span class="line"> 7, 1</span><br><span class="line"> 0, 1</span><br><span class="line"> 5, 1</span><br><span class="line"> -3, 0</span><br><span class="line"> 2, 1</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># idea is to store appreaed values in hashmap</span></span><br><span class="line">        <span class="comment"># sum(0, y) - sum(0, x) = sum(x, y)</span></span><br><span class="line">        res, cur, dic = <span class="number">0</span>, <span class="number">0</span>, defaultdict(int)</span><br><span class="line">        dic[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            cur += n</span><br><span class="line">            <span class="keyword">if</span> cur-k <span class="keyword">in</span> dic:</span><br><span class="line">                res += dic[cur-k]</span><br><span class="line">            dic[cur] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counts&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            cur_sum += num;</span><br><span class="line">            ans += counts[cur_sum - k];</span><br><span class="line">            ++counts[cur_sum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/3nxf3P" target="_blank" rel="noopener">https://goo.gl/3nxf3P</a><br><a href="https://goo.gl/T4kEoE" target="_blank" rel="noopener">https://goo.gl/T4kEoE</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>543. Diameter of Binary Tree</title>
      <link href="/2018/08/21/543-Diameter-of-Binary-Tree/"/>
      <url>/2018/08/21/543-Diameter-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree </span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5</span><br></pre></td></tr></table></figure></p><p>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>If the longest path will include the root node, then the longest path must be the depth(root-&gt;right) + depth (root-&gt;left)<br>If the longest path does not include the root node, this problem is divided into 2 sub-problem: set left child and right child as the new root separately, and repeat step1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> max_d= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        design a maxDepth function to calculate depth for left and right subtree</span></span><br><span class="line"><span class="comment">        a global variable for maximum diameter</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> max_d;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) left= maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) right= maxDepth(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        max_d= max(max_d, left+right);</span><br><span class="line">        <span class="keyword">return</span> max(left, right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/PFpQAY" target="_blank" rel="noopener">https://goo.gl/PFpQAY</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>349. Intersection of Two Arrays</title>
      <link href="/2018/08/21/349-Intersection-of-Two-Arrays/"/>
      <url>/2018/08/21/349-Intersection-of-Two-Arrays/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two arrays, write a function to compute their intersection.</p><p>Example 1:</p><p>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2]<br>Example 2:</p><p>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [9,4]<br>Note:</p><p>Each element in the result must be unique.<br>The result can be in any order.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="comment">//chekc how many distinct element are the same</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; check(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check.count(n))&#123;</span><br><span class="line">                res.push_back(n);</span><br><span class="line">                check.erase(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/ov6Mgb" target="_blank" rel="noopener">https://goo.gl/ov6Mgb</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> hash table </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>215. Kth Largest Element in an Array</title>
      <link href="/2018/08/21/215-Kth-Largest-Element-in-an-Array/"/>
      <url>/2018/08/21/215-Kth-Largest-Element-in-an-Array/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5<br>Example 2:</p><p>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><h3 id="Solution-priority-queue"><a href="#Solution-priority-queue" class="headerlink" title="Solution priority_queue:"></a>Solution priority_queue:</h3><p>This problem can easily be solved by using STL container, priority queue.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># use min heap to store the largest K element</span></span><br><span class="line">        <span class="comment"># the top of the heap is Kth largest element because it's min heap</span></span><br><span class="line">        pq = nums[:k]</span><br><span class="line">        heapq.heapify(pq)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            heapq.heappush(pq, x)</span><br><span class="line">            heapq.heappop(pq)</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq(nums.begin(), nums.end()); <span class="comment">//put all elements in priority queue</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) </span><br><span class="line">            pq.pop(); <span class="comment">//remove the elements that is greater than Kth element</span></span><br><span class="line">        <span class="keyword">return</span> pq.top(); <span class="comment">//Now the largest one is Kth </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution-quick-sort"><a href="#Solution-quick-sort" class="headerlink" title="Solution quick sort:"></a>Solution quick sort:</h3><p>However, this is not what this question is asking.<br>We can use <code>quick sort</code> to solve this question. The essential part of quick sort is sort the array by a <code>pivot</code>. The pivot will divide the array into two half, one half greater than pivot and the other smaller than pivot.</p><ol><li>Initialize left to be 0 and right to be nums.size() - 1;</li><li>Partition the array, if the pivot is at the k-1-th position, return it (we are done);</li><li>If the pivot is right to the k-1-th position, update right to be the left neighbor of the pivot;</li><li>Else update left to be the right neighbor of the pivot.</li><li>Repeat 2.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, left, r)</span>:</span></span><br><span class="line">            <span class="comment"># use l as pivot, partition nums to </span></span><br><span class="line">            <span class="comment"># larger than nums[l] + equal to nums[l] + smaller than nums[l]</span></span><br><span class="line">            pivot = nums[left]</span><br><span class="line">            l = left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                <span class="keyword">if</span> nums[l] &lt; pivot <span class="keyword">and</span> nums[r] &gt; pivot:</span><br><span class="line">                    nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[l] &gt;= pivot: <span class="comment"># already greater, continue</span></span><br><span class="line">                    l+= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[r] &lt;= pivot: <span class="comment"># already smaller, continue</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">            nums[left], nums[r] = nums[r], nums[left]</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        l, r = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            p = partition(nums, l, r)</span><br><span class="line">            <span class="keyword">if</span> p == k<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[p]</span><br><span class="line">            <span class="keyword">elif</span> p &lt; k<span class="number">-1</span>:</span><br><span class="line">                l = p+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = p<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//quick sort: find a pivot and partition the list into two half. greater than pivot and smaller than pivot</span></span><br><span class="line">        <span class="comment">//if pivot is k-1th, then return</span></span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> p= sort(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span>(p == k<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums[p];</span><br><span class="line">            <span class="keyword">if</span>(p &lt; k<span class="number">-1</span>)</span><br><span class="line">                left= p+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right= p<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//use left most element as pivot, greater than pivot put left side.</span></span><br><span class="line">        <span class="keyword">int</span> pivot= nums[left]; </span><br><span class="line">        <span class="keyword">int</span> l= left+<span class="number">1</span>, r= right;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt; pivot &amp;&amp; nums[r] &gt; pivot)</span><br><span class="line">                swap(nums[l++], nums[r--]);</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&gt;= pivot)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">if</span>(nums[r]&lt;= pivot)</span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//the nums[r] is greater than nums[left], so need to swap </span></span><br><span class="line">        swap(nums[left], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>space complexity: $O(1)$</p><p>reference:<br><a href="https://goo.gl/R5oX7C" target="_blank" rel="noopener">https://goo.gl/R5oX7C</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> sort </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>143. Reorder List</title>
      <link href="/2018/08/21/143-Reorder-List/"/>
      <url>/2018/08/21/143-Reorder-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p><p>Example 1:</p><p>Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.<br>Example 2:</p><p>Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to divide the list into two half. Reverse the second half, then reassemble the list.</p><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cut the list into half</span><br><span class="line">1-2-3-4-5-6</span><br><span class="line">    |     |</span><br><span class="line">   slow  fast</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reverse the second part of the list</span><br><span class="line">1-2-3-4-5-6</span><br><span class="line">    | |    </span><br><span class="line">   mid|  </span><br><span class="line">     pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1-2-3-4-5-6   original</span><br><span class="line"></span><br><span class="line">      4</span><br><span class="line">1-2-3/  &gt; 6   make 4 point to tmp-&gt;next, which is 6</span><br><span class="line">      5</span><br><span class="line"></span><br><span class="line">1-2-3 5-4-6   make 5-&gt;next point to 4</span><br><span class="line">1-2-3-5-4-6   make mid-&gt;next point to 5</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">size, p = <span class="number">1</span>, head</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    p, size = p.next, size+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">p = head</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(size//<span class="number">2</span> - <span class="number">1</span>):</span><br><span class="line">    p = p.next</span><br><span class="line">q = p.next</span><br><span class="line">p.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#reverse next half</span></span><br><span class="line">half, half.next = ListNode(<span class="number">0</span>), q</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> q <span class="keyword">and</span> q.next:</span><br><span class="line">    tmp = half.next</span><br><span class="line">    half.next = q.next</span><br><span class="line">    q.next = q.next.next</span><br><span class="line">    half.next.next = tmp</span><br><span class="line"></span><br><span class="line">p, q = head, half.next</span><br><span class="line"><span class="keyword">while</span> p <span class="keyword">and</span> q:</span><br><span class="line">    p2, q2 = p.next, q.next</span><br><span class="line">    p.next = q</span><br><span class="line">    q.next = p2</span><br><span class="line">    p = p2</span><br><span class="line">    q = q2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *slow= head, *fast= head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; </span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* middle = slow;</span><br><span class="line">        ListNode* preCurrent = slow-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(preCurrent-&gt;next != <span class="literal">NULL</span>)&#123; <span class="comment">//use preCurrent-&gt;next to determine whether if there's more element need to reverse</span></span><br><span class="line">            </span><br><span class="line">            ListNode *tmp = preCurrent-&gt;next; </span><br><span class="line">            preCurrent-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = middle-&gt;next;</span><br><span class="line">            middle-&gt;next= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        slow = head; <span class="comment">//first part of the list</span></span><br><span class="line">        fast = middle-&gt;next; <span class="comment">//second part of the list</span></span><br><span class="line">        <span class="keyword">while</span>(slow != middle)&#123;</span><br><span class="line">            middle-&gt;next = fast-&gt;next;</span><br><span class="line">            fast-&gt;next= slow-&gt;next;</span><br><span class="line">            slow-&gt;next= fast;</span><br><span class="line">            slow= fast-&gt;next;</span><br><span class="line">            fast= middle-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>Another way is to use stack to keep all the second half nodes. Since stack is last in first out, we would get the last node when we rearrange the list.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">stk = collections.deque()</span><br><span class="line">size, p = <span class="number">1</span>, head</span><br><span class="line"><span class="keyword">while</span> p:</span><br><span class="line">    p, size = p.next, size+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">p = head</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(size // <span class="number">2</span> - <span class="number">1</span>):</span><br><span class="line">    p = p.next</span><br><span class="line"></span><br><span class="line">q = p.next <span class="comment"># head of second half list</span></span><br><span class="line">p.next = <span class="keyword">None</span> <span class="comment"># let first half end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    stk.append(q)</span><br><span class="line">    q = q.next</span><br><span class="line"></span><br><span class="line">p = head</span><br><span class="line"><span class="keyword">while</span> stk <span class="keyword">and</span> p:</span><br><span class="line">    top = stk.pop()</span><br><span class="line">    top.next = p.next</span><br><span class="line">    p.next = top</span><br><span class="line">    p = p.next.next</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$</p><p>reference:<br><a href="https://goo.gl/5MyHcY" target="_blank" rel="noopener">https://goo.gl/5MyHcY</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>438. Find All Anagrams in a String</title>
      <link href="/2018/08/21/438-Find-All-Anagrams-in-a-String/"/>
      <url>/2018/08/21/438-Find-All-Anagrams-in-a-String/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.</p><p>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</p><p>The order of output does not matter.</p><p>Example 1:</p><p>Input:<br>s: “cbaebabacd” p: “abc”</p><p>Output:<br>[0, 6]</p><p>Explanation:<br>The substring with start index = 0 is “cba”, which is an anagram of “abc”.<br>The substring with start index = 6 is “bac”, which is an anagram of “abc”.<br>Example 2:</p><p>Input:<br>s: “abab” p: “ab”</p><p>Output:<br>[0, 1, 2]</p><p>Explanation:<br>The substring with start index = 0 is “ab”, which is an anagram of “ab”.<br>The substring with start index = 1 is “ba”, which is an anagram of “ab”.<br>The substring with start index = 2 is “ab”, which is an anagram of “ab”.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question to ask:</p><ol><li>what is anagram? size would be the same?</li></ol><p>The idea is using fixed size sliding window, the size is <code>len(p)</code><br>An anagram is frequency of each character should be same in two strings.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span></span><br><span class="line">        pCount = Counter(p)</span><br><span class="line">        sCount = Counter(s[:len(p)<span class="number">-1</span>])</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> range(len(p)<span class="number">-1</span>, len(s)):</span><br><span class="line">            sCount[s[end]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sCount == pCount:</span><br><span class="line">                res.append(end-len(p)+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            start = end-len(p)+<span class="number">1</span></span><br><span class="line">            sCount[s[start]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sCount[s[start]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> sCount[s[start]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, m(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: p)</span><br><span class="line">            m[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>, count= p.length();</span><br><span class="line">        <span class="keyword">while</span>(right&lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//find a character in s that also appeared in p, then move right pointer and decrease the count</span></span><br><span class="line">            <span class="comment">//if a character is not in p, then the value will be negative</span></span><br><span class="line">            <span class="keyword">if</span>(m[s[right++]]-- &gt;= <span class="number">1</span>) --count; </span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) res.push_back(left); <span class="comment">//the starting index of the anagram</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            an anagram's size would be the same as p.length()</span></span><br><span class="line"><span class="comment">            therefore, if length is equal, then we should move left pointer toward right 1 step</span></span><br><span class="line"><span class="comment">            if the value of character key in map is greater or equal then 0, it means it's a character in p</span></span><br><span class="line"><span class="comment">            because in previous step we minus 1 for all characters, so if a character in s is exists in p, then the value in map is at least 0</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(right-left == p.length() &amp;&amp; m[s[left++]]++ &gt;= <span class="number">0</span>) ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/5yadmE" target="_blank" rel="noopener">https://goo.gl/5yadmE</a><br><a href="https://goo.gl/8XAyZH" target="_blank" rel="noopener">https://goo.gl/8XAyZH</a><br><a href="https://goo.gl/gT32uu" target="_blank" rel="noopener">https://goo.gl/gT32uu</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> two pointers </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>76. Minimum Window Substring</title>
      <link href="/2018/08/21/76-Minimum-Window-Substring/"/>
      <url>/2018/08/21/76-Minimum-Window-Substring/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>Example:</p><p>Input: S = “ADOBECODEBANC”, T = “ABC”<br>Output: “BANC”<br>Note:</p><p>If there is no such window in S that covers all characters in T, return the empty string “”.<br>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>create counter for target string, know how many for each char</li><li>walk through array with start, end pointers</li><li>use independent variable target_len to know if we have all char in t</li><li>when find s[end] is needed, subtract target_len</li><li>when target_len is 0, means current window contains every letter in t, check if it’s smaller than existed res</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s:str, t:str)</span> -&gt; str:</span></span><br><span class="line">target = Counter(t)</span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        target_len = len(t)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> target[s[end]] &gt; <span class="number">0</span>:</span><br><span class="line">                target_len -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            target[s[end]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> target_len == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> len(res) &gt; len(s[start:end+<span class="number">1</span>]):</span><br><span class="line">                    res = s[start:end+<span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                target[s[start]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> target[s[start]] &gt; <span class="number">0</span>:</span><br><span class="line">                    target_len += <span class="number">1</span></span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="Solution-C"><a href="#Solution-C" class="headerlink" title="Solution C++"></a>Solution C++</h2><p>Since we need to solve this problem in $O(n)$, so we can not use brute force or sorting. We can use a hash table with characters that appeared in T as key, and number of appearance as value.</p><ul><li>walk through T, store in map</li><li>walk through S. If meet a character <code>c</code> appeared in T, map[c]–. Keep going until we have a window that contains every character in T.</li><li>Move the left boundary of the window, skip characters that do not exist in T. Skip a character if it appears in S more that appears in T.<br>example:<br>S: aaaabb<br>T: ab</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T.size() &gt; S.size()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, count = <span class="number">0</span>, minLen = S.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.find(T[i]) != m.end()) ++m[T[i]];</span><br><span class="line">            <span class="keyword">else</span> m[T[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; S.size(); ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.find(S[right]) != m.end()) &#123; <span class="comment">//found a character appeared in both S and T</span></span><br><span class="line">                --m[S[right]];</span><br><span class="line">                <span class="keyword">if</span> (m[S[right]] &gt;= <span class="number">0</span>) ++count;</span><br><span class="line">                <span class="keyword">while</span> (count == T.size()) &#123; <span class="comment">//find a valid window that contains every characters in T</span></span><br><span class="line">                    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                        minLen = right - left + <span class="number">1</span>;</span><br><span class="line">                        res = S.substr(left, minLen);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (m.find(S[left]) != m.end()) &#123;</span><br><span class="line">                        ++m[S[left]]; <span class="comment">//s[left] is a char in T</span></span><br><span class="line">                        <span class="keyword">if</span> (m[S[left]] &gt; <span class="number">0</span>) --count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: t) <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">int</span> counter=t.size(), begin=<span class="number">0</span>, end=<span class="number">0</span>, d=INT_MAX, head=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]--&gt;<span class="number">0</span>) counter--; <span class="comment">//in t</span></span><br><span class="line">            <span class="keyword">while</span>(counter==<span class="number">0</span>)&#123; <span class="comment">//valid</span></span><br><span class="line">                <span class="keyword">if</span>(end-begin&lt;d)  d=end-(head=begin);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]++==<span class="number">0</span>) counter++;  <span class="comment">//make it invalid</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d==INT_MAX? <span class="string">""</span>:s.substr(head, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3:"></a>Solution 3:</h3><p>It’s the same template as <a href="https://goo.gl/AJ5Sw7" target="_blank" rel="noopener">https://goo.gl/AJ5Sw7</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: t)</span><br><span class="line">            <span class="built_in">map</span>[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> start= <span class="number">0</span>, end= <span class="number">0</span>, count= <span class="built_in">map</span>.size(), len= INT_MAX, head= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(end&lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(s[end]) != <span class="built_in">map</span>.end() )&#123;</span><br><span class="line">                <span class="comment">//can find this char in the dictionary, two strings both have this char</span></span><br><span class="line">                <span class="built_in">map</span>[s[end]]--;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[s[end]] == <span class="number">0</span>)</span><br><span class="line">                    count--;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.find(s[start]) != <span class="built_in">map</span>.end())&#123;</span><br><span class="line">                    <span class="built_in">map</span>[s[start]]++;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">map</span>[s[start]] &gt; <span class="number">0</span>)</span><br><span class="line">                        count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(len&gt; end-start)&#123;</span><br><span class="line">                    len= end- start;</span><br><span class="line">                    head= start;</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len == INT_MAX? res: s.substr(head, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/1JwyJD" target="_blank" rel="noopener">https://goo.gl/1JwyJD</a><br><a href="https://goo.gl/pAMsMh" target="_blank" rel="noopener">https://goo.gl/pAMsMh</a><br><a href="https://goo.gl/B6FoMj" target="_blank" rel="noopener">https://goo.gl/B6FoMj</a><br><a href="https://goo.gl/cHbo8L" target="_blank" rel="noopener">https://goo.gl/cHbo8L</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
            <tag> hash table </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>297. Serialize and Deserialize Binary Tree</title>
      <link href="/2018/08/21/297-Serialize-and-Deserialize-Binary-Tree/"/>
      <url>/2018/08/21/297-Serialize-and-Deserialize-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p>Example: </p><p>You may serialize the following tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure></p><p>as “[1,2,3,null,null,4,5]”<br>Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use preorder traversal to generate the string and create the tree.</p><ol><li><p>serialize<br>Use stringstream to build the string.<br>Traverse the Tree with preorder traversal<br>Insert empty node as ‘#’, separate the nodes between ‘ ‘.</p></li><li><p>deserialize<br>Since we use preorder to store the tree, use preorder to deserialize it.<br>idea is to use a queue to store all the nodes in data. The istringstream is already a queue and can help to separate string</p></li></ol><p>Store the tree as a string, use <code>,</code> to separate each node. Use <code>#</code> to mark it as empty node.</p><p>When deserialize, use a <code>global variable</code> to process the data. Because the right side of tree would pick up the rest after left side is processed.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example:</span><br><span class="line">-----</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="comment">#,#,3,4,#,#,5,#,#</span></span><br><span class="line">-----</span><br><span class="line"><span class="number">2</span>,<span class="comment">#,#,3,4,#,#,5,#,#</span></span><br><span class="line">-----</span><br><span class="line"><span class="comment">#,#,3,4,#,#,5,#,#</span></span><br><span class="line">-----</span><br><span class="line"><span class="comment">#,3,4,#,#,5,#,#</span></span><br><span class="line">-----</span><br><span class="line"><span class="number">3</span>,<span class="number">4</span>,<span class="comment">#,#,5,#,#</span></span><br><span class="line">-----</span><br><span class="line"><span class="number">4</span>,<span class="comment">#,#,5,#,#</span></span><br><span class="line">-----</span><br><span class="line"><span class="comment">#,#,5,#,#</span></span><br><span class="line">-----</span><br><span class="line"><span class="comment">#,5,#,#</span></span><br><span class="line">-----</span><br><span class="line"><span class="number">5</span>,<span class="comment">#,#</span></span><br><span class="line">-----</span><br><span class="line"><span class="comment">#,#</span></span><br><span class="line">-----</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">','</span>.join([str(root.val), self.serialize(root.left), self.serialize(root.right)])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        <span class="comment"># print("-----")</span></span><br><span class="line">        <span class="comment"># print(self.data)</span></span><br><span class="line">        <span class="keyword">if</span> self.data[<span class="number">0</span>] == <span class="string">"#"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        node = TreeNode(self.data[:self.data.find(<span class="string">","</span>)])</span><br><span class="line">        node.left = self.deserialize(self.data[self.data.find(<span class="string">","</span>)+<span class="number">1</span>:])</span><br><span class="line">        node.right = self.deserialize(self.data[self.data.find(<span class="string">","</span>)+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//searialize</span></span><br><span class="line">    <span class="comment">//Use stringstream to build the string. Traverse the Tree with preorder traversal. insert empty node as '#', separate the nodes between ' '</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//deserialize</span></span><br><span class="line">    <span class="comment">//idea is to use a queue to store all the nodes in data. The istringstream is already a queue and can help to separate string</span></span><br><span class="line">    <span class="comment">//still use preorder traversal</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        serialize(root, out);</span><br><span class="line">        <span class="keyword">return</span> out.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">ostringstream</span>&amp; out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            out &lt;&lt; root-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            serialize(root-&gt;left, out);</span><br><span class="line">            serialize(root-&gt;right, out);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">        root-&gt;left = deserialize(in);</span><br><span class="line">        root-&gt;right = deserialize(in);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure><p>time complexity: O(n)</p><p>reference:<br><a href="https://goo.gl/xoE4oD" target="_blank" rel="noopener">https://goo.gl/xoE4oD</a><br><a href="https://goo.gl/Gn3Uc2" target="_blank" rel="noopener">https://goo.gl/Gn3Uc2</a></p><h3 id="Solution-2-BFS"><a href="#Solution-2-BFS" class="headerlink" title="Solution 2 BFS:"></a>Solution 2 BFS:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        res+= to_string(root-&gt;val)+ <span class="string">" "</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode* tmp= q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!tmp) res+= <span class="string">"# "</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">                    res+= <span class="string">"# "</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    q.push(tmp-&gt;left);</span><br><span class="line">                    res+= to_string(tmp-&gt;left-&gt;val)+ <span class="string">" "</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                    res+= <span class="string">"# "</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    q.push(tmp-&gt;right);</span><br><span class="line">                    res+= to_string(tmp-&gt;right-&gt;val)+ <span class="string">" "</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[<span class="number">0</span>] == <span class="string">'#'</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tokens= helper(data, <span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">int</span> i= <span class="number">0</span>;</span><br><span class="line">        TreeNode *root= <span class="keyword">new</span> TreeNode(stoi(tokens[i++]));</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; newQ;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                TreeNode *tmp= q.front(); q.pop();</span><br><span class="line">                <span class="comment">//printf("queue front= %d\n", tmp-&gt;val);</span></span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">"#"</span>)</span><br><span class="line">                    tmp-&gt;left= <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp-&gt;left= <span class="keyword">new</span> TreeNode(stoi(tokens[i]));</span><br><span class="line">                    newQ.push(tmp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">"#"</span>)</span><br><span class="line">                    tmp-&gt;right= <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp-&gt;right= <span class="keyword">new</span> TreeNode(stoi(tokens[i]));</span><br><span class="line">                    newQ.push(tmp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            q= newQ;</span><br><span class="line">            <span class="comment">//printf("q size= %d\n", q.size());</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; helper(<span class="built_in">string</span> &amp;data, <span class="keyword">char</span> delimiter)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tokens;</span><br><span class="line">        <span class="built_in">string</span> token;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(getline(iss, token, delimiter))&#123;</span><br><span class="line">            tokens.push_back(token);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//for(auto s: tokens)</span></span><br><span class="line">        <span class="comment">//    cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>309. Best Time to Buy and Sell Stock with Cooldown</title>
      <link href="/2018/08/20/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/"/>
      <url>/2018/08/20/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><p>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<br>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)<br>Example:</p><p>Input: [1,2,3,0,2]<br>Output: 3<br>Explanation: transactions = [buy, sell, cooldown, buy, sell]</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The key of solving this question is to find out the dp equation.<br>(1) We have to <code>rest</code> before we <code>buy</code> and<br>(2) we have to <code>buy</code> before we <code>sell</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//use two sets of buy&amp; sell to check if there's cooldown</span></span><br><span class="line">        int buy(INT_MIN), sell(0), prev_sell(0), prev_buy(0);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price: prices)&#123;</span><br><span class="line">            prev_buy = buy; </span><br><span class="line">            buy = max(buy, prev_sell-price); <span class="comment">//</span></span><br><span class="line">            prev_sell = sell;</span><br><span class="line">            sell = max(sell, prev_buy+price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link href="/2018/08/20/121-Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/2018/08/20/121-Best-Time-to-Buy-and-Sell-Stock/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Example 1:<br>Input: [7, 1, 5, 3, 6, 4]<br>Output: 5</p><p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)<br>Example 2:<br>Input: [7, 6, 4, 3, 1]<br>Output: 0</p><p>In this case, no transaction is done, i.e. max profit = 0.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        low = nums[<span class="number">0</span>]</span><br><span class="line">        cur, res = <span class="number">0</span> , <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            cur = max(cur, num-low)</span><br><span class="line">            res = max(res, cur)</span><br><span class="line">            low = min(low, num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minp= prices[<span class="number">0</span>], res= INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; prices.size(); i++)&#123;</span><br><span class="line">            res= max(res, prices[i]- minp);</span><br><span class="line">            minp= min(minp, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res&gt;<span class="number">0</span>? res: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>67. Add Binary</title>
      <link href="/2018/08/20/67-Add-Binary/"/>
      <url>/2018/08/20/67-Add-Binary/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two binary strings, return their sum (also a binary string).</p><p>The input strings are both non-empty and contains only characters 1 or 0.</p><p>Example 1:</p><p>Input: a = “11”, b = “1”<br>Output: “100”<br>Example 2:</p><p>Input: a = “1010”, b = “1011”<br>Output: “10101”</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to start from the end of string and add every bit.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i= a.length()<span class="number">-1</span>, j= b.length()<span class="number">-1</span>, carry= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res= <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x= i&gt;= <span class="number">0</span> &amp;&amp; a[i--]== <span class="string">'1'</span>;</span><br><span class="line">            <span class="keyword">int</span> y= j&gt;= <span class="number">0</span> &amp;&amp; b[j--]== <span class="string">'1'</span>;</span><br><span class="line">            res= to_string((x+y+carry)%<span class="number">2</span>)+ res;</span><br><span class="line">            carry= (x+y+carry)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">            res= to_string(carry)+res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(max(m, n))$<br>space complexity: $O(1)$</p><p>reference:<br><a href="https://goo.gl/93GtDQ" target="_blank" rel="noopener">https://goo.gl/93GtDQ</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>283. Move Zeroes</title>
      <link href="/2018/08/20/283-Move-Zeroes/"/>
      <url>/2018/08/20/283-Move-Zeroes/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>Example:</p><p>Input: [0,1,0,3,12]<br>Output: [1,3,12,0,0]<br>Note:</p><p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use a pointer to store the position of zeros, another point to walk through the array.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p_zero= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</span><br><span class="line">                swap(nums[p_zero++], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>29. Divide Two Integers</title>
      <link href="/2018/08/20/29-Divide-Two-Integers/"/>
      <url>/2018/08/20/29-Divide-Two-Integers/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.</p><p>Return the quotient after dividing dividend by divisor.</p><p>The integer division should truncate toward zero.</p><p>Example 1:</p><p>Input: dividend = 10, divisor = 3<br>Output: 3<br>Example 2:</p><p>Input: dividend = 7, divisor = -3<br>Output: -2<br>Note:</p><p>Both dividend and divisor will be 32-bit signed integers.<br>The divisor will never be 0.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use bit manipulation to solve this problem. </p><p>Left shift the divisor and get the multiply of it. Also need to check the sign of two numbers<br>example: dividend=15, divisor=3<br>15= 3<em>4+3<br>3= 3</em>1+0</p><p>result= 4+1= 5</p><p>edge cases:</p><ul><li>divisor = 0;</li><li>dividend = INT_MIN and divisor = -1 (because abs(INT_MIN) = INT_MAX + 1).</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        use deduction to get the quotient. </span></span><br><span class="line"><span class="comment">        but deduct one by one is too slow, so we can use shifting to speed up the process</span></span><br><span class="line"><span class="comment">        ex:</span></span><br><span class="line"><span class="comment">        d1: 15, d2: 3</span></span><br><span class="line"><span class="comment">        shift d2 left to get multiply</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!divisor || (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = (dividend&gt; <span class="number">0</span> ^ divisor&gt;<span class="number">0</span>)? <span class="number">-1</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d1= <span class="built_in">labs</span>(dividend), d2= <span class="built_in">labs</span>(divisor);</span><br><span class="line">        <span class="keyword">while</span>(d1&gt;= d2)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp= d2;</span><br><span class="line">            <span class="keyword">int</span> multiply= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(d1&gt;= tmp&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">                tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                multiply&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            d1-= tmp;</span><br><span class="line">            res+= multiply;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res*sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(logn)$</p><p>reference:<br><a href="https://goo.gl/a5wA7D" target="_blank" rel="noopener">https://goo.gl/a5wA7D</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>621. Task Scheduler</title>
      <link href="/2018/08/19/621-Task-Scheduler/"/>
      <url>/2018/08/19/621-Task-Scheduler/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p><p>However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.</p><p>You need to return the least number of intervals the CPU will take to finish all the given tasks.</p><p>Example 1:<br>Input: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2<br>Output: 8<br>Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.<br>Note:<br>The number of tasks is in the range [1, 10000].<br>The integer n is in the range [0, 100].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>count max frequency</li><li>find how many tasks are max frequency</li><li>calculate the scheduled slots by max frequency. The idea here is we assume the tasks list is max_frequency tasks dominant</li><li>If the scheduled slots is smaller than len(tasks), it means there’re enough tasks to fill out the cooldown interval.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leastInterval</span><span class="params">(self, tasks: List[str], n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> len(tasks)</span><br><span class="line">        </span><br><span class="line">        count = Counter(tasks)</span><br><span class="line">        max_freq = max(count.values())</span><br><span class="line">        num_max_freq = sum(<span class="number">1</span> <span class="keyword">for</span> task, freq <span class="keyword">in</span> count.items() <span class="keyword">if</span> freq == max_freq)</span><br><span class="line">        </span><br><span class="line">        scheduled = (max_freq <span class="number">-1</span>) * (n+<span class="number">1</span>) + num_max_freq</span><br><span class="line">        <span class="keyword">return</span> max(len(tasks), scheduled)</span><br></pre></td></tr></table></figure><h3 id="Solution-Heap"><a href="#Solution-Heap" class="headerlink" title="Solution: Heap"></a>Solution: Heap</h3><p>The idea is to find the largest frequency element in the <code>heap</code>, schedule it in a round, then put it aside in a <code>tmp</code> (to not schedule it before cooldown time). </p><p>If one of the round we have no task in <code>heap</code> and nothing in <code>tmp</code> , it means no remaining task, no need to continue.</p><p>Otherwise, if no task in <code>heap</code> but have task in <code>tmp</code>, it means we have to wait for cooldown.</p><p>When end of a round, push the tasks in <code>tmp</code> back to <code>heap</code> for next round.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leastInterval</span><span class="params">(self, tasks: List[str], n: int)</span> -&gt; int:</span></span><br><span class="line">        count = Counter(tasks)</span><br><span class="line">        heap = [(-v, k) <span class="keyword">for</span> k, v <span class="keyword">in</span> count.items()]</span><br><span class="line">        heapify(heap)</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">                <span class="keyword">if</span> heap:</span><br><span class="line">                    v, k = heappop(heap)</span><br><span class="line">                    <span class="keyword">if</span> -v &gt; <span class="number">1</span>:</span><br><span class="line">                        tmp.append((v+<span class="number">1</span>, k))</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># all elements has been pop out from heap</span></span><br><span class="line">                <span class="comment"># but they still have remain taks keeping in tmp</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> heap <span class="keyword">and</span> <span class="keyword">not</span> tmp: </span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># end of a round, put the task back to heap</span></span><br><span class="line">            <span class="keyword">for</span> task <span class="keyword">in</span> tmp:</span><br><span class="line">                heappush(heap, task)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to count whether if we need extra idle slots.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">26</span>, <span class="number">0</span>); <span class="comment">//only 26 character</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: tasks) </span><br><span class="line">            <span class="built_in">map</span>[c - <span class="string">'A'</span>]++; <span class="comment">//count which task has the largest frequency</span></span><br><span class="line">        </span><br><span class="line">        sort(<span class="built_in">map</span>.begin(), <span class="built_in">map</span>.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max_val = <span class="built_in">map</span>[<span class="number">25</span>] - <span class="number">1</span>; <span class="comment">//last element do not need cool down</span></span><br><span class="line">        <span class="keyword">int</span> idle_slots = max_val * n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">24</span>; i &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[i] &gt; <span class="number">0</span>; i--) &#123; </span><br><span class="line">            <span class="comment">//already set up the largest one, so start at i=24</span></span><br><span class="line">            idle_slots -= min(<span class="built_in">map</span>[i], max_val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if idle slot &gt; 0, some of the task need extra. </span></span><br><span class="line">        <span class="comment">//idle slot &lt; 0, don't need idle slots</span></span><br><span class="line">        <span class="keyword">return</span> idle_slots &gt; <span class="number">0</span> ? idle_slots + tasks.size() : tasks.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time"></a>Second time</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123;</span><br><span class="line">        /*</span><br><span class="line">        idea: count how many extra idle slot needed.</span><br><span class="line">        1. count which task will be the most.</span><br><span class="line">        2. the last task do not need idle slot, so remember to deduct 1</span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        map&lt;int, int&gt; map;</span><br><span class="line">        </span><br><span class="line">        for(auto c: tasks)&#123;</span><br><span class="line">            map[c-&apos;A&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; after;</span><br><span class="line">        for(auto m: map)&#123;</span><br><span class="line">            after.push_back(m.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(after.begin(), after.end());</span><br><span class="line">        int max_val= after[after.size()-1]-1;</span><br><span class="line">        int idle_slot= n* max_val;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        for(int i= after.size()-2; i&gt;= 0; i--)&#123;</span><br><span class="line">            idle_slot-= min(after[i], max_val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return idle_slot &lt; 0? tasks.size(): idle_slot+tasks.size();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Third-time"><a href="#Third-time" class="headerlink" title="Third time:"></a>Third time:</h3><p>Use a vector to count every appeared character.<br>Sort the vector, it will be ascending order; therefore, the largest element would be in the last.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: tasks)</span><br><span class="line">            count[c-<span class="string">'A'</span>]++;</span><br><span class="line">            </span><br><span class="line">        sort(count.begin(), count.end());</span><br><span class="line">        <span class="keyword">int</span> idle= n* (count[<span class="number">25</span>]<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">24</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            idle-= min(count[i], count[<span class="number">25</span>]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> idle&gt;<span class="number">0</span> ? tasks.size()+idle: tasks.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/DaFYrA" target="_blank" rel="noopener">https://goo.gl/DaFYrA</a><br><a href="https://goo.gl/unPm4P" target="_blank" rel="noopener">https://goo.gl/unPm4P</a><br><a href="https://goo.gl/JhFQuh" target="_blank" rel="noopener">https://goo.gl/JhFQuh</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> greedy </tag>
            
            <tag> uber </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>253. Meeting Rooms II</title>
      <link href="/2018/08/19/253-Meeting-Rooms-II/"/>
      <url>/2018/08/19/253-Meeting-Rooms-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0, 30],[5, 10],[15, 20]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[7,10],[2,4]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea of solving this question is: whenever there is a start meeting, we need to add one room.</p><p>for example, we have meetings that span along time as follows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|_____|</span><br><span class="line">      |______|</span><br><span class="line">|________|</span><br><span class="line">        |_______|</span><br></pre></td></tr></table></figure></p><p>Then, the start time array and end time array after sorting appear like follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">||    ||</span><br><span class="line">     |   |   |  |</span><br></pre></td></tr></table></figure><p>We can use a map to store all the position that have <code>start</code> or <code>end</code>. If there’s a <code>start</code>, we increase <code>1</code> on that position, means that we need a conference room. On the other hand, we decrease <code>1</code> on <code>end</code>, denotes that we finish using a meeting room.</p><p>Then we can use a variable to store <code>current</code> using meeting room, and another variable to store the <code>peak</code> of using meeting rooms.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxroom= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">//to count</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> interval: intervals)&#123;</span><br><span class="line">            <span class="built_in">map</span>[interval.start]++;</span><br><span class="line">            <span class="built_in">map</span>[interval.end]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m: <span class="built_in">map</span>)&#123;</span><br><span class="line">            cur+= m.second;</span><br><span class="line">            maxroom= max(maxroom, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxroom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$, map use $O(logn)$ for insertion, and n elements.<br>space complexity: $O(n)$</p><h2 id="Solution-2-Heap"><a href="#Solution-2-Heap" class="headerlink" title="Solution 2 Heap"></a>Solution 2 Heap</h2><p>Thought process, always a good idea to sort meeting start time. When we go through each meeting, we want to find <code>the earliest ended</code> meeting so we can put another meeting after it.</p><p>We could then use a <code>min heap</code> to store the end time. When we see another <code>interval.start</code> ≥ <code>heap.peek()</code>, we know there’s a meeting already ended when <code>interval</code> meeting starts. So we can schedule the meeting after that.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMeetingRooms</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        print(intervals)</span><br><span class="line">        hq = [] <span class="comment"># only put end time </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> hq <span class="keyword">and</span> i[<span class="number">0</span>] &gt;= hq[<span class="number">0</span>]:</span><br><span class="line">                print(<span class="string">"cur heap: "</span>, hq)</span><br><span class="line">                print(<span class="string">"heap end: "</span>, hq[<span class="number">0</span>] , <span class="string">", interval start: "</span>, i[<span class="number">0</span>])</span><br><span class="line">                heapq.heapreplace(hq, i[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(hq, i[<span class="number">1</span>])</span><br><span class="line">        print(hq)</span><br><span class="line">        <span class="keyword">return</span> len(hq)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">[[0, 30], [0, 10], [3, 4], [5, 10], [6, 7], [15, 20], [30, 31]]</span><br><span class="line">cur heap:  [4, 30, 10]</span><br><span class="line">heap end:  4 , interval start:  5</span><br><span class="line">cur heap:  [7, 10, 10, 30]</span><br><span class="line">heap end:  7 , interval start:  15</span><br><span class="line">cur heap:  [10, 10, 20, 30]</span><br><span class="line">heap end:  10 , interval start:  30</span><br><span class="line">[10, 30, 20, 31]</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/TQuqvR" target="_blank" rel="noopener">https://goo.gl/TQuqvR</a><br><a href="https://goo.gl/H2uUhe" target="_blank" rel="noopener">https://goo.gl/H2uUhe</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>91. Decode Ways</title>
      <link href="/2018/08/19/91-Decode-Ways/"/>
      <url>/2018/08/19/91-Decode-Ways/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure></p><p>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Explanation: It could be decoded as “AB” (1 2) or “L” (12).<br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p><p>Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. basic case:</span><br><span class="line"> &quot;3&quot;-&gt; c, num_ways(&quot;3&quot;)= 1</span><br><span class="line"> &quot;&quot;-&gt; &quot;&quot;, num_ways(&quot;&quot;)= 1</span><br><span class="line"></span><br><span class="line">2. common cases:</span><br><span class="line"> &quot;12345&quot;, num_ways(&quot;2345&quot;)+num_ways(&quot;345&quot;)</span><br><span class="line"></span><br><span class="line"> &quot;27345&quot;, nums_ways(&quot;7345&quot;)</span><br><span class="line"></span><br><span class="line">3. exception:</span><br><span class="line"> &quot;011&quot;, num_ways(&quot;011&quot;)= 0</span><br></pre></td></tr></table></figure></p><p>Use a dp array of size n + 1 to store the subproblem solutions.<br>dp[0] means an empty string will have one way to decode.<br>dp[1] means the way to decode a string of size 1. </p><p>For other cases, check one digit(<code>dp[i-1]</code>) and two digit(<code>dp[i-2]</code>) combination and save the results along the way. In the end, dp[n] will be the end result.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># decode ways is determined by how many characters, so empty string should count as well</span></span><br><span class="line">        dp = [<span class="number">0</span>]* (len(s)+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span> <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">"0"</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(dp)):</span><br><span class="line">            num1 = int(s[i<span class="number">-1</span>:i])</span><br><span class="line">            num2 = int(s[i<span class="number">-2</span>:i])</span><br><span class="line">            <span class="keyword">if</span> num1 &gt; <span class="number">0</span> <span class="keyword">and</span> num1 &lt;= <span class="number">9</span>:</span><br><span class="line">                dp[i] += dp[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> num2 &gt;= <span class="number">10</span> <span class="keyword">and</span> num2 &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] += dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        use 1d dp array to sum up how many ways from beginning</span></span><br><span class="line"><span class="comment">        dp[i-1]: 1 digit: can not be zero </span></span><br><span class="line"><span class="comment">        dp[i-2]: 2 digits: can not exceed 26, digit of ten can not be zero</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> n= s.length();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">1</span>; <span class="comment">//empty string only one way to decode</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//since the dp equation needs dp[i-1] and dp[i-2] to calculate</span></span><br><span class="line">        <span class="comment">//we also need to init dp[1]</span></span><br><span class="line">        dp[<span class="number">1</span>]= s[<span class="number">0</span>] == <span class="string">'0'</span>? <span class="number">0</span>:<span class="number">1</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">2</span>; i&lt; dp.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1= stoi(s.substr(i<span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">            <span class="comment">//cout&lt;&lt;n1&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">int</span> n2= stoi(s.substr(i<span class="number">-2</span>, <span class="number">2</span>));</span><br><span class="line">            <span class="comment">//cout&lt;&lt;n2&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(n1&gt;= <span class="number">1</span> &amp;&amp; n1 &lt;= <span class="number">9</span>) dp[i]+= dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(n2&gt;= <span class="number">10</span> &amp;&amp; n2 &lt;= <span class="number">26</span>) dp[i]+= dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p><p>reference:<br><a href="https://leetcode.com/problems/decode-ways/discuss/253018/Python%3A-Easy-to-understand-explanation-bottom-up-dynamic-programming" target="_blank" rel="noopener">https://leetcode.com/problems/decode-ways/discuss/253018/Python%3A-Easy-to-understand-explanation-bottom-up-dynamic-programming</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>65. Valid Number</title>
      <link href="/2018/08/18/65-Valid-Number/"/>
      <url>/2018/08/18/65-Valid-Number/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Validate if a given string is numeric.</p><p>Some examples:<br>“0” =&gt; true<br>“ 0.1 “ =&gt; true<br>“abc” =&gt; false<br>“1 a” =&gt; false<br>“2e10” =&gt; true</p><p>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p><p>Update (2015-02-10):<br>The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This is a problem to let you discuss with interviewer and implement the detail. </p><ol><li>skip the leading whitespaces</li><li>check the positive or negative sign is valid. if there’re two ‘+’ or ‘-‘, it should be invalid.</li><li>To do so, simply skip the leading sign and count the number of digits and the number of points. A valid significand has no more than one point and at least one digit.</li><li>check if the exponent part is valid. We do this if the significand is followed by ‘e’. Simply skip the leading sign and count the number of digits. A valid exponent contain at least one digit.</li><li>skip the trailing whitespaces. We must reach the ending ‘\0’ if the string is a valid number.</li></ol><ul><li>White spaces: may have three cases</li></ul><ol><li>leading white spaces, skip it</li><li>trailing white space, skip it</li><li>white spaces in the middle of string, invalid number</li></ol><ul><li>Decimal point</li></ul><ol><li>can only appear once, but can show in any position. “.3”, “1.e2”, “1.”</li><li>can not showed after <code>e</code>. “1e.1”</li></ol><p>example that can use<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;0&quot;; // True</span><br><span class="line">string s2 = &quot; 0.1 &quot;; // True</span><br><span class="line">string s3 = &quot;abc&quot;; // False, not digit</span><br><span class="line">string s4 = &quot;1 a&quot;; // False, because white space in the middle</span><br><span class="line">string s5 = &quot;2e10&quot;; // True</span><br><span class="line"></span><br><span class="line">string s6 = &quot;-e10&quot;; // False</span><br><span class="line">string s7 = &quot; 2e-9 &quot;; // True</span><br><span class="line">string s8 = &quot;+e1&quot;; // False</span><br><span class="line">string s9 = &quot;1+e&quot;; // False</span><br><span class="line">string s10 = &quot; &quot;; // False</span><br><span class="line"></span><br><span class="line">string s11 = &quot;e9&quot;; // False</span><br><span class="line">string s12 = &quot;4e+&quot;; // False</span><br><span class="line">string s13 = &quot; -.&quot;; // False</span><br><span class="line">string s14 = &quot;+.8&quot;; // True</span><br><span class="line">string s15 = &quot; 005047e+6&quot;; // True</span><br><span class="line"></span><br><span class="line">string s16 = &quot;.e1&quot;; // False</span><br><span class="line">string s17 = &quot;3.e&quot;; // False</span><br><span class="line">string s18 = &quot;3.e1&quot;; // True</span><br><span class="line">string s19 = &quot;+1.e+5&quot;; // True</span><br><span class="line">string s20 = &quot; -54.53061&quot;; // True</span><br><span class="line"></span><br><span class="line">string s21 = &quot;. 1&quot;; // False</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//"1 1"is not valid, "0x11" is not valid, "." is not valid, "2e3.1" is not valid, "2e" is not valid,"1a" is not valid,"++1" is not valid</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// skip the whilespaces</span></span><br><span class="line">        <span class="keyword">while</span>(s[i] == <span class="string">' '</span>) i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check the significand</span></span><br><span class="line">        <span class="comment">// skip the sign if exist</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) i++; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n_nm= <span class="number">0</span>; <span class="comment">//how many digits</span></span><br><span class="line">        <span class="keyword">int</span> n_pt= <span class="number">0</span>; <span class="comment">//how many decimal points</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[i]) || s[i] == <span class="string">'.'</span>)</span><br><span class="line">            s[i++] == <span class="string">'.'</span> ? n_pt++:n_nm++;       </span><br><span class="line">        <span class="keyword">if</span>(n_pt&gt;<span class="number">1</span> || n_nm&lt;<span class="number">1</span>) <span class="comment">// no more than one point, at least one digit</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check the exponent if exist</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'e'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// skip the sign, " 005047e+6", it should also be true</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) i++; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> n_nm = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                n_nm++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n_nm&lt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip the trailing whitespaces</span></span><br><span class="line">        <span class="keyword">while</span>(s[i] == <span class="string">' '</span>)</span><br><span class="line">            i++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// must reach the ending 0 of the string</span></span><br><span class="line">        <span class="keyword">return</span> s[i]== <span class="string">'\0'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/qsSdzM" target="_blank" rel="noopener">https://goo.gl/qsSdzM</a><br><a href="https://goo.gl/s91yxH" target="_blank" rel="noopener">https://goo.gl/s91yxH</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>10. Regular Expression Matching</title>
      <link href="/2018/08/18/10-Regular-Expression-Matching/"/>
      <url>/2018/08/18/10-Regular-Expression-Matching/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</p><p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p><p>Note:</p><p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.<br>Example 1:</p><p>Input:<br>s = <code>&quot;aa&quot;</code><br>p = <code>&quot;a&quot;</code><br>Output: false<br>Explanation: “a” does not match the entire string <code>&quot;aa&quot;</code>.<br>Example 2:</p><p>Input:<br>s = <code>&quot;aa&quot;</code><br>p = <code>&quot;a*&quot;</code><br>Output: true<br>Explanation: ‘*’ means zero or more of the preceding element, <code>&#39;a&#39;</code>. Therefore, by repeating <code>&#39;a&#39;</code> once, it becomes <code>&quot;aa&quot;</code>.<br>Example 3:</p><p>Input:<br>s = <code>&quot;ab&quot;</code><br>p = <code>&quot;.*&quot;</code><br>Output: true<br>Explanation: “.<em>“ means “zero or more (</em>) of any character (.)”.<br>Example 4:</p><p>Input:<br>s = <code>&quot;aab&quot;</code><br>p = <code>&quot;c*a*b&quot;</code><br>Output: true<br>Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches <code>&quot;aab&quot;</code>.<br>Example 5:</p><p>Input:<br>s = <code>&quot;mississippi&quot;</code><br>p = <code>&quot;mis*is*p*.&quot;</code><br>Output: false</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>create dp array. dp[i][j] to be true if s[0..i) matches p[0..j)</p><ol><li><p>If p[j] == s[i] :  dp[i][j] = dp[i-1][j-1];<br>If the character on position j in string p is equal to the character on position i in string s.</p></li><li><p>If p[j] == ‘.’ : dp[i][j] = dp[i-1][j-1];<br>If the character on position j in string p is a ‘.’, it can match any character, so dp[i][j] follow dp[i-1][j-1].</p></li><li><p>If p[j] == ‘*’:<br>there are two sub conditions:</p><ol><li>if p[j-1] != s[i] : dp[i][j] = dp[i][j-2]  //in this case, $a*$ only counts as empty</li><li>if p[i-1] == s[i] or p[i-1] == ‘.’:<br>dp[i][j] = dp[i-1][j]    //in this case, $a*$ counts as multiple a<br>or dp[i][j] = dp[i][j-1] // in this case, $a*$ counts as single a<br>or dp[i][j] = dp[i][j-2] // in this case, $a*$ counts as empty</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        create dp array. dp[i][j] to be true if s[0..i) matches p[0..j)</span></span><br><span class="line"><span class="comment">        1. edge case</span></span><br><span class="line"><span class="comment">        2. dp array init</span></span><br><span class="line"><span class="comment">        3. </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//edge case, both NULL</span></span><br><span class="line">        <span class="keyword">if</span>(s.empty() &amp;&amp; p.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> r= s.length(), c= p.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(r+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(c+<span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]= <span class="literal">true</span>; <span class="comment">//both empty is true</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; c; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j] == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j<span class="number">-1</span>]) <span class="comment">//previous is the same, current is '*'</span></span><br><span class="line">                dp[<span class="number">0</span>][j+<span class="number">1</span>]= <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; c; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]== p[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>]= dp[i][j];</span><br><span class="line">                <span class="keyword">if</span>(p[j]== <span class="string">'.'</span>) dp[i+<span class="number">1</span>][j+<span class="number">1</span>]= dp[i][j]; <span class="comment">//ex: abc, ab.</span></span><br><span class="line">                <span class="keyword">if</span>(p[j]== <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p[j<span class="number">-1</span>] != <span class="string">'.'</span> &amp;&amp; p[j<span class="number">-1</span>] != s[i]) <span class="comment">//can not use special character to represent any word</span></span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>]= dp[i+<span class="number">1</span>][j<span class="number">-1</span>]; <span class="comment">//the same as </span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>]= (dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(mn)$<br>space complexity: $O(mn)$<br>reference:<br><a href="https://goo.gl/1yJRGK" target="_blank" rel="noopener">https://goo.gl/1yJRGK</a><br><a href="https://goo.gl/sFR26t" target="_blank" rel="noopener">https://goo.gl/sFR26t</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> apple </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>680. Valid Palindrome II</title>
      <link href="/2018/08/18/680-Valid-Palindrome-II/"/>
      <url>/2018/08/18/680-Valid-Palindrome-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.</p><p>Example 1:<br>Input: “aba”<br>Output: True<br>Example 2:<br>Input: “abca”<br>Output: True<br>Explanation: You could delete the character ‘c’.<br>Note:<br>The string will only contain lowercase characters a-z. The maximum length of the string is 50000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Can delete at most one character, implies that the string will not be valid if we delete one character and it does not make a valid palindrome.</p><ol><li>Design a subfunction to check the string is valid or not. </li><li>When we encounter two different characters, we can choose to delete one of them, and check if it’s valid or not.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isPalin</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                <span class="keyword">return</span> isPalin(i+<span class="number">1</span>, j) <span class="keyword">or</span> isPalin(i, j<span class="number">-1</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l= <span class="number">0</span>, r= s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r])</span><br><span class="line">                <span class="keyword">return</span> isValid(s, l+<span class="number">1</span>, r) || isValid(s, l, r<span class="number">-1</span>);</span><br><span class="line">            l++; r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++; right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution:"></a>Solution:</h3><p>Similar idea as above</p><ol><li>remove the character if <code>s[i]</code> and <code>s[j]</code> are different</li><li>compare the two strings with their <code>reversed</code> string. Note that we only need to compare the rest of string.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                one = s[i:j] <span class="comment"># remove s[j]</span></span><br><span class="line">                two = s[i+<span class="number">1</span>:j+<span class="number">1</span>] <span class="comment"># remove s[i]</span></span><br><span class="line">                <span class="keyword">return</span> one == one[::<span class="number">-1</span>] <span class="keyword">or</span> two == two[::<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>314. Binary Tree Vertical Order Traversal</title>
      <link href="/2018/08/17/314-Binary-Tree-Vertical-Order-Traversal/"/>
      <url>/2018/08/17/314-Binary-Tree-Vertical-Order-Traversal/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, return the vertical order traversal of its nodes’ values. (ie, from top to bottom, column by column).</p><p>If two nodes are in the same row and column, the order should be from left to right.</p><p>Examples 1:</p><p>Input: [3,9,20,null,null,15,7]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> /\</span><br><span class="line">/  \</span><br><span class="line">9  20</span><br><span class="line">   /\</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [9],</span><br><span class="line">  [3,15],</span><br><span class="line">  [20],</span><br><span class="line">  [7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Examples 2:</p><p>Input: [3,9,8,4,0,1,7]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   /\</span><br><span class="line">  /  \</span><br><span class="line">  9   8</span><br><span class="line"> /\  /\</span><br><span class="line">/  \/  \</span><br><span class="line">4  01   7</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [4],</span><br><span class="line">  [9],</span><br><span class="line">  [3,0,1],</span><br><span class="line">  [8],</span><br><span class="line">  [7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Examples 3:</p><p>Input: [3,9,8,4,0,1,7,null,null,null,2,5] (0’s right child is 2 and 1’s left child is 5)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   /\</span><br><span class="line">  /  \</span><br><span class="line">  9   8</span><br><span class="line"> /\  /\</span><br><span class="line">/  \/  \</span><br><span class="line">4  01   7</span><br><span class="line">   /\</span><br><span class="line">  /  \</span><br><span class="line">  5   2</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [4],</span><br><span class="line">  [9,5],</span><br><span class="line">  [3,0,1],</span><br><span class="line">  [8,2],</span><br><span class="line">  [7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to construct a map with the vertical index and every value of that level. By using map, we can get ascending index by default.</p><p>Then we use BFS to walk though the tree. If it’s a left node, then the index should be smaller. If it’s a right node, the index should be greater.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode*&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, root&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp= q.front(); q.pop();</span><br><span class="line">            <span class="built_in">map</span>[tmp.first].push_back(tmp.second-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(tmp.second-&gt;left) q.push(&#123;tmp.first<span class="number">-1</span>, tmp.second-&gt;left&#125;);</span><br><span class="line">            <span class="keyword">if</span>(tmp.second-&gt;right) q.push(&#123;tmp.first+<span class="number">1</span>, tmp.second-&gt;right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m: <span class="built_in">map</span>)</span><br><span class="line">            res.push_back(m.second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity:<br>map use $O(log n)$ for insertion, total is n node, so $O(nlogn)$</p><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/5278930.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5278930.html</a><br><a href="https://goo.gl/yfKXEE" target="_blank" rel="noopener">https://goo.gl/yfKXEE</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>301. Remove Invalid Parentheses</title>
      <link href="/2018/08/17/301-Remove-Invalid-Parentheses/"/>
      <url>/2018/08/17/301-Remove-Invalid-Parentheses/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p><p>Note: The input string may contain letters other than the parentheses ( and ).</p><p>Example 1:</p><p>Input: “()())()”<br>Output: [“()()()”, “(())()”]<br>Example 2:</p><p>Input: “(a)())()”<br>Output: [“(a)()()”, “(a())()”]<br>Example 3:</p><p>Input: “)(“<br>Output: [“”]</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question can ask in interview:</p><ol><li>what is invalid, if contains other characters or digits, will it be valid?</li><li>Input type, string</li><li>Output type, should be vector<string></string></li><li>time/space complexity restriction</li></ol><p>Solution:<br>We’re trying to make it valid, we need to remove a ‘)’. And should remove the extra parentheses by <code>counting redundant</code> left or right parentheses. Then use dfs to check if the string is valid or not.</p><ol><li><p>Check input is valid or not by using variable to count left parentheses and right parentheses.<br><code>count(&#39;(&#39;) &gt;= count(&#39;)&#39;)</code>, i&lt; n-1. Before reach to end of string, count of left parentheses should always be greater or equal than right parentheses. Because if right has more then left, it would be invalid.<br><code>count(&#39;(&#39;) == count(&#39;)&#39;)</code>, i == n-1. When reach to the end, if it’s a valid string, number of left == number of right.</p></li><li><p>Use dfs to check “if we remove extra parentheses, the string is valid or not”. </p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; removeInvalidParentheses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        1. count redundant left or right parentheses</span></span><br><span class="line"><span class="comment">        2. dfs to find after remove parentheses, the string would be valid or not. One thing to notice is to skip duplicate character</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i= <span class="number">0</span>, l= <span class="number">0</span>, r= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l == <span class="number">0</span>) r++;</span><br><span class="line">                <span class="keyword">else</span> l--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        helper(s, <span class="number">0</span>, l, r, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> cnt1, <span class="keyword">int</span> cnt2, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s)) res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//check duplicate</span></span><br><span class="line">            <span class="keyword">if</span>(i != start &amp;&amp; s[i] == s[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt1 &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">'('</span>) </span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i)+ s.substr(i+<span class="number">1</span>), i, cnt1<span class="number">-1</span>, cnt2, res);</span><br><span class="line">            <span class="keyword">if</span>(cnt2 &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">')'</span>)</span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i)+ s.substr(i+<span class="number">1</span>), i, cnt1, cnt2<span class="number">-1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">')'</span>)</span><br><span class="line">                right++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(right&gt; left) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(2 ^ {l+r})$<br>space complexity: $O((l+r)^2)$ ~ $O(n^2)$</p><p>reference:<br><a href="https://goo.gl/KgYdwq" target="_blank" rel="noopener">https://goo.gl/KgYdwq</a><br><a href="https://goo.gl/p61yqa" target="_blank" rel="noopener">https://goo.gl/p61yqa</a></p><h3 id="second-time"><a href="#second-time" class="headerlink" title="second time:"></a>second time:</h3><p>The same idea.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; removeInvalidParentheses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. count how many invalid '(' or ')'</span></span><br><span class="line"><span class="comment">        2. use dfs to get different output</span></span><br><span class="line"><span class="comment">            isValid function</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> i= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left== <span class="number">0</span>)</span><br><span class="line">                    right++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(res, s, left, right, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span> tmp, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(tmp))</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt; tmp.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//skip duplicate element</span></span><br><span class="line">            <span class="keyword">if</span>(i != start &amp;&amp; tmp[i] == tmp[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;<span class="number">0</span> &amp;&amp; tmp[i]== <span class="string">'('</span>) </span><br><span class="line">                dfs(res, tmp.substr(<span class="number">0</span>, i)+ tmp.substr(i+<span class="number">1</span>), left<span class="number">-1</span>, right, i);</span><br><span class="line">            <span class="keyword">if</span>(right&gt;<span class="number">0</span> &amp;&amp; tmp[i] == <span class="string">')'</span>) </span><br><span class="line">                dfs(res, tmp.substr(<span class="number">0</span>, i)+ tmp.substr(i+<span class="number">1</span>), left, right<span class="number">-1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>, i= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)</span><br><span class="line">                left--;</span><br><span class="line">            <span class="keyword">if</span>(left&lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> bfs </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>273. Integer to English Words</title>
      <link href="/2018/08/16/273-Integer-to-English-Words/"/>
      <url>/2018/08/16/273-Integer-to-English-Words/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.</p><p>Example 1:</p><p>Input: 123<br>Output: “One Hundred Twenty Three”<br>Example 2:</p><p>Input: 12345<br>Output: “Twelve Thousand Three Hundred Forty Five”<br>Example 3:</p><p>Input: 1234567<br>Output: “One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven”<br>Example 4:</p><p>Input: 1234567891<br>Output: “One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One”</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question can ask in interview:</p><ol><li>What format is the integer? contain dots? floating number?</li><li>Input type, integer/string</li><li>Output type, should be string</li><li>time/space complexity restriction</li></ol><p>The hint from this question, <code>Group the number by thousands (3 digits). Write a helper function that takes a number less than 1000 and convert just that chunk to words.</code></p><ol><li><p>use some example to demonstrate how to set up the array.<br>1~19, all different words<br>20~99, different words too<br>100~999, can be constructed by previous two with <code>&quot;Hundred&quot;</code>.<br>greater than 1000, can use previous three with <code>&quot;Thousand&quot;, &quot;Million&quot;, &quot;Billion&quot;</code>.</p></li><li><p>After creating the dictionary, we can try to divide the question into smaller pieces. Since the result with <code>num</code> greater than 1000 are similar, we can use a helper function to construct strings less than 1000.</p></li><li><p>Dealing with <code>num</code> greater than thousands. The pattern is to divide <code>num</code> with 1000 multiple times and counting how many 1000 we have divided.</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; less_than_20= &#123;<span class="string">""</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>, <span class="string">"Four"</span>, <span class="string">"Five"</span>, <span class="string">"Six"</span>, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>, <span class="string">"Ten"</span>, <span class="string">"Eleven"</span>, <span class="string">"Twelve"</span>, <span class="string">"Thirteen"</span>, <span class="string">"Fourteen"</span>, <span class="string">"Fifteen"</span>, <span class="string">"Sixteen"</span>, <span class="string">"Seventeen"</span>, <span class="string">"Eighteen"</span>, <span class="string">"Nineteen"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tens= &#123;<span class="string">""</span>, <span class="string">"Ten"</span>, <span class="string">"Twenty"</span>, <span class="string">"Thirty"</span>, <span class="string">"Forty"</span>, <span class="string">"Fifty"</span>, <span class="string">"Sixty"</span>, <span class="string">"Seventy"</span>, <span class="string">"Eighty"</span>, <span class="string">"Ninety"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; thousands= &#123;<span class="string">""</span>, <span class="string">"Thousand"</span>, <span class="string">"Million"</span>, <span class="string">"Billion"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Zero"</span>;</span><br><span class="line">        <span class="keyword">int</span> i= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res= <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(num&gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">1000</span> != <span class="number">0</span>)</span><br><span class="line">                res= helper(num%<span class="number">1000</span>)+ thousands[i]+ <span class="string">" "</span>+ res;</span><br><span class="line">            num /= <span class="number">1000</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.substr(<span class="number">0</span>, res.find_last_not_of(<span class="string">' '</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">return</span> less_than_20[num]+ <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">return</span> tens[num/<span class="number">10</span>]+ <span class="string">" "</span>+ helper(num%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> less_than_20[num/<span class="number">100</span>]+ <span class="string">" Hundred "</span>+ helper(num%<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(1)$, because the length of <code>num</code> is limited and the loop will be called constant number of times.</p><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/4772780.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4772780.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> amazon </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>17. Letter Combinations of a Phone Number</title>
      <link href="/2018/08/16/17-Letter-Combinations-of-a-Phone-Number/"/>
      <url>/2018/08/16/17-Letter-Combinations-of-a-Phone-Number/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a digit string, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p><p>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This question is a relatively easy backtracking problem. The idea of backtracking is to find the end result of a branch, then move back one step and search for other results. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dict&#123;<span class="string">" "</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> tmp= <span class="string">""</span>;</span><br><span class="line">        helper(res, tmp, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span> tmp, <span class="built_in">string</span>&amp; digits, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; digits.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num= digits[index]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: dict[num])&#123;</span><br><span class="line">            helper(res, tmp+c, digits, index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/o1acNw" target="_blank" rel="noopener">https://goo.gl/o1acNw</a><br><a href="https://goo.gl/HBP2MX" target="_blank" rel="noopener">https://goo.gl/HBP2MX</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>152. Maximum Product Subarray</title>
      <link href="/2018/08/15/152-Maximum-Product-Subarray/"/>
      <url>/2018/08/15/152-Maximum-Product-Subarray/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a <code>res</code> variable to denote the maximum result to return. In addition, two variables <code>imin</code> and <code>imax</code> for to store current maximum value and current minimum value. Why do we need to store the minimum value? The smallest product, which is the largest in the negative sense could become the maximum when being multiplied by a negative number.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># Since the number could be negative, nums[-1] might be negative as well</span></span><br><span class="line">        <span class="comment"># Keep tracking the smallest product and largest product in array</span></span><br><span class="line">        <span class="comment"># If nums[i] is negative, we swap the (min_p, max_p) because smaller number*negative would be bigger than large number*negative</span></span><br><span class="line">        <span class="comment"># ex: 3*-1 &gt; 10*-1</span></span><br><span class="line">        </span><br><span class="line">        min_p, max_p, res = nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span>:</span><br><span class="line">                min_p, max_p = max_p, min_p</span><br><span class="line">            min_p = min(min_p*nums[i], nums[i])</span><br><span class="line">            max_p = max(max_p*nums[i], nums[i])</span><br><span class="line">            res = max(res, max_p)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// store the result that is the max we have found so far</span></span><br><span class="line">        <span class="keyword">int</span> r = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// imax/imin stores the max/min product of</span></span><br><span class="line">        <span class="comment">// subarray that ends with the current number A[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, imax = r, imin = r; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// multiplied by a negative makes big number smaller, small number bigger</span></span><br><span class="line">            <span class="comment">// so we redefine the extremums by swapping them</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>)</span><br><span class="line">                swap(imax, imin);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// max/min product for the current number is either the current number itself</span></span><br><span class="line">            <span class="comment">// or the max/min by the previous number times the current one</span></span><br><span class="line">            imax = max(nums[i], imax * nums[i]);</span><br><span class="line">            imin = min(nums[i], imin * nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// the newly computed max value is a candidate for our global result</span></span><br><span class="line">            r = max(r, imax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/Eu7Vb4" target="_blank" rel="noopener">https://goo.gl/Eu7Vb4</a><br><a href="https://goo.gl/fDPzc1" target="_blank" rel="noopener">https://goo.gl/fDPzc1</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>516. Longest Palindromic Subsequence</title>
      <link href="/2018/08/13/516-Longest-Palindromic-Subsequence/"/>
      <url>/2018/08/13/516-Longest-Palindromic-Subsequence/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p><p>Example 1:<br>Input: “bbbab”<br>Output: 4<br>One possible longest palindromic subsequence is “bbbb”.</p><p>Example 2:<br>Input: “cbbd”<br>Output: 2<br>One possible longest palindromic subsequence is “bb”.</p><h3 id="Solution1-DFS"><a href="#Solution1-DFS" class="headerlink" title="Solution1 DFS:"></a>Solution1 DFS:</h3><p>Use a 2D array and two pointers to check longest palindromic subsequence. memo[i][j] means the longest palindromic subsequence on between <code>i</code> and <code>j</code>.</p><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b b b a b</span><br><span class="line">  i     j</span><br></pre></td></tr></table></figure></p><p>if s[i] == s[j], the length would increase 2.<br><code>memo[start][end]= helper(s, start+1, end-1, memo)+2;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b b b a b</span><br><span class="line">  i   j</span><br></pre></td></tr></table></figure><p>if s[i]!= s[j], the length should be <code>max(memo[i+1][j], memo[i][j-1])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n= s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> helper(s, <span class="number">0</span>, n<span class="number">-1</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo[start][end] != <span class="number">-1</span>) <span class="keyword">return</span> memo[start][end];</span><br><span class="line">        <span class="keyword">if</span>(start&gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s[start] == s[end])</span><br><span class="line">            memo[start][end]= helper(s, start+<span class="number">1</span>, end<span class="number">-1</span>, memo)+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            memo[start][end]= max(helper(s, start+<span class="number">1</span>, end, memo), helper(s, start, end<span class="number">-1</span>, memo));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> memo[start][end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2-DP"><a href="#Solution2-DP" class="headerlink" title="Solution2 DP:"></a>Solution2 DP:</h3><p>Similar to previous idea. Use a pointer <code>i</code> to denote the length that we traverse right now. Another pointer <code>j</code> to denote check the palindromic substring.</p><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b b b a b</span><br><span class="line">  j i</span><br></pre></td></tr></table></figure></p><p><code>dp[i][j]= dp[i-1][j+1]+2</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b b b a b</span><br><span class="line">  j   i</span><br></pre></td></tr></table></figure><p><code>dp[i][j]= max(dp[i-1][j], dp[i][j+1])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.length(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            dp[i][i]= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= i<span class="number">-1</span>; j&gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">                    dp[i][j]= dp[i<span class="number">-1</span>][j+<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]= max(dp[i<span class="number">-1</span>][j], dp[i][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>647. Palindromic Substrings</title>
      <link href="/2018/08/13/647-Palindromic-Substrings/"/>
      <url>/2018/08/13/647-Palindromic-Substrings/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string, your task is to count how many palindromic substrings in this string.</p><p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p><p>Example 1:<br>Input: “abc”<br>Output: 3<br>Explanation: Three palindromic strings: “a”, “b”, “c”.<br>Example 2:<br>Input: “aaa”<br>Output: 6<br>Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.<br>Note:<br>The input string length won’t exceed 1000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a variable <code>count</code> to calculate the total palindrome substring.<br>One thing to notice about palindrome string is that, the center of a palindrome string could be character or middle of two characters. Therefore, we need to check twice.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            expand(s, i, i);</span><br><span class="line">            expand(s, i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s[left]==s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^2)$<br>space complexity: O(1)<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> pure storage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>227. Basic Calculator II</title>
      <link href="/2018/08/11/227-Basic-Calculator-II/"/>
      <url>/2018/08/11/227-Basic-Calculator-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p><p>Example 1:</p><p>Input: “3+2*2”<br>Output: 7<br>Example 2:</p><p>Input: “ 3/2 “<br>Output: 1<br>Example 3:</p><p>Input: “ 3+5 / 2 “<br>Output: 5<br>Note:</p><p>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use <code>stack</code> to store every signed numbers in it. One thing to notice is that we need to use a variable to denote positive of first digit. Whenever we reach to <code>second operator</code>, we can definitely push the previous result into stack. For example:</p><p> -1+2 : the sign was initially <code>-</code>. When we meet second operator <code>+</code>, we can push <code>-1</code> into the stack. then set sign to <code>+</code></p><p>Therefore, we need a <code>stack</code> to store calculated value. <code>sign</code> to store a sign that waited to be calculated. <code>tmp</code> is current value.</p><p>Example: <code>3+5/2</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       init-&gt; 0 -&gt; 1  -&gt; 2 -&gt; 3   -&gt; 4(reach to end)</span><br><span class="line">stack:  []-&gt;  []-&gt; [3]-&gt;[3]-&gt;[3,5]-&gt;[3,5] become [3,2] after calculation</span><br><span class="line">sign:   + -&gt;  + -&gt; +  -&gt; + -&gt; /   -&gt; 2</span><br><span class="line">tmp:    0 -&gt;  3 -&gt; 0  -&gt; 5 -&gt; 0   -&gt; 0</span><br><span class="line"></span><br><span class="line">Then, just add up value in stack.</span><br><span class="line">3+2 = 5</span><br></pre></td></tr></table></figure></p><p><img src="IMG_5534.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># when we reach to second operator, calculate result and push to stack</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># might have multiple digits number</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        stk = []</span><br><span class="line">        sign = <span class="string">'+'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">                num = num*<span class="number">10</span> + int(s[i])</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> <span class="string">'+-*/'</span> <span class="keyword">or</span> i == len(s)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="string">'+'</span>: <span class="comment"># sign is the previously not yet calculated sign</span></span><br><span class="line">                    stk.append(num)</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="string">'-'</span>:</span><br><span class="line">                    stk.append(-num)</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="string">'*'</span>:</span><br><span class="line">                    num *= stk.pop()</span><br><span class="line">                    stk.append(num)</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="string">'/'</span>:</span><br><span class="line">                    num = int(stk.pop()/num)</span><br><span class="line">                    stk.append(num)</span><br><span class="line">                sign = s[i]</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> sum(stk)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">char</span> sign= <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>, tmp= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">                tmp= <span class="number">10</span>*tmp+s[i]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; !<span class="built_in">isspace</span>(s[i]) || i == s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'-'</span>)</span><br><span class="line">                    stk.push(-tmp);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'+'</span>)</span><br><span class="line">                    stk.push(tmp);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> num;</span><br><span class="line">                    <span class="keyword">if</span>(sign == <span class="string">'*'</span>)</span><br><span class="line">                        num= stk.top()*tmp;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        num= stk.top()/tmp;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign= s[i];</span><br><span class="line">                tmp= <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            res+= stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)<br>space complexity: O(n)</p><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/4601208.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4601208.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> uber </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>332. Reconstruct Itinerary</title>
      <link href="/2018/08/10/332-Reconstruct-Itinerary/"/>
      <url>/2018/08/10/332-Reconstruct-Itinerary/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p><p>Note:</p><p>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.<br>All airports are represented by three capital letters (IATA code).<br>You may assume all tickets form at least one valid itinerary.<br>Example 1:<br>Input: tickets = <code>[[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</code><br>Output: <code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</code></p><p>Example 2:<br>Input: tickets = <code>[[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</code><br>Output: <code>[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code><br>Explanation: Another possible reconstruction is <code>[&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>. But it is larger in lexical order.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We can first show an example with the graph.</p><p><img style="width: 50%; height: 50%" src="1.jpg"></p><p>After we have the graph, we can use DFS to solve the problem. We traverse down a path until it stuck, then we go back to previous node and traverse other paths of previous node.</p><p>We can use <code>unordered_map</code> to store the paths. <code>multiset</code> can use to help sorting the incoming tickets in smaller lexical order.<br><img style="width: 50%; height: 50%" src="2.jpg"></p><p>The step goes like this:</p><ol><li>construct the graph</li><li>start visit “JFK”</li><li>if “JFK” has paths, then start from the first one, and erase it. To erase it is because we visit the path, if we come back later, we’ll then traverse the second path from “JFK”.</li><li>The result is in reverse order. </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findItinerary(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; tickets) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: tickets)&#123;</span><br><span class="line">            <span class="built_in">map</span>[n.first].insert(n.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="built_in">map</span>, <span class="string">"JFK"</span>, res);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; <span class="built_in">map</span>, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">map</span>[s].size())&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp= *<span class="built_in">map</span>[s].begin();</span><br><span class="line">            <span class="built_in">map</span>[s].erase(<span class="built_in">map</span>[s].begin());</span><br><span class="line">            dfs(<span class="built_in">map</span>, tmp, res);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/xDedxi" target="_blank" rel="noopener">https://goo.gl/xDedxi</a><br><a href="http://www.cnblogs.com/grandyang/p/5183210.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5183210.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
            <tag> yelp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>207. Course Schedule</title>
      <link href="/2018/08/08/207-Course-Schedule/"/>
      <url>/2018/08/08/207-Course-Schedule/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p><p>Example 1:</p><p>Input: 2, [[1,0]]<br>Output: true<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0. So it is possible.<br>Example 2:</p><p>Input: 2, [[1,0],[0,1]]<br>Output: false<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0, and to take course 0 you should<br>             also have finished course 1. So it is impossible.<br>Note:</p><p>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p><h3 id="Solution1-DFS"><a href="#Solution1-DFS" class="headerlink" title="Solution1 DFS:"></a>Solution1 DFS:</h3><p>We can use DFS to solve this question. From above example, <code>Input: 2, [[1,0],[0,1]]</code>, we can see that if the graph contains a <code>cycle</code>, we can not finish all the courses. </p><p>First of all, let’s see how we generate a graph. we can use a <code>vector&lt;unordered_set&gt;</code> to do so. Every index stores the courses that can be taken after finish the <code>index</code> course. </p><p>Second, we need to traverse the graph and find if there’s any cycle. The idea of finding a cycle is to record the nodes that we’ve already traversed on current path. If we encounter a node that we’ve already traversed, then it must contains a cycle in the graph. After current path is checked, reset it to <code>false</code>.</p><p>Third, another visited array to store which node is already traversed. help to save time.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. create a graph for dfs</span></span><br><span class="line"><span class="comment">        2. if we can find a cycle, then we can not finish all courses. </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: prerequisites)&#123;</span><br><span class="line">            graph[n.second].insert(n.first); </span><br><span class="line">            <span class="comment">// [1, 0]: To take course 1 you should have finished course 0</span></span><br><span class="line">            <span class="comment">// So we need an edge from 0-&gt;1, because we need to get to 0 then 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(numCourses, <span class="literal">false</span>), onpath(numCourses, <span class="literal">false</span>); <span class="comment">//the second one is to check cycle</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dfscycle(graph, visited, onpath, i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfscycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; onpath, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[index]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//already traversed this node in big picture</span></span><br><span class="line">        </span><br><span class="line">        onpath[index]= visited[index]= <span class="literal">true</span>; <span class="comment">//set to true denoted that we traverse this node</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor: graph[index])&#123; <span class="comment">//check all next level as node index is the prerequist</span></span><br><span class="line">            <span class="keyword">if</span>(onpath[neighbor] || dfscycle(graph, visited, onpath, neighbor)) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//1. onpath[neighbor] is true, means that this neighbor is already in this subpath, so we have a cycle</span></span><br><span class="line">            <span class="comment">//2. dfscycle, go further and find a cycle in subpath</span></span><br><span class="line">        &#125;</span><br><span class="line">        onpath[index]= <span class="literal">false</span>; <span class="comment">//reset to false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Python DFS</strong></p><ol><li>if node v has not been visited, then mark it as 0.</li><li>if node v is being visited, then mark it as -1. If we find a vertex marked as -1 in DFS, then their is a ring.</li><li>if node v has been visited, then mark it as 1. If a vertex was marked as 1, then no ring contains v or its successors.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># Idea is to find if there's any cycle </span></span><br><span class="line">        visited = [<span class="number">0</span>] * numCourses</span><br><span class="line">        <span class="comment"># state of visited: </span></span><br><span class="line">        <span class="comment"># 0,  not visited</span></span><br><span class="line">        <span class="comment"># 1,  visited</span></span><br><span class="line">        <span class="comment"># -1, visting</span></span><br><span class="line">        graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[y].append(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.dfsCycle(graph, visited, i):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfsCycle</span><span class="params">(self, graph, visited, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># change the state to visiting, if we somehow get to this node again, then there's a cycle</span></span><br><span class="line">        visited[i] = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> course <span class="keyword">in</span> graph[i]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.dfsCycle(graph, visited, course):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        visited[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="Solution2-BFS"><a href="#Solution2-BFS" class="headerlink" title="Solution2 BFS:"></a>Solution2 BFS:</h3><p>The BFS solution is to apply topological sort. The idea is to check if every node does not have any indegree after we traverse the graph. </p><p>First, we need to generate a graph. Pretty similar to DFS solution above.<br>Second, we need a indegree array, size is numCourses. Add one if a course have prerequisite.<br>  After calculated the indegree, some of the node might not have any indegree, so we start to traverse from them.</p><p>Third, BFS. If a node’s indegree becomes <code>zero</code>, then we need to push it into the queue.<br>Finally, check indegree array to see if all zero.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. calculate indegree for every node</span></span><br><span class="line"><span class="comment">        2. BFS, push every node with indegree 0 into queue</span></span><br><span class="line"><span class="comment">        3. check if every node has indegree 0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(numCourses);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: prerequisites)&#123;</span><br><span class="line">            indegree[n.first]++;</span><br><span class="line">            graph[n.second].push_back(n.first);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp= q.front(); q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; !graph[tmp].empty() &amp;&amp; i&lt; graph[tmp].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--indegree[graph[tmp][i]] == <span class="number">0</span>) q.push(graph[tmp][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution-Python-BFS-topological-sort"><a href="#Solution-Python-BFS-topological-sort" class="headerlink" title="Solution Python BFS topological sort"></a>Solution Python BFS topological sort</h2><p>The idea is to build graph, then add every node’s prerequisites to a set.<br>Notice the <code>graph</code> is build to find if I complete course <code>y</code> then what I could move next <code>x</code>.<br>But the <code>todo</code> is if want to take <code>x</code>, what <code>y</code> should take.</p><ol><li>Walk through the node that have no prerequisites first</li><li>Remove node <code>n</code> from other’s <code>todo</code>, because node <code>n</code> is completed. </li><li>When we find other node <code>X</code> have <code>todo</code> with length <code>0</code>, ie: nothing else to do after complete node <code>n</code>, then we add <code>X</code> to queue.</li><li>Finally, check if <code>todo</code> is empty. If it’s not, then there’s a cycle.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        todo = &#123;i: set() <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses)&#125; </span><br><span class="line">        graph = defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> prerequisites:</span><br><span class="line">            todo[i].add(j)</span><br><span class="line">            graph[j].add(i)</span><br><span class="line">        q = deque([])</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> todo.items():</span><br><span class="line">            <span class="keyword">if</span> len(v) == <span class="number">0</span>:</span><br><span class="line">                q.append(k)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            n = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[n]:</span><br><span class="line">                todo[i].remove(n)</span><br><span class="line">                <span class="keyword">if</span> len(todo[i]) == <span class="number">0</span>:</span><br><span class="line">                    q.append(i)</span><br><span class="line">            todo.pop(n)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> todo</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://www.youtube.com/watch?v=zkTOIVUdW-I" target="_blank" rel="noopener">https://www.youtube.com/watch?v=zkTOIVUdW-I</a><br><a href="https://goo.gl/iN1qG3" target="_blank" rel="noopener">https://goo.gl/iN1qG3</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
            <tag> topological sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>402. Remove K Digits</title>
      <link href="/2018/08/02/402-Remove-K-Digits/"/>
      <url>/2018/08/02/402-Remove-K-Digits/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.</p><p>Note:<br>The length of num is less than 10002 and will be ≥ k.<br>The given num does not contain any leading zero.<br>Example 1:</p><p>Input: num = “1432219”, k = 3<br>Output: “1219”<br>Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.<br>Example 2:</p><p>Input: num = “10200”, k = 1<br>Output: “200”<br>Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.<br>Example 3:</p><p>Input: num = “10”, k = 2<br>Output: “0”<br>Explanation: Remove all the digits from the number and it is left with nothing which is 0.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question to ask:</p><ol><li>what to output if there’s no digits left?</li><li>Are there any character other than digits?</li><li>Output type</li><li></li></ol><p>Use a string as a stack, push_back every digit that is smaller than <code>res.back()</code>. </p><p>example:<br>num: “12311421”<br>k: 3</p><p>1<br>12<br>123<br>11<br>111<br>1114<br>1112<br>11121</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res= <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n= num.length(), keep= n-k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: num)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k &amp;&amp; res.size() &amp;&amp; res.back()&gt; c)&#123;</span><br><span class="line">                <span class="comment">//if 1st digit is greater than second digit, it will get remove too</span></span><br><span class="line">                res.pop_back();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        res.resize(keep); <span class="comment">//if only 1 digit and remove 1 digit, then resize res to 0</span></span><br><span class="line">        <span class="keyword">while</span>(!res.empty() &amp;&amp; res[<span class="number">0</span>] == <span class="string">'0'</span>) res.erase(res.begin());</span><br><span class="line">        <span class="keyword">return</span> res.empty()? <span class="string">"0"</span>: res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/8fQRQR" target="_blank" rel="noopener">https://goo.gl/8fQRQR</a><br><a href="http://www.cnblogs.com/grandyang/p/5883736.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5883736.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>767. Reorganize String</title>
      <link href="/2018/08/02/767-Reorganize-String/"/>
      <url>/2018/08/02/767-Reorganize-String/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.</p><p>If possible, output any possible result.  If not possible, return the empty string.</p><p>Example 1:</p><p>Input: S = “aab”<br>Output: “aba”<br>Example 2:</p><p>Input: S = “aaab”<br>Output: “”<br>Note:</p><p>S will consist of lowercase letters and have length in range [1, 500].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>When we first see this problem, we should use an example to walk through it, and we can see that we need to know what character has the greatest occurrence in the string.</p><ol><li>Use an unordered_map to count occurrence</li><li>Use priority queue to store the occurrence, it will automatically sort it. </li><li>Put the character into the result string, take <code>2 different character</code> at a time, this can ensure the outcome will not have same adjacent character.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reorganizeString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. count the frequency of each char</span></span><br><span class="line"><span class="comment">        2. put into priority queue</span></span><br><span class="line"><span class="comment">        3. the top 2 elements in queue must be the most frequently element, put them into result string first</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: S)</span><br><span class="line">            <span class="built_in">map</span>[c]++;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: <span class="built_in">map</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n.second&gt; (S.length()+<span class="number">1</span>)/<span class="number">2</span>) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">//Pigeonhole principal </span></span><br><span class="line">            q.push(&#123;n.second, n.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(q.size()&gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp1= q.top(); q.pop();</span><br><span class="line">            <span class="keyword">auto</span> tmp2= q.top(); q.pop();</span><br><span class="line">            res.push_back(tmp1.second);</span><br><span class="line">            res.push_back(tmp2.second);</span><br><span class="line">            <span class="keyword">if</span>(--tmp1.first &gt; <span class="number">0</span>) q.push(tmp1);</span><br><span class="line">            <span class="keyword">if</span>(--tmp2.first &gt; <span class="number">0</span>) q.push(tmp2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!q.empty())</span><br><span class="line">            res.push_back(q.top().second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The goal is to first exhaust the most-frequent chars. We build a frequency dict of the letters in the string. We push all the letters into a max heap together with their <code>-ve</code> frequencies (max heap: high-freq letters are towards the top of the heap)<br>We pop two letters at a time from the heap, add them to our result string, decrement their frequencies and push them back into heap. Why do we have to pop two items/letters at a time you’re wondering? Because if we only pop one at a time, we will keep popping and pushing the same letter over and over again if that letter has a freq greater than 1. Hence by popping two at time, adding them to result, decrementing their freq and finally pushing them back into heap, we guranatee that we are always alternating between letters.</p><p>For example: for the string <code>s = aab</code><br>The freq dict will be: <code>d = {&quot;a&quot;: 2, &quot;b&quot;:1}</code><br>And the heap: <code>h = [(-2, &quot;a&quot;), (-1, &quot;b&quot;)]</code></p><p>After the first iteration:<br><code>h = [(-1, &quot;a&quot;)]</code><br>and so on…<br>Edge Case:</p><p>NOTE [1]</p><ul><li>Since we are always popping two items at a time, we will definitely run into an out of bounds error if we have an odd number of unique items in the given string. To avoid this, we need to make sure our heap at least has two items at any given time. We achive this by running our main logic inside a while len(heap) &gt; 1 instead of a while heap</li></ul><p>NOTE [2]</p><ul><li>Again if the there is an odd number of unique letters in the string, there will be one last item/letter remaining in the heap when our loop terminates. Hence we need to examine that last item:</li><li>If the last item has a freq greater than 1: -&gt; then return “” becasue we can’t escape having the same letter repeated contigiously.</li><li>else if the item has freq = 1, we pop it, add it to our result and we’re done.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorganizeString</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> d:</span><br><span class="line">                <span class="comment"># we want max heap</span></span><br><span class="line">                d[c] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[c] = <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Use Max heap to store</span></span><br><span class="line">        hq = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">            heapq.heappush(hq, (v, k))</span><br><span class="line">        </span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="comment"># we want to make the string separate by two characters, so pop out two each turn</span></span><br><span class="line">        <span class="keyword">while</span> len(hq) &gt; <span class="number">1</span>:</span><br><span class="line">            f1, c1 = heapq.heappop(hq)</span><br><span class="line">            f2, c2 = heapq.heappop(hq)</span><br><span class="line">            res+= str(c1+c2)</span><br><span class="line">            <span class="keyword">if</span> f1+<span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">                heapq.heappush(hq, (f1+<span class="number">1</span>, c1))</span><br><span class="line">            <span class="keyword">if</span> f2+<span class="number">1</span> != <span class="number">0</span>:</span><br><span class="line">                heapq.heappush(hq, (f2+<span class="number">1</span>, c2))</span><br><span class="line">        <span class="keyword">if</span> len(hq):</span><br><span class="line">            <span class="comment"># still 1 (freq, character) pair left</span></span><br><span class="line">            f1, c1 = heapq.heappop(hq)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> f1 &lt; <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += str(c1)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Solution-Sorting"><a href="#Solution-Sorting" class="headerlink" title="Solution - Sorting"></a>Solution - Sorting</h3><ol><li>count letter appearance</li><li>find the letter with most frequent.</li><li>If the most frequent letter is over half of string, then return <code>&quot;&quot;</code></li><li>put the letter into <code>even</code> index number (0, 2, 4 …) char array</li><li>put the letter into <code>odd</code> index number (1, 3, 5 …) char array</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorganizeString</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        counter = collections.Counter(S)</span><br><span class="line">        i, res, n = <span class="number">0</span>, [<span class="keyword">None</span>] * len(S), len(S)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> sorted(counter, key = counter.get, reverse = <span class="keyword">True</span>):</span><br><span class="line">            <span class="keyword">if</span> counter[k] &gt; n // <span class="number">2</span> + (n % <span class="number">2</span>): <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(counter[k]):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= n: i = <span class="number">1</span></span><br><span class="line">                print(i, k)</span><br><span class="line">                res[i] = k; i += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> greedy </tag>
            
            <tag> uber </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>452. Minimum Number of Arrows to Burst Balloons</title>
      <link href="/2018/08/02/452-Minimum-Number-of-Arrows-to-Burst-Balloons/"/>
      <url>/2018/08/02/452-Minimum-Number-of-Arrows-to-Burst-Balloons/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p><p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p><p>Example:</p><p>Input:<br><code>[[10,16], [2,8], [1,6], [7,12]]</code></p><p>Output:<br>2</p><p>Explanation:<br>One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The question is saying that we have many balloons, which might overlap, and how many arrows make them burst.<br>Take the example from question, the graph would look like this.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    ---(2,8)---            ---(10,16)---</span><br><span class="line">  ---(1,6)---       ---(7,12)---</span><br><span class="line">|-------------------------------------------|</span><br></pre></td></tr></table></figure><p>From the graph, it’s easy to come out with the answer that we need two arrows. So let’s transfer it to code.</p><ol><li>We need to sort the input <code>points</code>, and we can use STL sorting directly. Since the STL sorting pairs will sort the first element in advance, if the first element are equal, then it’ll sort based on second element.</li><li>We can see that if the <code>end</code> value overlaps other’s <code>start</code> value, we can use one arrow to burst them.</li><li>If a balloon’s <code>start</code> is greater than current <code>end</code> value, then we need a new arrow.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(points.begin(), points.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">1</span>, end= points[<span class="number">0</span>].second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; points.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i].first&lt;= end)</span><br><span class="line">                <span class="comment">//can cover ith balloon</span></span><br><span class="line">                end= min(end, points[i].second);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//can not use previous arrow to shot current balloon, need new arrow</span></span><br><span class="line">                res++;</span><br><span class="line">                end= points[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>reference:<br><a href="http://www.cnblogs.com/grandyang/p/6050562.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/6050562.html</a><br><a href="https://goo.gl/oBHFYw" target="_blank" rel="noopener">https://goo.gl/oBHFYw</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>763. Partition Labels</title>
      <link href="/2018/08/01/763-Partition-Labels/"/>
      <url>/2018/08/01/763-Partition-Labels/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p><p>Example 1:<br>Input: S = “ababcbacadefegdehijhklij”<br>Output: [9,7,8]<br>Explanation:<br>The partition is “ababcbaca”, “defegde”, “hijhklij”.<br>This is a partition so that each letter appears in at most one part.<br>A partition like “ababcbacadefegde”, “hijhklij” is incorrect, because it splits S into less parts.<br>Note:</p><p>S will have length in range [1, 500].<br>S will consist of lowercase letters (‘a’ to ‘z’) only.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>Use an unordered_map to store the last position of occurred character.</li><li>Traverse the array, remember the maximum of last position for every showing character.</li><li>If current position is the last position of a character, then make a cut.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; partitionLabels(<span class="built_in">string</span> S) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; S.length(); i++)</span><br><span class="line">            <span class="built_in">map</span>[S[i]]= i;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> last= <span class="number">0</span>, start= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; S.length(); i++)&#123;</span><br><span class="line">            last= max(last, <span class="built_in">map</span>[S[i]]);</span><br><span class="line">            <span class="keyword">if</span>(i == last)&#123;</span><br><span class="line">                <span class="comment">//find a cutting point where this character will not appear in the folowing string anymore</span></span><br><span class="line">                res.push_back(i- start+<span class="number">1</span>);</span><br><span class="line">                start= i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/8654822.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/8654822.html</a><br><a href="https://goo.gl/HRrkCn" target="_blank" rel="noopener">https://goo.gl/HRrkCn</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>232. Implement Queue using Stacks</title>
      <link href="/2018/08/01/232-Implement-Queue-using-Stacks/"/>
      <url>/2018/08/01/232-Implement-Queue-using-Stacks/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Implement the following operations of a queue using stacks.</p><p>push(x) – Push element x to the back of queue.<br>pop() – Removes the element from in front of queue.<br>peek() – Get the front element.<br>empty() – Return whether the queue is empty.<br>Example:</p><p>MyQueue queue = new MyQueue();</p><p>queue.push(1);<br>queue.push(2);<br>queue.peek();  // returns 1<br>queue.pop();   // returns 1<br>queue.empty(); // returns false<br>Notes:</p><p>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.<br>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.<br>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This question is basically showing the understanding of data structure. We can use two stacks to help while we <code>push</code> into the stack. If you face this question in a interview, start with the difference with <code>queue(FIFO)</code> and <code>stack(FILO)</code>. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            tmp.push(stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.push(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!tmp.empty())&#123;</span><br><span class="line">            stk.push(tmp.top());</span><br><span class="line">            tmp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp= stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>Time complexity:<br>push: $O(n)$, pop: $O(1)$, peek: $O(1)$, isEmpty: $O(1)$<br>Space Complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/4fv6iQ" target="_blank" rel="noopener">https://goo.gl/4fv6iQ</a><br><a href="https://goo.gl/KqsRJT" target="_blank" rel="noopener">https://goo.gl/KqsRJT</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> microsoft </tag>
            
            <tag> apple </tag>
            
            <tag> stack </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>439. Ternary Expression Parser</title>
      <link href="/2018/08/01/439-Ternary-Expression-Parser/"/>
      <url>/2018/08/01/439-Ternary-Expression-Parser/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively).</p><p>Note:</p><p>The length of the given string is ≤ 10000.<br>Each number will contain only one digit.<br>The conditional expressions group right-to-left (as usual in most languages).<br>The condition will always be either T or F. That is, the condition will never be a digit.<br>The result of the expression will always evaluate to either a digit 0-9, T or F.<br>Example 1:</p><p>Input: <code>&quot;T?2:3&quot;</code></p><p>Output: <code>&quot;2&quot;</code></p><p>Explanation: If true, then result is 2; otherwise result is 3.<br>Example 2:</p><p>Input: <code>&quot;F?1:T?4:5&quot;</code></p><p>Output: <code>&quot;4&quot;</code></p><p>Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   &quot;(F ? 1 : (T ? 4 : 5))&quot;                   &quot;(F ? 1 : (T ? 4 : 5))&quot;</span><br><span class="line">-&gt; &quot;(F ? 1 : 4)&quot;                 or       -&gt; &quot;(T ? 4 : 5)&quot;</span><br><span class="line">-&gt; &quot;4&quot;                                    -&gt; &quot;4&quot;</span><br></pre></td></tr></table></figure></p><p>Example 3:<br>Input: <code>&quot;T?T?F:5:3&quot;</code><br>Output: <code>&quot;F&quot;</code></p><p>Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   &quot;(T ? (T ? F : 5) : 3)&quot;                   &quot;(T ? (T ? F : 5) : 3)&quot;</span><br><span class="line">-&gt; &quot;(T ? F : 3)&quot;                 or       -&gt; &quot;(T ? F : 5)&quot;</span><br><span class="line">-&gt; &quot;F&quot;                                    -&gt; &quot;F&quot;</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">parseTernary</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= expression.length()<span class="number">-1</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">char</span> c= expression[i]; <span class="comment">//current condition</span></span><br><span class="line">            <span class="keyword">if</span>(!stk.empty() &amp;&amp; stk.top() == <span class="string">'?'</span>)&#123;</span><br><span class="line">                stk.pop(); <span class="comment">//pop out the '?'</span></span><br><span class="line">                <span class="keyword">char</span> first= stk.top();</span><br><span class="line">                stk.pop(); <span class="comment">//pop out first digit</span></span><br><span class="line">                stk.pop(); <span class="comment">//pop out ':'</span></span><br><span class="line">                <span class="keyword">char</span> second= stk.top();</span><br><span class="line">                stk.top()= (c== <span class="string">'T'</span>)? first: second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stk.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="number">1</span>, stk.top());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/jKfet6" target="_blank" rel="noopener">https://goo.gl/jKfet6</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>255. Verify Preorder Sequence in Binary Search Tree</title>
      <link href="/2018/08/01/255-Verify-Preorder-Sequence-in-Binary-Search-Tree/"/>
      <url>/2018/08/01/255-Verify-Preorder-Sequence-in-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.</p><p>You may assume each number in the sequence is unique.</p><p>Consider the following binary search tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure></p><p>Example 1:</p><p>Input: <code>[5,2,6,1,3]</code><br>Output: false<br>Example 2:</p><p>Input: <code>[5,2,1,3,6]</code><br>Output: true<br>Follow up:<br>Could you do it using only constant space complexity?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>Walk through the preorder traversal, <code>left subtree value &lt; root&#39;s value &lt; right subtree&#39;s value</code></li><li>We can see that, <code>root value&lt; upcoming right value in the array</code></li><li>If we know the root value, we can use it to determine whether if upcoming value is valid. So we use a <code>lower</code> to denote the lower_bound, which is also the root value, of the tree.</li><li>Use a stack to store the array from <code>root</code> to <code>left subtree</code>, whenever reach a node has greater value, pop value out of stack. Then store the last pop out value as lower bound.</li></ol><p><img src="255.png" width="50%" height="50%"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Push 50</span><br><span class="line">Push 17 </span><br><span class="line">Push 9</span><br><span class="line">(read 14, 14 &gt; 9)</span><br><span class="line">Pop 9 (lower bound = 9)</span><br><span class="line">Push 14</span><br><span class="line">Push 12</span><br><span class="line">(read 23, 23 &gt; 12)</span><br><span class="line">Pop 12</span><br><span class="line">Pop 14</span><br><span class="line">Pop 17 (lower bound = 17)</span><br><span class="line">Push 23</span><br><span class="line">(read 76, 76 &gt; 23)</span><br><span class="line">Pop 23</span><br><span class="line">Pop 50 (lowerbound = 50)</span><br><span class="line">Push 76</span><br><span class="line">Push 54</span><br><span class="line">(read 72, 72 &gt; 54)</span><br><span class="line">Pop 54 (lower bound = 54)</span><br><span class="line">Push 72</span><br><span class="line">Push 67</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> lower_bound= INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: preorder)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&lt; lower_bound)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; n&gt; stk.top())&#123;</span><br><span class="line">                lower_bound= stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>131. Palindrome Partitioning</title>
      <link href="/2018/07/30/131-Palindrome-Partitioning/"/>
      <url>/2018/07/30/131-Palindrome-Partitioning/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of s.</p><p>Example:</p><p>Input: “aab”<br>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This is a similar backtracking problem. For this kind of question, we’ll use a <code>helper</code> function to help us check every possible sequence meet the requirement or not. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. a sub function to check is palindrome or not</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        helper(res, tmp, s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp, <span class="built_in">string</span> s, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start== s.length())&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ispalin(s, start, i))&#123;</span><br><span class="line">                tmp.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">                helper(res, tmp, s, i+<span class="number">1</span>);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ispalin</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(start&lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start++] != s[end--])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n*n!)</p><p>reference:<br><a href="https://goo.gl/bBS1Eh" target="_blank" rel="noopener">https://goo.gl/bBS1Eh</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> uber </tag>
            
            <tag> pure storage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>77. Combinations</title>
      <link href="/2018/07/30/77-Combinations/"/>
      <url>/2018/07/30/77-Combinations/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p>Example:</p><p>Input: n = 4, k = 2<br>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This is a very basic backtracking problem. We can use a helper function to do the work. The only input is <code>start</code>, which denotes where is current position in the <code>1...n</code> sequence.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        use backtracking, when a temp vector&lt;int&gt; have size k, store then backtracking</span></span><br><span class="line"><span class="comment">        another input is start pos.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        helper(res, tmp, n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k== <span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt;= n; i++)&#123;</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">            helper(res, tmp, n, k<span class="number">-1</span>, i+<span class="number">1</span>);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>306. Additive Number</title>
      <link href="/2018/07/30/306-Additive-Number/"/>
      <url>/2018/07/30/306-Additive-Number/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Additive number is a string whose digits can form additive sequence.</p><p>A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p><p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.</p><p>Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p><p>Example 1:</p><p>Input: “112358”<br>Output: true<br>Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.<br>             1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8<br>Example 2:</p><p>Input: “199100199”<br>Output: true<br>Explanation: The additive sequence is: 1, 99, 100, 199.<br>             1 + 99 = 100, 99 + 100 = 199<br>Follow up:<br>How would you handle overflow for very large input integers?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>think about how to devide the string. it should be three part.</li><li>need a sub function for add string.</li><li>a sub function to check if three strings can form additive sequence.</li></ol><p>draw a graph to help understand and test.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAdditiveNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. think about how to devide the string. it should be three part.</span></span><br><span class="line"><span class="comment">        2. need a sub function for add string.</span></span><br><span class="line"><span class="comment">        3. a sub function to check if three strings can form additive sequence.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= num.length()/<span class="number">2</span>; i++)&#123; <span class="comment">//start from 1 is because substr is [0, i)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;= (num.length()-i)/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(check(num.substr(<span class="number">0</span>, i), num.substr(i, j), num.substr(i+j))) <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2, <span class="built_in">string</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.length()&gt; <span class="number">1</span> &amp;&amp; num1[<span class="number">0</span>] == <span class="string">'0'</span> || num2.length()&gt; <span class="number">1</span> &amp;&amp; num2[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">string</span> sum = add(num1, num2);</span><br><span class="line">        <span class="keyword">if</span>(sum == num3) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//can not divide num3 to sum because length of sum is larger, return false</span></span><br><span class="line">        <span class="comment">//num3 does not contain equal string of sum in itself, return false</span></span><br><span class="line">        <span class="keyword">if</span>(sum.length() &gt;= num3.length() || num3.substr(<span class="number">0</span>, sum.length()) != sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//recursively find following string</span></span><br><span class="line">            <span class="keyword">return</span> check(num2, sum, num3.substr(sum.length()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. start from right to left, then reverse the string</span></span><br><span class="line"><span class="comment">        2. make sure the carry is added</span></span><br><span class="line"><span class="comment">        3. use (char - '0') to calculate digits</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> sum= <span class="number">0</span>, carry= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n= num1.length()<span class="number">-1</span>, m= num2.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;= <span class="number">0</span> ||m &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            sum= carry+ (n&gt;= <span class="number">0</span> ? num1[n--]-<span class="string">'0'</span>: <span class="number">0</span>)+ (m&gt;= <span class="number">0</span>? num2[m--]-<span class="string">'0'</span>: <span class="number">0</span>);</span><br><span class="line">            res.push_back(sum%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">            carry= sum/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry) res.push_back(carry+ <span class="string">'0'</span>);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/eQGcxW" target="_blank" rel="noopener">https://goo.gl/eQGcxW</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> epic system </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note-Docker</title>
      <link href="/2018/07/29/note-Docker/"/>
      <url>/2018/07/29/note-Docker/</url>
      <content type="html"><![CDATA[<p>Docker presents in the entire software development workflow, but mainly use in deployment.<br><img src="img1.png" alt=""></p><p>Dockerfile: describe the dependency<br>create docker image<br>run-time instance of docker image<br>docker hub: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a><br>reference:<br><a href="https://www.youtube.com/user/dockerrun" target="_blank" rel="noopener">https://www.youtube.com/user/dockerrun</a><br><a href="https://www.udemy.com/understanding-docker-performing-selenium-automation/" target="_blank" rel="noopener">https://www.udemy.com/understanding-docker-performing-selenium-automation/</a></p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>89. Gray Code</title>
      <link href="/2018/07/29/89-Gray-Code/"/>
      <url>/2018/07/29/89-Gray-Code/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p><p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p><p>Example 1:</p><p>Input: 2<br>Output: [0,1,3,2]<br>Explanation:<br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2</p><p>For a given n, a gray code sequence may not be uniquely defined.<br>For example, [0,2,3,1] is also a valid gray code sequence.</p><p>00 - 0<br>10 - 2<br>11 - 3<br>01 - 1<br>Example 2:</p><p>Input: 0<br>Output: [0]<br>Explanation: We define the gray code sequence to begin with 0.<br>             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.<br>             Therefore, for n = 0 the gray code sequence is [0].</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>So we start with the <code>k-1</code>th bit from the right. We first do not do anything to it. See we have already initialized a 32-bit bitset (which is essentially a boolean array) with all <code>0</code>s. Without doing anything to this bit, we call the <code>helper</code> function to do the next task with <code>k+1</code> that is to do the next bit after it. It goes on till we reach the <code>zero</code>th bit. We now have bitset containing the bits we selected at those positions. NOW, we backtrack. Next up after calling helper is, you see, we do a flip. So we flip the 0 and make it a 1 or vice versa and we do the same operation again. We choose. We explore. We unchoose.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;32&gt; bits;</span><br><span class="line">        helper(res, bits, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;&amp; bits, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k== <span class="number">0</span>) res.push_back(bits.to_ulong());</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            helper(res, bits, k<span class="number">-1</span>); <span class="comment">//get 0000 0000 first</span></span><br><span class="line">            bits.flip(k<span class="number">-1</span>);   <span class="comment">//change to 0000 0001</span></span><br><span class="line">            helper(res, bits, k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/VBu5Bc" target="_blank" rel="noopener">https://goo.gl/VBu5Bc</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>784. Letter Case Permutation</title>
      <link href="/2018/07/29/784-Letter-Case-Permutation/"/>
      <url>/2018/07/29/784-Letter-Case-Permutation/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.</p><p>Examples:<br>Input: S = “a1b2”<br>Output: <code>[&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</code></p><p>Input: S = “3z4”<br>Output: <code>[&quot;3z4&quot;, &quot;3Z4&quot;]</code></p><p>Input: S = “12345”<br>Output: <code>[&quot;12345&quot;]</code><br>Note:</p><p>S will be a string with length at most 12.<br>S will consist only of letters or digits.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>use toupper and tolower function in c++</li><li>backtracking function(int start, res, string)</li><li>for every character in S, determine if it’s number or letter</li><li>backtrack the string</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCasePermutation(<span class="built_in">string</span> S) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(res, S, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == s.length())&#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c= s[pos]; <span class="comment">//initial character</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            helper(res, s, pos+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            helper(res, s, pos+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isupper</span>(c))&#123; <span class="comment">//1A</span></span><br><span class="line">                s[pos]= <span class="built_in">tolower</span>(s[pos]); <span class="comment">//change to 1a</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//1a</span></span><br><span class="line">                s[pos]= <span class="built_in">toupper</span>(s[pos]); <span class="comment">//change to 1A</span></span><br><span class="line">            &#125;</span><br><span class="line">            helper(res, s, pos+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="http://www.cplusplus.com/reference/cctype/isdigit/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/cctype/isdigit/</a><br><a href="https://goo.gl/NCcQDz" target="_blank" rel="noopener">https://goo.gl/NCcQDz</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> yelp </tag>
            
            <tag> east </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>401. Binary Watch</title>
      <link href="/2018/07/29/401-Binary-Watch/"/>
      <url>/2018/07/29/401-Binary-Watch/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p><p>Each LED represents a zero or one, with the least significant bit on the right.</p><p><img src="401.jpg" alt=""></p><p>For example, the above binary watch reads “3:25”.</p><p>Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p><p>Example:</p><p>Input: n = 1<br>Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]<br>Note:<br>The order of output does not matter.<br>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.<br>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>We can use backtracking to solve this problem. </p><ol><li>Think <code>hours</code> and <code>minutes</code> as a combined array.</li><li>Like a combination problem. If we want to pick <code>n</code> elements from <code>hours</code> and <code>minutes</code>, we will pick <code>n-i</code> elements from <code>minutes</code> while we pick <code>i</code> elements from <code>hours</code>.</li></ol><ul><li>example: if n= 2:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&quot;3:00&quot;,&quot;5:00&quot;,&quot;9:00&quot;,&quot;1:01&quot;,&quot;1:02&quot;, ...]`</span><br><span class="line"> 1+2:00 ,1+4:00,1+8:00, 1:01</span><br><span class="line">                        i=4(equal to hour.size())</span><br><span class="line">                        generate minute then call helper again</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hour = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>&#125;, minute = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; readBinaryWatch(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(res, make_pair(<span class="number">0</span>, <span class="number">0</span>), num, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; time, <span class="keyword">int</span> num, <span class="keyword">int</span> start_point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(to_string(time.first) +  (time.second &lt; <span class="number">10</span> ?  <span class="string">":0"</span> : <span class="string">":"</span>) + to_string(time.second));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start_point; i &lt; hour.size() + minute.size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (i &lt; hour.size()) &#123;    </span><br><span class="line">                time.first += hour[i];</span><br><span class="line">                <span class="keyword">if</span> (time.first &lt; <span class="number">12</span>)     helper(res, time, num - <span class="number">1</span>, i + <span class="number">1</span>);     <span class="comment">// "hour" should be less than 12.</span></span><br><span class="line">                time.first -= hour[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;     </span><br><span class="line">                time.second += minute[i - hour.size()];</span><br><span class="line">                <span class="keyword">if</span> (time.second &lt; <span class="number">60</span>)    helper(res, time, num - <span class="number">1</span>, i + <span class="number">1</span>);     <span class="comment">// "minute" should be less than 60.</span></span><br><span class="line">                time.second -= minute[i - hour.size()];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> backtracking </tag>
            
            <tag> bit manipulation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>186. Reverse Words in a String II</title>
      <link href="/2018/07/27/186-Reverse-Words-in-a-String-II/"/>
      <url>/2018/07/27/186-Reverse-Words-in-a-String-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an input string , reverse the string word by word. </p><p>Example:</p><p>Input:  <code>[&quot;t&quot;,&quot;h&quot;,&quot;e&quot;,&quot; &quot;,&quot;s&quot;,&quot;k&quot;,&quot;y&quot;,&quot; &quot;,&quot;i&quot;,&quot;s&quot;,&quot; &quot;,&quot;b&quot;,&quot;l&quot;,&quot;u&quot;,&quot;e&quot;]</code><br>Output: <code>[&quot;b&quot;,&quot;l&quot;,&quot;u&quot;,&quot;e&quot;,&quot; &quot;,&quot;i&quot;,&quot;s&quot;,&quot; &quot;,&quot;s&quot;,&quot;k&quot;,&quot;y&quot;,&quot; &quot;,&quot;t&quot;,&quot;h&quot;,&quot;e&quot;]</code><br>Note: </p><p>A word is defined as a sequence of non-space characters.<br>The input string does not contain leading or trailing spaces.<br>The words are always separated by a single space.<br>Follow up: Could you do it in-place without allocating extra space?</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>We can reverse the string first, then use two pointers to find space <code>&#39; &#39;</code>. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; str)</span> </span>&#123;</span><br><span class="line">        reverse(str.begin(), str.end());</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>, n= str.size();</span><br><span class="line">        <span class="keyword">while</span>(right&lt; n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(right&lt; n &amp;&amp; str[right]!= <span class="string">' '</span>) right++;</span><br><span class="line">            reverse(str.begin()+left, str.begin()+right);</span><br><span class="line">            left= ++right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/mLq9PF" target="_blank" rel="noopener">https://goo.gl/mLq9PF</a><br><a href="https://goo.gl/PztRhh" target="_blank" rel="noopener">https://goo.gl/PztRhh</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>350. Intersection of Two Arrays II</title>
      <link href="/2018/07/26/350-Intersection-of-Two-Arrays-II/"/>
      <url>/2018/07/26/350-Intersection-of-Two-Arrays-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given two arrays, write a function to compute their intersection.</p><p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p><p>Note:<br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.<br>Follow up:</p><ul><li>What if the given array is already sorted? How would you optimize your algorithm?</li><li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li><li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li></ul><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>For this question, we can easily use an unordered_map to count the number that appear in nums1. Then walk through the nums2, and store the same number to the result.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dict;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)nums1.size(); i++) </span><br><span class="line">            dict[nums1[i]]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)nums2.size(); i++)</span><br><span class="line">            <span class="keyword">if</span>(dict.find(nums2[i]) != dict.end() &amp;&amp; --dict[nums2[i]] &gt;= <span class="number">0</span>) </span><br><span class="line">        </span><br><span class="line">        res.push_back(nums2[i]);            </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Follow up:</p><ul><li><p>What if the given array is already sorted? How would you optimize your algorithm?<br>If the array is already sorted, we can use binary search to speed up the process. </p></li><li><p>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?<br>It’s better to use the smaller array to construct the counter hash.</p></li><li><p>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?<br>Divide and conquer. Repeat the process frequently: Slice nums2 to fit into memory, process (calculate intersections), and write partial results to memory.</p></li></ul><p>reference:<br><a href="https://goo.gl/CqspgR" target="_blank" rel="noopener">https://goo.gl/CqspgR</a><br><a href="https://goo.gl/rewNgE" target="_blank" rel="noopener">https://goo.gl/rewNgE</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easy </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> hash table </tag>
            
            <tag> binary search </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>60. Permutation Sequence</title>
      <link href="/2018/07/26/60-Permutation-Sequence/"/>
      <url>/2018/07/26/60-Permutation-Sequence/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p><p>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>Given n and k, return the kth permutation sequence.</p><p>Note:</p><p>Given n will be between 1 and 9 inclusive.<br>Given k will be between 1 and n! inclusive.<br>Example 1:</p><p>Input: n = 3, k = 3<br>Output: “213”<br>Example 2:</p><p>Input: n = 4, k = 9<br>Output: “2314”</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># Solution:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factorial(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">string</span> res;</span><br><span class="line">            <span class="keyword">int</span> sum= <span class="number">1</span>;</span><br><span class="line">            factorial[<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line">                sum*= i;</span><br><span class="line">                factorial[i]= sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// factorial[] = &#123;1, 1, 2, 6, 24, ... n!&#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line">                numbers.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// numbers = &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">            </span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> index= k/factorial[n-i];</span><br><span class="line">                res+= to_string(numbers[index]);</span><br><span class="line">                numbers.erase(numbers.begin()+ index);</span><br><span class="line">                k-= index*factorial[n-i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/guWjyp" target="_blank" rel="noopener">https://goo.gl/guWjyp</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>37. Sudoku Solver</title>
      <link href="/2018/07/26/37-Sudoku-Solver/"/>
      <url>/2018/07/26/37-Sudoku-Solver/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy all of the following rules:</p><p>Each of the digits 1-9 must occur exactly once in each row.<br>Each of the digits 1-9 must occur exactly once in each column.<br>Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.<br>Empty cells are indicated by the character ‘.’.</p><p><img src="1.png" alt=""><br>A sudoku puzzle…</p><p><img src="2.png" alt=""><br>…and its solution numbers marked in red.</p><p>Note:</p><p>The given board contain only digits 1-9 and the character ‘.’.<br>You may assume that the given Sudoku puzzle will have a single unique solution.<br>The given board size is always 9x9.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>For this question, we can use recursive/backtracking to solve it. </p><ol><li>Find a <code>&#39;.&#39;</code> location that need to fill in a number</li><li>Check if this position can be filled in with some number. The checking can be done by scanning the same row, the same column, the same 3*3 box.</li><li>If we can fill the position with a number, then we use recursive to find next <code>&#39;.&#39;</code> position to be filled. One thing to notice is that, when we do the recursive, we might found out that this current result is false. At this time, we can use backtracking to previous level, and try to put other number in the previous position.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. find location, '.', to check </span></span><br><span class="line"><span class="comment">        2. determine what number can this position use. </span></span><br><span class="line"><span class="comment">            By checking whether if same row || same column || same box, have this number.</span></span><br><span class="line"><span class="comment">        3. after filling this position, we can pass this board to the recursive and check next '.' to be filled.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(board.empty() || board[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]== <span class="string">'.'</span>)&#123; <span class="comment">//a location needs to be filled</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c= <span class="string">'1'</span>; c&lt;= <span class="string">'9'</span>; c++)&#123; <span class="comment">//try from 1 through 9</span></span><br><span class="line">                        <span class="keyword">if</span>(isValid(board, i, j, c))&#123; <span class="comment">//check if this 'c' can put in the position</span></span><br><span class="line">                            board[i][j]= c; <span class="comment">//put c into the location</span></span><br><span class="line">                          <span class="keyword">if</span>(solve(board)) <span class="comment">//if this is the solution</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                board[i][j]= <span class="string">'.'</span>; <span class="comment">//go back and try another char</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] != <span class="string">'.'</span> &amp;&amp; board[i][col]== c) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check row by row, found c is already used</span></span><br><span class="line">            <span class="keyword">if</span>(board[row][i] != <span class="string">'.'</span> &amp;&amp; board[row][i]== c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> boxR= <span class="number">3</span>*(row/<span class="number">3</span>)+ i/<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> boxC= <span class="number">3</span>*(col/<span class="number">3</span>)+ i%<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[boxR][boxC] != <span class="string">'.'</span> &amp;&amp; board[boxR][boxC]== c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://www.youtube.com/watch?v=b6CxF17Y_k4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=b6CxF17Y_k4</a><br><a href="https://goo.gl/PaqSwh" target="_blank" rel="noopener">https://goo.gl/PaqSwh</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>249. Group Shifted Strings</title>
      <link href="/2018/07/25/249-Group-Shifted-Strings/"/>
      <url>/2018/07/25/249-Group-Shifted-Strings/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence:</p><p>“abc” -&gt; “bcd” -&gt; … -&gt; “xyz”<br>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p><p>Example:</p><p>Input: [“abc”, “bcd”, “acef”, “xyz”, “az”, “ba”, “a”, “z”],<br>Output:<br>[<br>  [“abc”,”bcd”,”xyz”],<br>  [“az”,”ba”],<br>  [“acef”],<br>  [“a”,”z”]<br>]</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>Find a way to determine whether if two word are the same pattern. We can do it by checking the difference for each character in the word. This result can use as a key to store every word who has same pattern.</li><li>Then we can use an unordered_map to store the <code>key</code> and value <code>vector&lt;string&gt;</code>, which is the words that have equal pattern.</li></ol><p>For example:<br>for a string s of length n, we encode its shifting feature as “s[1] - s[0], s[2] - s[1], …, s[n - 1] - s[n - 2],”.<br>if we have <code>abc</code> and <code>efg</code>. We can find out that,<br>distance of <code>a</code> and <code>b</code> is 1, distance of <code>b</code> and <code>c</code> is 1.<br>distance of <code>e</code> and <code>f</code> is 1, distance of <code>f</code> and <code>g</code> is 1.<br>Therefore, these two words are the same pattern.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupStrings(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. find out how to find the pattern for each words, we can calculate the diff between every word</span></span><br><span class="line"><span class="comment">        2. use the diff as key, the same words as value</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s: strings)</span><br><span class="line">            <span class="built_in">map</span>[shift(s)].push_back(s);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s: <span class="built_in">map</span>)&#123;</span><br><span class="line">            res.push_back(s.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shift</span><span class="params">(<span class="built_in">string</span> input)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; input.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff= input[i]-input[i<span class="number">-1</span>];</span><br><span class="line">            res+= diff&lt; <span class="number">0</span> ? diff+<span class="number">26</span>: diff;</span><br><span class="line">            res+= <span class="string">','</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h1><p>more concise code. add 26 to the diff and mod it afterward.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupStrings(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; res;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : strings) &#123;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : a) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if((c-a[0]) &lt; 0)</span></span><br><span class="line"><span class="comment">                t+= ((c-a[0]+26) + ',');</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                t+= ((c-a[0]) + ',');</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            </span><br><span class="line">            t += (((c+ <span class="number">26</span> - a[<span class="number">0</span>]) % <span class="number">26</span>) + <span class="string">','</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>[t].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> m: <span class="built_in">map</span>)</span><br><span class="line">        res.push_back(m.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> google </tag>
            
            <tag> apple </tag>
            
            <tag> medium </tag>
            
            <tag> uber </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>244. Shortest Word Distance II</title>
      <link href="/2018/07/25/244-Shortest-Word-Distance-II/"/>
      <url>/2018/07/25/244-Shortest-Word-Distance-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. Your method will be called repeatedly many times with different parameters. </p><p>Example:<br>Assume that words = <code>[&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]</code>.</p><p>Input: word1 = “coding”, word2 = “practice”<br>Output: 3<br>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>Use a defaultdict to quickly find word</li><li>Since a word might appear multiple times, need to search where’s the shortest distance<ol><li>walk through every index of word1 and word2, takes <code>O(m*n)</code> </li><li>use merge sort, take <code>O(m+n)</code></li></ol></li></ol><p><code>O(m*n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, wordsDict: List[str])</span>:</span></span><br><span class="line">        self.dic = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(wordsDict)):</span><br><span class="line">            self.dic[wordsDict[i]].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        dis1, dis2 = self.dic[word1], self.dic[word2]</span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> v1 <span class="keyword">in</span> dis1:</span><br><span class="line">            <span class="keyword">for</span> v2 <span class="keyword">in</span> dis2:</span><br><span class="line">                res = min(res, abs(v1-v2))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your WordDistance object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = WordDistance(wordsDict)</span></span><br><span class="line"><span class="comment"># param_1 = obj.shortest(word1,word2)</span></span><br></pre></td></tr></table></figure><p><code>O(m+n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, wordsDict: List[str])</span>:</span></span><br><span class="line">        self.dic = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(wordsDict)):</span><br><span class="line">            self.dic[wordsDict[i]].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortest</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        dis1, dis2 = self.dic[word1], self.dic[word2]</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(dis1) <span class="keyword">and</span> j &lt; len(dis2):</span><br><span class="line">            res = min(res, abs(dis1[i] - dis2[j]))</span><br><span class="line">            <span class="keyword">if</span> dis1[i] &lt; dis2[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>The problem is relatively simple, but this is a design question, so you have to collect as much information as you need from the interviewer. For example, does the input contains any duplicate elements? if it does, we need to use a <code>vector&lt;int&gt;</code> to store the index of same word.</p><h1 id="basic-solution"><a href="#basic-solution" class="headerlink" title="basic solution:"></a>basic solution:</h1><p>in the search part, the time complexity is <code>O(MN)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WordDistance(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i) &#123;</span><br><span class="line">        m[words[i]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortest</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m[word1].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m[word2].size(); ++j) &#123;</span><br><span class="line">            res = min(res, <span class="built_in">abs</span>(m[word1][i] - m[word2][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: O(MN)</p><h1 id="improved-solution"><a href="#improved-solution" class="headerlink" title="improved solution:"></a>improved solution:</h1><p>We can improve the above solution by using two pointers to find the smallest result.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">    WordDistance(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; words.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[words[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortest</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> vec1= <span class="built_in">map</span>[word1];</span><br><span class="line">        <span class="keyword">auto</span> vec2= <span class="built_in">map</span>[word2];</span><br><span class="line">        <span class="keyword">int</span> res= INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>, j= <span class="number">0</span>; i&lt; vec1.size()&amp;&amp; j&lt; vec2.size();)&#123;</span><br><span class="line">            <span class="keyword">int</span> idx1= vec1[i];</span><br><span class="line">            <span class="keyword">int</span> idx2= vec2[j];</span><br><span class="line">            <span class="keyword">if</span>(idx1&lt; idx2)&#123;</span><br><span class="line">                res= min(res, idx2-idx1);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res= min(res, idx1-idx2);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: O(m+n)</p><h1 id="more-concise-solution"><a href="#more-concise-solution" class="headerlink" title="more concise solution:"></a>more concise solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WordDistance(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            m[words[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortest</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, res = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m[word1].size() &amp;&amp; j &lt; m[word2].size()) &#123;</span><br><span class="line">            res = min(res, <span class="built_in">abs</span>(m[word1][i] - m[word2][j]));</span><br><span class="line">            m[word1][i] &lt; m[word2][j] ? ++i : ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(m+n)<br>reference:<br><a href="https://goo.gl/BkmZXc" target="_blank" rel="noopener">https://goo.gl/BkmZXc</a><br><a href="http://www.cnblogs.com/grandyang/p/5187640.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5187640.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> uber </tag>
            
            <tag> design </tag>
            
            <tag> hash table </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>739. Daily Temperatures</title>
      <link href="/2018/07/25/739-Daily-Temperatures/"/>
      <url>/2018/07/25/739-Daily-Temperatures/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.</p><p>For example, given the list temperatures = <code>[73, 74, 75, 71, 69, 72, 76, 73]</code>, your output should be <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.</p><p>Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range <code>[30, 100]</code>.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The start of this idea is to walk through every element in the array. We put every element in the stack, and if we get to a new temperature that is higher than stack.top(), then we can start to pop out the elements in the stack, until stack.top() is greater than new temperature. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">0</span>] * len(T)</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i, t <span class="keyword">in</span> enumerate(T):</span><br><span class="line">            <span class="comment"># keep pop out element and update them in ans array</span></span><br><span class="line">            <span class="comment"># store the index in stk</span></span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> T[i] &gt; T[stk[<span class="number">-1</span>]]:</span><br><span class="line">                prev = stk.pop()</span><br><span class="line">                ans[prev] = i-prev</span><br><span class="line">            stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(temperatures.size(), <span class="number">0</span>);</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> index= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty() &amp;&amp; index&lt; temperatures.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; temperatures[index] &gt; temperatures[stk.top()])&#123;</span><br><span class="line">                res[stk.top()]= index-stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)<br>space complexity: O(n)</p><p>reference:<br><a href="https://goo.gl/cYiBN3" target="_blank" rel="noopener">https://goo.gl/cYiBN3</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>149. Max Points on a Line</title>
      <link href="/2018/07/25/149-Max-Points-on-a-Line/"/>
      <url>/2018/07/25/149-Max-Points-on-a-Line/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p><p>Example 1:</p><p>Input: <code>[[1,1],[2,2],[3,3]]</code><br>Output: 3<br>Explanation:</p><pre><code>^||        o|     o|  o  +-------------&gt;0  1  2  3  4</code></pre><p>Example 2:</p><p>Input: <code>[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</code><br>Output: 4<br>Explanation:</p><pre><code>^||  o|     o        o|        o|  o        o+-------------------&gt;0  1  2  3  4  5  6</code></pre><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>basic solution:<br>Calculate slope for two points to find whether if they are on the same line, the solution is <code>O(n^2)</code>. First of all, we can divide the points into three groups, exact same point, one the same vertical, or general slope. However, this can not pass one test case, so need to improve based on it.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Failed on case: [[0,0],[94911151,94911150],[94911152,94911151]]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; &amp;points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> samePoint = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y)&#123;</span><br><span class="line">                samePoint++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(points[i].x == points[j].x)&#123;</span><br><span class="line">                <span class="built_in">map</span>[INT_MAX]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">double</span> slope = <span class="keyword">double</span>(points[i].y - points[j].y) / <span class="keyword">double</span>(points[i].x - points[j].x);</span><br><span class="line">                <span class="built_in">map</span>[slope]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> localMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = <span class="built_in">map</span>.begin(); it != <span class="built_in">map</span>.end(); it++)&#123;</span><br><span class="line">            localMax = max(localMax, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        localMax += samePoint;</span><br><span class="line">        result = max(result, localMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Previous solution have a major problem. First, the slope is not concise because if may exceed the number that <code>double</code> can express. Therefore, we can find the greatest common divisor(GCD) to avoid the issue. We calculate every GCD and use it to divide the <code>dx</code> and <code>dy</code>.<br>For example: if we have <code>[8,4]</code>, <code>[4,2]</code>, <code>[2,1]</code> to be our slope, these three slopes will be counted into one map value.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a point.</span></span><br><span class="line"><span class="comment">* struct Point &#123;</span></span><br><span class="line"><span class="comment">*     int x;</span></span><br><span class="line"><span class="comment">*     int y;</span></span><br><span class="line"><span class="comment">*     Point() : x(0), y(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">*     Point(int a, int b) : x(a), y(b) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. devide the points into three groups:</span></span><br><span class="line"><span class="comment">            a. same point</span></span><br><span class="line"><span class="comment">            b. general slope</span></span><br><span class="line"><span class="comment">        2. count every slope for two points, O(n^2)</span></span><br><span class="line"><span class="comment">        3. the slope may have divided by zero problem, so use pair&lt;int, int&gt; to avoid that. In addition, find greatest common divisor to get accurate slope.</span></span><br><span class="line"><span class="comment">        4. add the same points to the localResult</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">int</span> duplicate = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y) &#123;</span><br><span class="line">                    ++duplicate; <span class="keyword">continue</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">int</span> dx = points[j].x - points[i].x;</span><br><span class="line">                <span class="keyword">int</span> dy = points[j].y - points[i].y;</span><br><span class="line">                <span class="keyword">int</span> d = gcd(dx, dy);</span><br><span class="line">                ++m[&#123;dx / d, dy / d&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, duplicate);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = m.begin(); it != m.end(); ++it) &#123;</span><br><span class="line">                res = max(res, it-&gt;second + duplicate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b == <span class="number">0</span>) ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://goo.gl/YRuLmT" target="_blank" rel="noopener">https://goo.gl/YRuLmT</a><br><a href="http://www.cnblogs.com/grandyang/p/4579693.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4579693.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>57. Insert Interval</title>
      <link href="/2018/07/25/57-Insert-Interval/"/>
      <url>/2018/07/25/57-Insert-Interval/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><p>Example 1:</p><p>Input: intervals = <code>[[1,3],[6,9]]</code>, newInterval = <code>[2,5]</code><br>Output: <code>[[1,5],[6,9]]</code><br>Example 2:</p><p>Input: intervals = <code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval = <code>[4,8]</code><br>Output: <code>[[1,2],[3,10],[12,16]]</code><br>Explanation: Because the new interval <code>[4,8]</code> overlaps with <code>[3,5]</code>,<code>[6,7]</code>,<code>[8,10]</code>.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>See it as another interval, add to the list, sort it then merge intervals<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert1</span><span class="params">(self, intervals, newInterval)</span>:</span></span><br><span class="line">    intervals.append(newInterval)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sorted(intervals, key=<span class="keyword">lambda</span> x:x.start):</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">and</span> res[<span class="number">-1</span>].end &gt;= i.start:</span><br><span class="line">            res[<span class="number">-1</span>].end = max(res[<span class="number">-1</span>].end, i.end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>$O(nlogn)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> index, i <span class="keyword">in</span> enumerate(intervals):</span><br><span class="line">            <span class="keyword">if</span> i[<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]:</span><br><span class="line">                res.append(i)</span><br><span class="line">            <span class="keyword">elif</span> i[<span class="number">0</span>] &gt; newInterval[<span class="number">1</span>]:</span><br><span class="line">                res.append(newInterval)</span><br><span class="line">                <span class="keyword">return</span> res+intervals[index:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newInterval[<span class="number">0</span>] = min(newInterval[<span class="number">0</span>], i[<span class="number">0</span>])</span><br><span class="line">                newInterval[<span class="number">1</span>] = max(newInterval[<span class="number">1</span>], i[<span class="number">1</span>])</span><br><span class="line">        res.append(newInterval)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>$O(n)$</p><p>This is a follow up for . </p><ol><li>Create a vector for storing result.</li><li>If an end of an interval does not greater than newInterval’s start, then we know they are not intersecting. Since the input is sorted, we can put these into the result first.</li><li>If an interval’s start is smaller than newInterval’s end, then they must intersect.</li></ol><p><img style="width: 100%; height: 100%" src="57.png"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for an interval.</span></span><br><span class="line"><span class="comment">* struct Interval &#123;</span></span><br><span class="line"><span class="comment">*     int start;</span></span><br><span class="line"><span class="comment">*     int end;</span></span><br><span class="line"><span class="comment">*     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">*     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; insert(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> index= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(index&lt; intervals.size() &amp;&amp; intervals[index].end &lt; newInterval.start)&#123;</span><br><span class="line">            res.push_back(intervals[index++]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index&lt; intervals.size() &amp;&amp; newInterval.end&gt;= intervals[index].start)&#123;</span><br><span class="line">            newInterval.start= min(intervals[index].start, newInterval.start);</span><br><span class="line">            newInterval.end= max(intervals[index].end, newInterval.end);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(newInterval);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index&lt; intervals.size())</span><br><span class="line">            res.push_back(intervals[index++]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: O(n)</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h3><p>The idea is to use newInterval as a buffer, and update it when there’s an overlap.<br>When the <code>newInterval.end &lt; intervals[i].start</code>, it means the upcoming intervals are greater, and no need to keep tracing.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; insert(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="keyword">auto</span> it= intervals.begin();</span><br><span class="line">        <span class="keyword">for</span>(; it!= intervals.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newInterval.end &lt; (*it).start)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(newInterval.start &gt; (*it).end)</span><br><span class="line">                res.push_back(*it);</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//overlapping, use newInterval as a buffer and update it</span></span><br><span class="line">                newInterval.start= min(newInterval.start, (*it).start);</span><br><span class="line">                newInterval.end= max(newInterval.end, (*it).end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res.push_back(newInterval);</span><br><span class="line">        <span class="keyword">for</span>(; it!= intervals.end(); it++)&#123;</span><br><span class="line">            res.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/5stsBW" target="_blank" rel="noopener">https://goo.gl/5stsBW</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> uber </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>126. Word Ladder II</title>
      <link href="/2018/07/24/126-Word-Ladder-II/"/>
      <url>/2018/07/24/126-Word-Ladder-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:</p><p>Only one letter can be changed at a time<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>Note:</p><p>Return an empty list if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.<br>Example 1:</p><p>Input:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>Output:<br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]<br>Example 2:</p><p>Input:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]</p><p>Output: []</p><p>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This is a follow up for <a href="/2018/06/14/127-Word-Ladder/" title="127. Word Ladder">127. Word Ladder</a>. If you have this question on interview, maybe go with a naive BFS solution, then improve it with bi-direction BFS. </p><p>The solution came with one direction BFS, the step is as follows.</p><ol><li>Use BFS to solve question, so we need a queue. <code>queue&lt;vector&lt;string&gt;&gt; paths</code>, to store the paths in current level.</li><li>A dictionary that help to search if a mutate string is in wordlist. The mutate string is created by the same method in <a href="/2018/06/14/127-Word-Ladder/" title="127. Word Ladder">127. Word Ladder</a>. For each character in a word, try to change it to another character, and check whether if it’s in the dictionary.</li><li>Once we know the words in previous level(can think of as the BFS level), we can not use those words again, so we need a set(<code>unordered_set&lt;string&gt; words</code>) to record the used string on this level.</li><li>Maintain a <code>minlevel</code> to speed up the process. Because if we can find a path to find <code>endWord</code> in 5 hops, then we don’t need to find any path that is greater than 5.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res; </span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(wordList.begin(), wordList.end()); <span class="comment">//for lookup if the changed word in dictionary or not</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; p&#123;beginWord&#125;; </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; paths;</span><br><span class="line">        </span><br><span class="line">        paths.push(p);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>, minLevel = INT_MAX;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!paths.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = paths.front(); <span class="comment">//start with beginWord</span></span><br><span class="line">            paths.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t.size() &gt; level) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">string</span> w : words) dict.erase(w); <span class="comment">//to remove the word that already used on level 1</span></span><br><span class="line">                words.clear();</span><br><span class="line">                level = t.size();</span><br><span class="line">                <span class="keyword">if</span> (level &gt; minLevel) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> last = t.back(); <span class="comment">//last element of curent path, try to find next word to link</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last.size(); ++i) &#123;</span><br><span class="line">                <span class="built_in">string</span> newLast = last;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ++ch) &#123;</span><br><span class="line">                    newLast[i] = ch;</span><br><span class="line">                    <span class="keyword">if</span> (!dict.count(newLast)) <span class="keyword">continue</span>; </span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//can find another word after changing one character in dictionary</span></span><br><span class="line">                    words.insert(newLast); <span class="comment">//put it into set, so we won't use it again</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    example: </span></span><br><span class="line"><span class="comment">                    t: abc-&gt;abd-&gt;acd</span></span><br><span class="line"><span class="comment">                    newPath= abc-&gt;abd-&gt;acd + acc</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; nextPath = t; </span><br><span class="line">                    nextPath.push_back(newLast);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newLast == endWord) &#123;</span><br><span class="line">                        res.push_back(nextPath);</span><br><span class="line">                        minLevel = level;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">else</span> paths.push(nextPath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://www.youtube.com/watch?v=lmypbtgdpuQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=lmypbtgdpuQ</a><br><a href="http://www.cnblogs.com/grandyang/p/4548184.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4548184.html</a><br><a href="https://goo.gl/4rcWS6" target="_blank" rel="noopener">https://goo.gl/4rcWS6</a><br><a href="https://goo.gl/t1vxXg" target="_blank" rel="noopener">https://goo.gl/t1vxXg</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> bfs </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>154. Find Minimum in Rotated Sorted Array II</title>
      <link href="/2018/07/24/154-Find-Minimum-in-Rotated-Sorted-Array-II/"/>
      <url>/2018/07/24/154-Find-Minimum-in-Rotated-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p><p>Find the minimum element.</p><p>The array may contain duplicates.</p><p>Example 1:</p><p>Input: <code>[1,3,5]</code><br>Output: 1<br>Example 2:</p><p>Input: <code>[2,2,2,0,1]</code><br>Output: 0</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This question is a follow up for  <a href="/2018/05/25/153-Find-Minimum-in-Rotated-Sorted-Array/" title="153. Find Minimum in Rotated Sorted Array">153. Find Minimum in Rotated Sorted Array</a>. We can still use binary search to solve this question. </p><ol><li>two pointers, <code>left</code> and <code>right</code>. In the end, we return the <code>nums[left]</code></li><li>calculate <code>mid</code> to find middle element.</li><li>Since the array is sorted, if <code>nums[mid] &gt; nums[right]</code> then we set <code>left</code> to <code>mid+1</code> because we know the smallest element is on the right side and it’s started position would at least be mid+1.</li><li>One thing to notice is that the array contains duplicate elements, if <code>nums[mid] == nums[right]</code> we reduce the right pointer.</li></ol><p>For the duplicate elements, it might drag the time complexity to <code>O(n)</code> if it looks like the following array.<br><code>&quot;1 1 1 1 1 0 1 1 1 1 1 1 1 1&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            mid= left+ (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt; nums[right])</span><br><span class="line">                left= mid+<span class="number">1</span>; <span class="comment">//set to mid+1 is because nums[mid] is definitely not the smallest element</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt; nums[right])</span><br><span class="line">                right= mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//nums[mid]== nums[right]</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> uber </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ 11 lambda function</title>
      <link href="/2018/07/23/C-11-lambda-function/"/>
      <url>/2018/07/23/C-11-lambda-function/</url>
      <content type="html"><![CDATA[<p>In C++ 11, a lambda expression is a convenient way of defining an anonymous function object right at the location where it is invoked or passed as an argument to a function.</p><p>basic usage:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[=] (<span class="keyword">int</span> x) <span class="keyword">mutable</span> <span class="keyword">throw</span>() -&gt; <span class="keyword">int</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// function</span></span><br><span class="line">  <span class="keyword">int</span> n = x + y;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>[=]：lambda-introducer, or capture clause<br>every lambda function start with lambda-introducer and can not be omitted. Besides of the working as a keyword for lambda expression, it can also denote how to fetch variables into lambda function.<br>You can use the <code>default capture mode</code> (capture-default in the Standard syntax) to indicate how to capture any outside variables that are referenced in the lambda: <code>[&amp;]</code> means all variables that you refer to are <code>captured by reference</code>, and <code>[=]</code> means they are <code>captured by value</code>. You can use a default capture mode, and then specify the opposite mode explicitly for specific variables.<br>For example, if a lambda body accesses the external variable total by reference and the external variable factor by value, then the following capture clauses are equivalent:</p><p><code>[]</code>: default<br><code>[=]</code>: set default capture mode to capture by value.<br><code>[&amp;]</code>: set default capture mode to capture by reference.<br><code>[x, &amp;y]</code>: x is capture by value, y is capture by reference.<br><code>[=, &amp;y]</code>: every variable is captured by value, except y is captured by reference.<br><code>[&amp;, x]</code>: every variable is captured by reference, except x is captured by value.</p></li></ul><p>use lambda with STL function:<br>example(with out lambda):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool condition(int value) &#123;</span><br><span class="line">  return (value &gt; 5);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  vector&lt;int&gt; numbers &#123; 1, 2, 3, 4, 5, 10, 15, 20, 25, 35, 45, 50 &#125;;</span><br><span class="line">  // check how many elements meet the condition</span><br><span class="line">  auto count = count_if(numbers.begin(), numbers.end(), condition);</span><br><span class="line">  cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; numbers &#123; 1, 2, 3, 4, 5, 10, 15, 20, 25, 35, 45, 50 &#125;;</span><br><span class="line">  // use lambda expression to replace the condition function</span><br><span class="line">  auto count = count_if(numbers.begin(), numbers.end(), [](int x) &#123; return (x &gt; 5); &#125;);</span><br><span class="line">  cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://msdn.microsoft.com/en-us/library/dd293608.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd293608.aspx</a><br><a href="https://blog.gtwang.org/programming/lambda-expression-in-c11/" target="_blank" rel="noopener">https://blog.gtwang.org/programming/lambda-expression-in-c11/</a></p>]]></content>
      
      <categories>
          
          <category> programming language </category>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> C++ 11 </tag>
            
            <tag> MSDN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>56. Merge Intervals</title>
      <link href="/2018/07/23/56-Merge-Intervals/"/>
      <url>/2018/07/23/56-Merge-Intervals/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><p>Input: <code>[[1,3],[2,6],[8,10],[15,18]]</code><br>Output: <code>[[1,6],[8,10],[15,18]]</code><br>Explanation: Since intervals <code>[1,3]</code> and <code>[2,6]</code> overlaps, merge them into [1,6].<br>Example 2:</p><p>Input: <code>[[1,4],[4,5]]</code><br>Output: <code>[[1,5]]</code><br>Explanation: Intervals [1,4] and [4,5] are considered overlapping.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>First of all, we can sort the array of intervals by its start value. The sort can use lambda function.</li><li>After we sort the array, we can easily found out that the only condition we need to check is whether if <code>i</code>‘s end value is smaller than <code>i+1</code>‘s start value.</li></ol><p>For example:<br>original: <code>[[4,3],[2,6],[3,5],[7,18]]</code><br>sorted: <code>[[2,6],[3,5],[4,7],[8,18]]</code></p><ul><li>init round: push the <code>[2,6]</code> into result.</li><li>1st round:<br>compare <code>[2,6]</code> and <code>[3,5]</code>. <code>6</code> is greater than <code>3</code>, so we then compare end value from both range.</li><li>2nd round:<br>compare <code>[2,6]</code> and <code>[4,7]</code>. update <code>[2,6]</code> to <code>[2,7]</code></li><li>3rd round:<br>compare <code>[2,7]</code> and <code>[8,18]</code>. Since <code>8</code> is greater than <code>7</code>, it can not merge together, so we push <code>[8,18]</code> into the result.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for an interval.</span></span><br><span class="line"><span class="comment">* struct Interval &#123;</span></span><br><span class="line"><span class="comment">*     int start;</span></span><br><span class="line"><span class="comment">*     int end;</span></span><br><span class="line"><span class="comment">*     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">*     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*static bool comp(Interval a, Interval b)&#123;</span></span><br><span class="line"><span class="comment">        return a.start&lt; b.start;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="comment">//sort(intervals.begin(), intervals.end(), comp);</span></span><br><span class="line">        sort(ins.begin(), ins.end(), [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        </span><br><span class="line">        res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.back().end &lt; intervals[i].start) res.push_back(intervals[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.back().end = max(res.back().end, intervals[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>238. Product of Array Except Self</title>
      <link href="/2018/07/23/238-Product-of-Array-Except-Self/"/>
      <url>/2018/07/23/238-Product-of-Array-Except-Self/</url>
      <content type="html"><![CDATA[<h2 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h2><p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p><p>Solve it without division and in O(n).</p><p>For example, given <code>[1,2,3,4]</code>, return <code>[24,12,8,6]</code>.</p><p>Follow up:<br>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>Given numbers <code>[2, 3, 4, 5]</code>, regarding the third number <code>4</code>, the product of array except <code>4</code> is <code>2*3*5</code> which consists of two parts: left <code>2*3</code> and right <code>5</code>. The product is <code>left*right</code>. We can get lefts and rights:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Numbers:     2    3    4     5</span><br><span class="line">Lefts:            2  2*3 2*3*4</span><br><span class="line">Rights:  3*4*5  4*5    5</span><br></pre></td></tr></table></figure><p>Let’s fill the empty with 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Numbers:     2    3    4     5</span><br><span class="line">Lefts:       1    2  2*3 2*3*4</span><br><span class="line">Rights:  3*4*5  4*5    5     1</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = [<span class="number">1</span>]*n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        right = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            res[i] = right*res[i]</span><br><span class="line">            right *= nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(length, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; length; i++)&#123;</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            res[i]*= right;</span><br><span class="line">            right*= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="second-time"><a href="#second-time" class="headerlink" title="second time:"></a>second time:</h1><p>based on the previous thought, but modify the code to make it more intuitive.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3   4   5   6</span></span><br><span class="line"><span class="comment">left=1 1*1  </span></span><br><span class="line"><span class="comment">        -&gt; 1*3  </span></span><br><span class="line"><span class="comment">            -&gt;3*4  </span></span><br><span class="line"><span class="comment">                -&gt; 3*4*5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3   4   5   6</span></span><br><span class="line"><span class="comment">                  1*1  right=1</span></span><br><span class="line"><span class="comment">              1*6 &lt;-</span></span><br><span class="line"><span class="comment">          5*6  &lt;-</span></span><br><span class="line"><span class="comment">      4*5*6  &lt;-</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">do same work, can use one for loop</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(length, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">1</span>, right= <span class="number">1</span>;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>, j= length<span class="number">-1</span>; i&lt; length; i++, j--)&#123;</span><br><span class="line">            res[i]*= left;</span><br><span class="line">            left*= nums[i];</span><br><span class="line">            res[j]*= right;</span><br><span class="line">            right*= nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time: O(n)</p><h3 id="Third-time"><a href="#Third-time" class="headerlink" title="Third time"></a>Third time</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//use two array separately start from 1 and n-2</span></span><br><span class="line">        <span class="keyword">int</span> n= nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; n; i++)</span><br><span class="line">            res[i]= res[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= n<span class="number">-2</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            right*= nums[i+<span class="number">1</span>];</span><br><span class="line">            res[i]*= right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> lyft </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>123. Best Time to Buy and Sell Stock III</title>
      <link href="/2018/07/23/123-Best-Time-to-Buy-and-Sell-Stock-III/"/>
      <url>/2018/07/23/123-Best-Time-to-Buy-and-Sell-Stock-III/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p><p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p>Example 1:</p><p>Input: <code>[3,3,5,0,0,3,1,4]</code><br>Output: 6<br>Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.<br>             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.<br>Example 2:</p><p>Input: <code>[1,2,3,4,5]</code><br>Output: 4<br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>             engaging multiple transactions at the same time. You must sell before buying again.<br>Example 3:</p><p>Input: <code>[7,6,4,3,1]</code><br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>this is a relatively easier way to understand this question. </p><ol><li><p>create a 2d array, row is total number of transaction, column is total number of days.<br><img style="width: 100%; height: 100%" src="IMG_5332.jpg"></p></li><li><p>the dp formula is<br><code>T[i][j]= max(T[i][j-1], price[j]-price[m]+ T[i-1][m])</code><br>it means, the maximum profit can get on transaction <code>i</code> in day <code>j</code> should be one of the following one.</p><ol><li><code>T[i][j-1]</code>, the same as previous day, means make no transaction at all.</li><li><code>price[j]-price[m]+ T[i-1][m]</code>, sale the stock bought on day <code>m</code> with the price on day <code>j</code>, and add the previous transaction profit together.</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//transaction: k, days: n</span></span><br><span class="line">    <span class="comment">//O(k*n^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> transactions= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(transactions+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(prices.size(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">1</span>; r&lt; dp.size(); r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">1</span>; c&lt; dp[<span class="number">0</span>].size(); c++)&#123;</span><br><span class="line">                <span class="keyword">int</span> maxval= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m= <span class="number">0</span>; m&lt; c; m++)&#123;</span><br><span class="line">                    maxval= max(maxval, prices[c]-prices[m]+ dp[r<span class="number">-1</span>][m]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[r][c]= max(dp[r][c<span class="number">-1</span>], maxval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[transactions][prices.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>However, the above solution would need many time to calculate. We can use a variable <code>maxdiff</code> to check whether if it’s a good time to sell the stock.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//transaction: k, days: n</span></span><br><span class="line">    <span class="comment">//O(k*n)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> transactions= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(transactions+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(prices.size(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">1</span>; r&lt; dp.size(); r++)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxdiff= -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">1</span>; c&lt; dp[<span class="number">0</span>].size(); c++)&#123;</span><br><span class="line">                dp[r][c]= max(dp[r][c<span class="number">-1</span>], prices[c]+maxdiff);</span><br><span class="line">                maxdiff= max(maxdiff, dp[r<span class="number">-1</span>][c]-prices[c]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[transactions][prices.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        sell1, sell2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        hold1, hold2 = float(<span class="string">"-inf"</span>), float(<span class="string">"-inf"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prices:</span><br><span class="line">            sell2 = max(sell2, hold2 + i) <span class="comment"># The maximum if we've just sold 2nd stock so far.</span></span><br><span class="line">            hold2 = max(hold2, sell1 - i) <span class="comment"># The maximum if we've just buy  2nd stock so far.</span></span><br><span class="line">            sell1 = max(sell1, hold1 + i) <span class="comment"># The maximum if we've just sold 1st stock so far.</span></span><br><span class="line">            hold1 = max(hold1, -i)        <span class="comment"># The maximum if we've just buy  1st stock so far.</span></span><br><span class="line">        <span class="keyword">return</span> sell2</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://www.youtube.com/watch?v=oDhu5uGq_ic&amp;feature=youtu.be" target="_blank" rel="noopener">https://www.youtube.com/watch?v=oDhu5uGq_ic&amp;feature=youtu.be</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hard </tag>
            
            <tag> array </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>45. Jump Game II</title>
      <link href="/2018/07/23/45-Jump-Game-II/"/>
      <url>/2018/07/23/45-Jump-Game-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Your goal is to reach the last index in the minimum number of jumps.</p><p>Example:</p><p>Input: <code>[2,3,1,1,4]</code><br>Output: 2<br>Explanation: The minimum number of jumps to reach the last index is 2.<br>    Jump 1 step from index 0 to 1, then 3 steps to the last index.<br>Note:</p><p>You can assume that you can always reach the last index.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>We can use a bfs to solve this question.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level= <span class="number">0</span>, curMax= <span class="number">0</span>, i= <span class="number">0</span>, nextMax= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;= curMax)&#123;  <span class="comment">//nodes count of current level&gt;0</span></span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">for</span>(; i&lt;=curMax; i++)&#123; <span class="comment">//traverse current level, and update the max reach of next level</span></span><br><span class="line">                nextMax= max(nextMax, nums[i]+i);</span><br><span class="line">                <span class="keyword">if</span>(nextMax&gt;= nums.size()<span class="number">-1</span>) <span class="keyword">return</span> level; <span class="comment">// if last element is in level+1, then the min jump=level </span></span><br><span class="line">            &#125;</span><br><span class="line">            curMax= nextMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://goo.gl/fG1EwS" target="_blank" rel="noopener">https://goo.gl/fG1EwS</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hard </tag>
            
            <tag> array </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>blockchain</title>
      <link href="/2018/07/11/blockchain/"/>
      <url>/2018/07/11/blockchain/</url>
      <content type="html"><![CDATA[<p>transaction:<br>fb: like, post<br>twitter: tweet, retweet<br>bitcoin: send money</p><p>Decentralize topology:<br>every node have whole copy.<br>51% of people have to approve/validate the new transaction.<br>the validation is done by miner, coin will be given to the 1st node that solve math problem.<br>Mining: verifying transactions by solving<br>transaction have queue up and group into block. </p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>199. Binary Tree Right Side View</title>
      <link href="/2018/07/11/199-Binary-Tree-Right-Side-View/"/>
      <url>/2018/07/11/199-Binary-Tree-Right-Side-View/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p>Example:</p><p>Input: <code>[1,2,3,null,5,null,4]</code><br>Output: <code>[1, 3, 4]</code><br>Explanation:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ul><li>DFS solution:</li></ul><ol><li>observe the tree, we can see that if we use a recursive traversal with a depth variable, we can get the rightmost element for each level.</li><li>traverse the right subtree first, then search for left subtree.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        self.res = []</span><br><span class="line">        level = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, level)</span>:</span></span><br><span class="line">            <span class="comment"># we only keep the rightest node in result, means every level only one node</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> level &gt; len(self.res):</span><br><span class="line">                self.res.append(root.val)</span><br><span class="line">            dfs(root.right, level+<span class="number">1</span>)</span><br><span class="line">            dfs(root.left, level+<span class="number">1</span>)</span><br><span class="line">        dfs(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        helper(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res, TreeNode* cur, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(depth == res.size())&#123;</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        helper(res, cur-&gt;right, depth+<span class="number">1</span>);</span><br><span class="line">        helper(res, cur-&gt;left, depth+<span class="number">1</span>); <span class="comment">//if a root have right and left node, the right node will add to res already, so left will not be pushed into res.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: <code>O(n)</code><br>space complexity: <code>O(n)</code></p><ul><li>BFS solution:</li></ul><ol><li>for BFS, we traverse each level with a queue.</li><li>push the newest element in queue to <code>res</code>. That is because the way we traverse, will look like this.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">  2    3 </span><br><span class="line">4  5  6  7</span><br></pre></td></tr></table></figure></li></ol><p><code>queue: 7 6 5 4</code>, 4 will be pushed into queue first, 7 will be the last and right most element.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            res.push_back(q.back()-&gt;val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i= q.size(); i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">auto</span> front= q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left) q.push(front-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right) q.push(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>BFS python<br>Use deque to store node in each level, then append child nodes in new deque.<br>The idea is to push the right most node last, so it would make sure <code>stack[-1]</code> is the rightest one.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            deque.append(root)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            newStack = collections.deque()</span><br><span class="line">            res.append(deque[<span class="number">-1</span>].val)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                node = deque.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    newStack.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    newStack.append(node.right)</span><br><span class="line">            deque = newStack</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/sWGD8V" target="_blank" rel="noopener">https://goo.gl/sWGD8V</a><br><a href="https://goo.gl/ZefCkV" target="_blank" rel="noopener">https://goo.gl/ZefCkV</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
          <category> amazon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> bfs </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>230. Kth Smallest Element in a BST</title>
      <link href="/2018/07/10/230-Kth-Smallest-Element-in-a-BST/"/>
      <url>/2018/07/10/230-Kth-Smallest-Element-in-a-BST/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p><p>Example 1:</p><p>Input: root = <code>[3,1,4,null,2]</code>, k = 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure></p><p>Output: 1<br>Example 2:</p><p>Input: root = <code>[5,3,6,2,4,null,null,1]</code>, k = 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">   / \</span><br><span class="line">  2   4</span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>Output: 3<br>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>use a variable to count ith smallest</li><li>whenever the count is zero, return the res</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                dfs(root.left)</span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                self.res = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        count= k;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//inorder traversal, find the left most first</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) helper(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        count--; </span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            res= root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) helper(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><p>BFS solution with inorder traversal</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        stack = deque()</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            top = stack.pop()</span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> top.val</span><br><span class="line">            root = top.right</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode* cur= root;</span><br><span class="line">        <span class="keyword">while</span>(cur || !q.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">                q.push(cur);</span><br><span class="line">                cur= cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cur= q.top(); q.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">            cur= cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/Ed7PGv" target="_blank" rel="noopener">https://goo.gl/Ed7PGv</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> amazon </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>173. Binary Search Tree Iterator</title>
      <link href="/2018/07/10/173-Binary-Search-Tree-Iterator/"/>
      <url>/2018/07/10/173-Binary-Search-Tree-Iterator/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p><p>Calling next() will return the next smallest number in the BST.</p><p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>we need to use O(1) time to find the smallest element, so we can use traverse the tree toward left, push the element into a stack, which will have the root in the bottom, smallest element(left most) element on the top.</li><li>One thing to notice is that, when we call hasNext(), we need to check whether if the current pop out root has a right subtree.<br>For example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line"> / \</span><br><span class="line">0   2</span><br></pre></td></tr></table></figure></li></ol><p>In above graph, we can see that <code>2</code> is smaller <code>3</code>. But we need to remember that we only push <code>[3,1,0]</code> into the stack. If we did not check for <code>1&#39;s</code> right subtree, we will get an incorrect next smaller element.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        self.stk = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            self.stk.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        node = self.stk.pop()</span><br><span class="line">        <span class="keyword">if</span> node.right: </span><br><span class="line">            p = node.right</span><br><span class="line">            <span class="keyword">while</span> p:</span><br><span class="line">                self.stk.append(p)</span><br><span class="line">                p = p.left</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.stk</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for binary tree</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode* n = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">int</span> res = n-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;right) &#123; <span class="comment">//Currently, n is the left most node, so we need to check if there's any right subtree of this n</span></span><br><span class="line">            n = n-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (n) &#123;</span><br><span class="line">                s.push(n);</span><br><span class="line">                n = n-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment">* BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment">* while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>108. Convert Sorted Array to Binary Search Tree</title>
      <link href="/2018/07/10/108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
      <url>/2018/07/10/108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><p>Given the sorted array: <code>[-10,-3,0,5,9]</code>,</p><p>One possible answer is: <code>[0,-3,9,-10,null,5]</code>, which represents the following height balanced BST:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>find node to create as root, binary search to get mid</li><li>find left and right children, left= [start, mid-1], right= [mid+1, end]</li><li>return root</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* head= helper(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid= (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//int mid= low +(high-low)/2;</span></span><br><span class="line">        <span class="comment">//this can avoid int overflow</span></span><br><span class="line">        </span><br><span class="line">        TreeNode* node= <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        node-&gt;left= helper(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right= helper(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>110. Balanced Binary Tree</title>
      <link href="/2018/07/10/110-Balanced-Binary-Tree/"/>
      <url>/2018/07/10/110-Balanced-Binary-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><p>a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example 1:</p><p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>Return true.</p><p>Example 2:</p><p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure></p><p>Return false.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ul><li>bottom-up method:<br>Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub tree<br>is balanced, and decides its return value.</li></ul><p>In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is <code>O(N)</code>, better than the first solution.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = check(root.left)</span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            right = check(root.right)</span><br><span class="line">            <span class="keyword">if</span> right == <span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> abs(left-right) &gt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> check(root) != <span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfsHeight</span> <span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftHeight = dfsHeight (root -&gt; left);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightHeight = dfsHeight (root -&gt; right);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max (leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfsHeight (root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)</p><ul><li>top-down solution<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span> <span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max (depth(root -&gt; left), depth (root -&gt; right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span> <span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left= depth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right= depth(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: O(N^2) for worst case</p><p>reference:<br><a href="https://goo.gl/25GVKA" target="_blank" rel="noopener">https://goo.gl/25GVKA</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>100. Same Tree</title>
      <link href="/2018/07/10/100-Same-Tree/"/>
      <url>/2018/07/10/100-Same-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given two binary trees, write a function to check if they are the same or not.</p><p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br></pre></td></tr></table></figure></p><p>Output: true<br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br></pre></td></tr></table></figure></p><p>Output: false<br>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br></pre></td></tr></table></figure></p><p>Output: false</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>if both of the input TreeNode* are NULL, return true</li><li>if one of them is NULL, return false</li><li>check for current values are equivalent to each others</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ((p-&gt;val == q-&gt;val) &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>617. Merge Two Binary Trees</title>
      <link href="/2018/07/10/617-Merge-Two-Binary-Trees/"/>
      <url>/2018/07/10/617-Merge-Two-Binary-Trees/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p><p>Example 1:<br>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">    1                         2                             </span><br><span class="line">   / \                       / \                            </span><br><span class="line">  3   2                     1   3                        </span><br><span class="line">     /                       \   \                      </span><br><span class="line">    5                         4   7</span><br></pre></td></tr></table></figure></p><p>Output:<br>Merged tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">    / \</span><br><span class="line">  4   5</span><br><span class="line">  / \   \ </span><br><span class="line">5   4   7</span><br></pre></td></tr></table></figure></p><p>Note: The merging process must start from the root nodes of both trees.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t1 &amp;&amp; t2)&#123;</span><br><span class="line">            TreeNode* tmp= <span class="keyword">new</span> TreeNode(t1-&gt;val+t2-&gt;val);</span><br><span class="line">            tmp-&gt;left= mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            tmp-&gt;right= mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t1? t1:t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/Nxp7M6" target="_blank" rel="noopener">https://goo.gl/Nxp7M6</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>226. Invert Binary Tree</title>
      <link href="/2018/07/10/226-Invert-Binary-Tree/"/>
      <url>/2018/07/10/226-Invert-Binary-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Invert a binary tree.</p><p>Example:</p><p>Input:</p><pre><code>    4  /   \  2     7/ \   / \1   3 6   9</code></pre><p>Output:</p><pre><code>    4  /   \  7     2/ \   / \9   6 3   1</code></pre><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>The basic idea is to swap the <code>left</code> and <code>right</code> node of the root. We can use recursive or non-recursive method to solve this question.</p><ul><li><p>recursive method</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        <span class="built_in">std</span>::swap(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>non-recursive method</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//use non-recursive method</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="comment">//stack: last in first out</span></span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            TreeNode* p= stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(p)&#123;</span><br><span class="line">                stk.push(p-&gt;left);</span><br><span class="line">                stk.push(p-&gt;right);</span><br><span class="line">                swap(p-&gt;left, p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>reference:<br><a href="https://goo.gl/9kLdfS" target="_blank" rel="noopener">https://goo.gl/9kLdfS</a><br><a href="https://goo.gl/nQJp7n" target="_blank" rel="noopener">https://goo.gl/nQJp7n</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>111. Minimum Depth of Binary Tree</title>
      <link href="/2018/07/09/111-Minimum-Depth-of-Binary-Tree/"/>
      <url>/2018/07/09/111-Minimum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><pre><code>  3/ \9  20  /  \15   7</code></pre><p>return its minimum depth = 2.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//NULL node no height</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> <span class="number">1</span>+minDepth(root-&gt;right); <span class="comment">//edge case for no left subtree</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>+minDepth(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+min(minDepth(root-&gt;left), minDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/mNYNmX" target="_blank" rel="noopener">https://goo.gl/mNYNmX</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>437. Path Sum III</title>
      <link href="/2018/07/09/437-Path-Sum-III/"/>
      <url>/2018/07/09/437-Path-Sum-III/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This question we can also use preorder traversal to solve it. That is to say, we visit current node, then check left and right subtree.</p><p>We need to maintain a variable <code>pre</code>, to store the sum of previous nodes. If <code>root-&gt;cal+pre</code> equal to target, then at least return 1. After that, we still need to check whether if adding other subtree can achieve target(might have zero or negative numbers).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//can start from root or left subtree or right subtree</span></span><br><span class="line">        <span class="keyword">return</span> helper(root, sum, <span class="number">0</span>)+ pathSum(root-&gt;left, sum)+pathSum(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//use pre to store previous levels sum</span></span><br><span class="line">        <span class="comment">//if root-&gt;cal+pre equal to target, then at least return 1</span></span><br><span class="line">        <span class="comment">//but still need to check whether if adding other subtree can achieve target(might have zero or negative numbers)</span></span><br><span class="line">        <span class="keyword">int</span> cur= pre+ root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> (cur== sum)+ helper(root-&gt;left, sum, cur)+ helper(root-&gt;right, sum, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: worst case $O(n^2)$, balanced tree: $T(n) = n + 2T(n/2)$ so $O(n*logn)$</p><p>However, previous brute-force solution is more time-consuming. For example <code>1-&gt;3-&gt;5</code>, we calculated: 1, 1+3, 1+3+5, 3, 3+5, 5.</p><ul><li>A more efficient implementation uses the <code>Prefix Sum</code> idea. We use a hash table (extra memory of order N). It would give us an $O(N)$ time complexity.</li><li>As we traverse down the tree, at an arbitrary node N, we store the sum until this node N <code>(sum_so_far (prefix) + N.val)</code>. in hash-table. Note this sum is the sum from root to N.</li><li>Now at a grand-child of N, say G, we can compute the sum from the root until G since we have the prefix_sum until this grandchild available.We pass in our recursive routine.</li><li>How do we know if we have a path of target sum which ends at this grand-child G? Say there are multiple such paths that end at G and say they start at A, B, C where A,B,C are predecessors of G. Then <code>sum(root-&gt;G) - sum(root-&gt;A) = target</code>. Therefore we can compute the <code>complement</code> at G as <code>sum_so_far+G.val-target</code> and look up the hash-table for the number of paths which had this sum</li><li>Now after we are done with a node and all its grandchildren, we remove it from the hash-table. This makes sure that the number of complement paths returned always correspond to paths that ended at a predecessor node.</li></ul><p><img src="image_1529701359.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prefixSum</span><span class="params">(self, root, target, cur, cache)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            complement = cur + root.val - target</span><br><span class="line">            <span class="keyword">if</span> complement <span class="keyword">in</span> cache:</span><br><span class="line">                self.res += cache[complement]</span><br><span class="line">            cache.setdefault(cur+root.val, <span class="number">0</span>)</span><br><span class="line">            cache[cur+root.val] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.prefixSum(root.left, target, cur+root.val, cache)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.prefixSum(root.right, target, cur+root.val, cache)</span><br><span class="line">            cache[cur+root.val] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.prefixSum(root, sum, <span class="number">0</span>, &#123;<span class="number">0</span>:<span class="number">1</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/6007336.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/6007336.html</a><br><a href="https://goo.gl/bYjbbn" target="_blank" rel="noopener">https://goo.gl/bYjbbn</a><br><a href="https://leetcode.com/problems/path-sum-iii/discuss/91892/Python-solution-with-detailed-explanation" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-iii/discuss/91892/Python-solution-with-detailed-explanation</a><br><a href="https://leetcode.com/problems/path-sum-iii/discuss/141424/Python-step-by-step-walk-through.-Easy-to-understand.-Two-solutions-comparison.-%3A-" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-iii/discuss/141424/Python-step-by-step-walk-through.-Easy-to-understand.-Two-solutions-comparison.-%3A-</a>)<br><a href="112-Path-Sum"></a><br><a href="113-Path-Sum-II"></a><br><a href="687-Longest-Univalue-Path"></a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>113. Path Sum II</title>
      <link href="/2018/07/09/113-Path-Sum-II/"/>
      <url>/2018/07/09/113-Path-Sum-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Given the below binary tree and sum = 22,</p><pre><code>  5 / \4   8</code></pre><p>   /   / \<br>  11  13  4<br> /  \    / \<br>7    2  5   1<br>Return:</p><p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This is a typical backtracking question. Design a backtrack helper function, use preorder traversal to include the path.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        helper(res, tmp, sum, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> sum, TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">//preorder traversal</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum-root-&gt;val ==<span class="number">0</span>) res.push_back(tmp);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) helper(res, tmp, sum-root-&gt;val, root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) helper(res, tmp, sum-root-&gt;val, root-&gt;right);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://goo.gl/VPHfpv" target="_blank" rel="noopener">https://goo.gl/VPHfpv</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>112. Path Sum</title>
      <link href="/2018/07/09/112-Path-Sum/"/>
      <url>/2018/07/09/112-Path-Sum/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Given the below binary tree and sum = 22,</p><pre><code>  5 / \4   8</code></pre><p>   /   / \<br>  11  13  4<br> /  \      \<br>7    2      1<br>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The basic idea is to subtract the value of current node from sum until it reaches a leaf node and the subtraction equals 0, then we know that we got a hit. Otherwise the subtraction at the end could not be 0.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> sum-root.val == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, sum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right, sum-root.val)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum-root-&gt;val==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/MkXt4r" target="_blank" rel="noopener">https://goo.gl/MkXt4r</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>222. Count Complete Tree Nodes</title>
      <link href="/2018/07/09/222-Count-Complete-Tree-Nodes/"/>
      <url>/2018/07/09/222-Count-Complete-Tree-Nodes/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a complete binary tree, count the number of nodes.</p><p>Note:</p><p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p><p>Example:</p><p>Input:<br>    1<br>   / \<br>  2   3<br> / \  /<br>4  5 6</p><p>Output: 6</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>A complete binary tree means every level is filled except for perhaps last level. To the extent that the last level is filled, it is filled left to right.<br>Therefore, we can know the following things.</p><ol><li>from traverse left subtree, we can obtain the maximum height of the tree.</li><li>if the tree is perfect binary tree(complete and full), it will have <code>2^h -1</code> nodes</li></ol><p>We use two pointer to count the height of <code>left</code> and <code>right</code>. If they’re equal, then the subtree of this root have totally <code>2^h -1</code> nodes. If not equal, then we recursively search <code>root-&gt;left</code> and <code>root-&gt;right</code>.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> hl= <span class="number">0</span>, hr= <span class="number">0</span>;</span><br><span class="line">        TreeNode* l= root, *r= root;</span><br><span class="line">        <span class="keyword">while</span>(l)&#123; hl++; l= l-&gt;left;&#125;</span><br><span class="line">        <span class="keyword">while</span>(r)&#123; hr++; r= r-&gt;right;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hl== hr) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, hl)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>+countNodes(root-&gt;left)+ countNodes(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: </p><p>reference:<br><a href="https://goo.gl/SAq511" target="_blank" rel="noopener">https://goo.gl/SAq511</a><br><a href="https://goo.gl/o9PEje" target="_blank" rel="noopener">https://goo.gl/o9PEje</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note-Tree</title>
      <link href="/2018/07/08/note-Tree/"/>
      <url>/2018/07/08/note-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><ul><li>Complete binary tree:<br>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.</li></ul><p><img src="Binary_search_tree_example.gif" alt=""></p><ul><li><p>Specific ordering property:<br>all left descendants &lt;= n &lt; all right descendants. Must be true for all node n.<br>Make sure to check whether if there’s any <code>duplicate</code> value. One definition is <code>no duplication</code>, the other is duplication will be on <code>right</code> or <code>either</code> side.</p></li><li><p>Complete Binary Tree:<br>Every level is filled except for perhaps last level. To the extent that the last level is filled, it is filled left to right.<br><img src="completetree.png" alt=""></p></li><li><p>Full Binary Tree<br>A full binary tree is every node has either zero or two children. That is, no nodes have only one children.</p></li><li><p>Perfect Binary Tree<br>Both full and complete. All leaf nodes are on same level, and this level have maximum nodes. Have exactly <code>2^h -1</code> nodes, h is number of levels(height).</p></li><li><p>Trie(Prefix Trees)<br>Each path down the tree would represent a word. Normally, have a <code>* node</code>(sometimes called <code>null node</code>)</p></li></ul><h1 id="Questions-to-ask-for-clarify"><a href="#Questions-to-ask-for-clarify" class="headerlink" title="Questions to ask for clarify"></a>Questions to ask for clarify</h1><p>What type of tree?</p><ul><li>binary tree, binary search tree. </li><li>balanced or unbalanced tree.<br>balanced means it ensures $O(logn)$ time to <code>insert</code> and <code>find</code>.</li><li>full binary tree: each node have two or zero children.</li><li>complete binary tree: only right bottom part is missing.</li></ul><p>empty tree<br>duplicate node. If it’s a BST, does duplicate node goes left or right?<br>skewed tree</p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> binary search tree </tag>
            
            <tag> binary tree </tag>
            
            <tag> complete binary tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>376. Wiggle Subsequence</title>
      <link href="/2018/07/06/376-Wiggle-Subsequence/"/>
      <url>/2018/07/06/376-Wiggle-Subsequence/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> greedy </tag>
            
            <tag> peak </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>698. Partition to K Equal Sum Subsets</title>
      <link href="/2018/07/05/698-Partition-to-K-Equal-Sum-Subsets/"/>
      <url>/2018/07/05/698-Partition-to-K-Equal-Sum-Subsets/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal.</p><p>Example 1:<br>Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4<br>Output: True<br>Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.<br>Note:</p><p>1 &lt;= k &lt;= len(nums) &lt;= 16.<br>0 &lt; nums[i] &lt; 10000.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>Assume sum is the sum of <code>nums[]</code> . The dfs process is to find a subset of <code>nums[]</code> which sum equals to <code>sum/k</code>. We use an array <code>visited[]</code> to record which element in <code>nums[]</code> is used. Each time when we get a <code>cur_sum = sum/k</code>, we will start from position 0 in <code>nums[]</code> to look up the elements that are not used yet and find another <code>cur_sum = sum/k</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartitionKSubsets</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># backtracking</span></span><br><span class="line">        <span class="comment"># since we don't have to print the result, we could use visited array to note if an element is used in a subset</span></span><br><span class="line">        </span><br><span class="line">        total = sum(nums)</span><br><span class="line">        <span class="keyword">if</span> total == <span class="number">0</span> <span class="keyword">or</span> total % k != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        visited = [<span class="number">0</span>]* len(nums)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(visited, nums, k, cur_sum, cur_num, start, target)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>: </span><br><span class="line">                <span class="comment"># we call backtrack when it's able to make k subsets</span></span><br><span class="line">                <span class="comment"># when there're k-1 subsets existed, we don't have to calculate the last</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum == target <span class="keyword">and</span> cur_num &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># successfully find a subset</span></span><br><span class="line">                <span class="keyword">return</span> backtrack(visited, nums, k<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, target)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                    visited[i] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> backtrack(visited, nums, k, cur_sum+nums[i], cur_num+<span class="number">1</span>, i+<span class="number">1</span>, target):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    visited[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> backtrack(visited, nums, k, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, total/k)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum= accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//can not form k subsets</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(nums.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, k, sum/k, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> curSum, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//only need to create one subset, current subset can do it</span></span><br><span class="line">        <span class="keyword">if</span>(curSum == target) <span class="keyword">return</span> helper(nums, k<span class="number">-1</span>, target, <span class="number">0</span>, <span class="number">0</span>, visited); <span class="comment">//achieve target, need to create k-1 more subset</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i]= <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(helper(nums, k, target, i+<span class="number">1</span>, curSum+nums[i], visited)) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            visited[i]= <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> partition </tag>
            
            <tag> subset </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>416. Partition Equal Subset Sum</title>
      <link href="/2018/07/05/416-Partition-Equal-Subset-Sum/"/>
      <url>/2018/07/05/416-Partition-Equal-Subset-Sum/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p>Note:<br>Each of the array element will not exceed 100.<br>The array size will not exceed 200.<br>Example 1:</p><p>Input: [1, 5, 11, 5]</p><p>Output: true</p><p>Explanation: The array can be partitioned as [1, 5, 5] and [11].<br>Example 2:</p><p>Input: [1, 2, 3, 5]</p><p>Output: false</p><p>Explanation: The array cannot be partitioned into equal sum subsets.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: nums)</span><br><span class="line">            sum+= n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sum %<span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//can not be partitioned into two subset</span></span><br><span class="line">        <span class="keyword">int</span> target= sum /<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(target+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= target; i&gt;= n; i--)&#123;</span><br><span class="line">                dp[i]= dp[i] || dp[i-n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>300. Longest Increasing Subsequence</title>
      <link href="/2018/07/01/300-Longest-Increasing-Subsequence/"/>
      <url>/2018/07/01/300-Longest-Increasing-Subsequence/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>For example,<br>Given [10, 9, 2, 5, 3, 7, 101, 18],<br>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p><p>Your algorithm should run in O(n2) complexity.</p><p>Follow up: Could you improve it to O(n log n) time complexity?</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//dp[i]: LIS when ends at nums[i]</span></span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt; nums[i])</span><br><span class="line">                    dp[i]= max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res= max(res, dp[i]); <span class="comment">//get the max value of LIS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n^2)<br>space complexity: O(1)</p><h1 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h1><p>The question also ask for O(nlogn) solution. </p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>343. Integer Break</title>
      <link href="/2018/07/01/343-Integer-Break/"/>
      <url>/2018/07/01/343-Integer-Break/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.</p><p>For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p><p>Note: You may assume that n is not less than 2 and not larger than 58.</p><p>Credits:<br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.<br><a href="https://goo.gl/CizU8W" target="_blank" rel="noopener">https://goo.gl/CizU8W</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>We can try to find the pattern,<br> num  divide into   product<br>  2       1+1          1<br>  3       2+1          2<br>  4       2+2          4<br>  5       2+3          6<br>  6       3+3          9<br>  7       3+2+2        12<br>  8       3+3+2        18</p><p>We can see that, all factors should be 2 or 3 (N &gt; 4). Also, since <code>3 * 3 &gt; 2 * 2 * 2</code>, we should try to have 3 as much as possible(N&gt;4). </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n ==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> product =<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">4</span>)&#123;</span><br><span class="line">            product *=<span class="number">3</span>;</span><br><span class="line">            n-=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        product *=n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>264. Ugly Number II</title>
      <link href="/2018/06/29/264-Ugly-Number-II/"/>
      <url>/2018/06/29/264-Ugly-Number-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Write a program to find the n-th ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</p><p>Note that 1 is typically treated as an ugly number, and n does not exceed 1690.</p><p>Credits:<br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>Let’s say we have an result array that contains every ugly number in it.<br><code>result[i]: ith ugly number</code></p><p>Now, how do we get the next ugly number, <code>result[i+1]</code>? The next ugly number must be one of these,<br><code>result[i]*2</code>, <code>result[i]*3</code>, <code>result[i]*5</code>. That is to say, if we know which to multiply, we can get <code>i+1th</code> ugly number. </p><p>We can use three different pointer to indicate three different counter for 2, 3, and 5. Each time we compare the product of these, and the least one is next ugly number.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>; <span class="comment">// for pointing the position of current 2, 3, 5</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n&gt; result.size())&#123;</span><br><span class="line">            result.push_back(min(result[i]*<span class="number">2</span>, min(result[j]*<span class="number">3</span>, result[k]*<span class="number">5</span>))); <span class="comment">//calculate which is the next minimum ugly number</span></span><br><span class="line">            <span class="keyword">if</span>(result.back() == result[i]*<span class="number">2</span>) ++i;</span><br><span class="line">            <span class="keyword">if</span>(result.back() == result[j]*<span class="number">3</span>) ++j;</span><br><span class="line">            <span class="keyword">if</span>(result.back() == result[k]*<span class="number">5</span>) ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
            <tag> heap </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>307. Range Sum Query - Mutable</title>
      <link href="/2018/06/28/307-Range-Sum-Query-Mutable/"/>
      <url>/2018/06/28/307-Range-Sum-Query-Mutable/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p><p>The update(i, val) function modifies nums by updating the element at index i to val.</p><p>Example:</p><p>Given nums = [1, 3, 5]</p><p>sumRange(0, 2) -&gt; 9<br>update(1, 2)<br>sumRange(0, 2) -&gt; 8<br>Note:</p><p>The array is only modifiable by the update function.<br>You may assume the number of calls to update and sumRange function is distributed evenly.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This question is a follow up for . If we use previous method to design the algorithm, it would be inefficient. The reason is that whenever we want to modify a value in the array, we would need to change the whole array after the modified one. </p><p>The following solution is based on <a href="https://en.wikipedia.org/wiki/Fenwick_tree" target="_blank" rel="noopener">Fenwick Tree</a>, which is an algorithm that can achieve O(logn) time for getting sum and modify value. </p><p><img src="fenwick.jpeg" alt="Fenwick Tree"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        num.resize(nums.size() +<span class="number">1</span>);</span><br><span class="line">        bit.resize(nums.size() +<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            update(i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff= val-num[i+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= i+<span class="number">1</span>; j&lt; num.size(); j += j&amp; -j)&#123; <span class="comment">//only modify logn elements for each iteration</span></span><br><span class="line">            bit[j] += diff;</span><br><span class="line">        &#125;</span><br><span class="line">        num[i+<span class="number">1</span>] = val;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        example:</span></span><br><span class="line"><span class="comment">        i= 4</span></span><br><span class="line"><span class="comment">         4: 0000 0100</span></span><br><span class="line"><span class="comment">        -4: 1111 1100</span></span><br><span class="line"><span class="comment">        only change bit[4] and bit[8]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(j + <span class="number">1</span>) - getSum(i);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j -= (j&amp;-j)) &#123;</span><br><span class="line">            res += bit[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj.update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> binary indexed tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>139. Word Break</title>
      <link href="/2018/06/28/139-Word-Break/"/>
      <url>/2018/06/28/139-Word-Break/</url>
      <content type="html"><![CDATA[<h2 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h2><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p><p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p><p>Return true because “leetcode” can be segmented as “leet code”.</p><p>UPDATE (2017/1/4):<br>The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The idea for the solution is that a given string <code>s</code> can be divided into two substring <code>s1</code> and <code>s2</code>. If <code>s1</code> and <code>s2</code> both fulfill the requirement, then complete the problem. Let’s create a dp array, which <code>dp[i]= 1</code> means we are able to find match in dictionary. </p><p>As we just said, the original string can treat as substrings. Therefore, we can use a two pointer to check whether if there’s matches in a string.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># DP</span></span><br><span class="line">        <span class="comment"># subproblem answer lead to final one</span></span><br><span class="line">        <span class="comment"># if we can find x is s[i+1:] in wordDict after completed s[0:i]</span></span><br><span class="line">        <span class="comment"># then return true</span></span><br><span class="line">        dp = [<span class="keyword">False</span>] * (len(s)+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//https://leetcode.com/problems/word-break/discuss/43814/C++-Dynamic-Programming-simple-and-fast-solution-(4ms)-with-optimization</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(wordDict.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size()+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> word = s.substr(j,i-j);</span><br><span class="line">                    <span class="keyword">if</span>(dict.find(word)!= dict.end())</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//next i</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><p>similar idea from previous one.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.length()+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: wordDict)</span><br><span class="line">            dict.insert(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= i<span class="number">-1</span>; j&gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dict.find(s.substr(j, i-j)) != dict.end())&#123;</span><br><span class="line">                        dp[i]= <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution-BFS"><a href="#Solution-BFS" class="headerlink" title="Solution BFS"></a>Solution BFS</h2><p>Modeled as a graph problem - every index is a vertex and every edge is a completed word<br>For example, the input string is “nightmare”, there are two ways to break it, “night mare” and “nightmare”. The graph would be<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0--&gt;5--&gt;9</span><br><span class="line"></span><br><span class="line">|__ __ _^</span><br></pre></td></tr></table></figure></p><p>The question is simply to check if there is a path from 0 to 9. The most efficient way is traversing the graph using BFS with the help of a queue and a hash set. The hash set is used to keep track of the visited nodes to avoid repeating the same work.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">        queue = deque()                                                                           </span><br><span class="line">        visited = set()                                                                                     </span><br><span class="line">        queue.append(<span class="number">0</span>)</span><br><span class="line">        visited.add(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            curr_index = queue.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(curr_index, len(s)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> s[curr_index:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    <span class="keyword">if</span> i == len(s):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    queue.append(i)</span><br><span class="line">                    visited.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>337. House Robber III</title>
      <link href="/2018/06/27/337-House-Robber-III/"/>
      <url>/2018/06/27/337-House-Robber-III/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p><p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \   \ </span><br><span class="line">  3   1</span><br></pre></td></tr></table></figure></p><p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \   \ </span><br><span class="line">1   3   1</span><br></pre></td></tr></table></figure></p><p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><a href="/2018/06/27/198-House-Robber/" title="198. House Robber">198. House Robber</a><a href="/2018/06/27/213-House-Robber-II/" title="213. House Robber II">213. House Robber II</a><p>This problem change the array to a tree structure but the idea is similar. We use a recursive function to sum up the value that starts from <code>root</code> or from its child(<code>root-&gt;left</code> and <code>root-&gt;right</code>). </p><ul><li>Solution1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> val= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            val+= rob(root-&gt;right-&gt;right)+ rob(root-&gt;right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            val+= rob(root-&gt;left-&gt;right)+ rob(root-&gt;left-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(root-&gt;val+ val, rob(root-&gt;right)+rob(root-&gt;left));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>However, this solution has a bad time complexity. It is because we need to recalculate many things. For example, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    6</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \   \ </span><br><span class="line">1   3   2</span><br></pre></td></tr></table></figure><p>If we start from <code>6</code>, and we calculate the <code>1, 3, 2</code>(grandchildren) value 1 time.<br>However, after we calculate <code>4, 5</code>, we’ll need to calculate <code>1, 3, 2</code> again.<br>This seems not efficient enough, we can use a map to record the node that we’ve already calculated.</p><ul><li>Solution 2<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">//use map to store every treeNode in the tree, so that we won't have to recalculate</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> robSub(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">robSub</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> val= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.find(root) != <span class="built_in">map</span>.end()) <span class="keyword">return</span> <span class="built_in">map</span>.at(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            val+= robSub(root-&gt;right-&gt;right)+ robSub(root-&gt;right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            val+= robSub(root-&gt;left-&gt;right)+ robSub(root-&gt;left-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        val = max(root-&gt;val+ val, robSub(root-&gt;right)+robSub(root-&gt;left));</span><br><span class="line">        <span class="built_in">map</span>[root]= val;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>Can we do even better?<br>The major problem is we need to loop up for those already calculated subproblems.<br>Actually, for each root, there are two scenarios: it is robbed or is not. rob(root) does not distinguish between these two cases, so “information is lost as the recursion goes deeper and deeper”, which results in repeated subproblems.<br>If we were able to maintain the information about the two scenarios for each tree root, let’s see how it plays out. Redefine rob(root) as a new function which will return an <code>array of two elements</code>, the first element of which denotes the maximum amount of money that can be robbed if root is <code>not robbed</code>, while the second element signifies the maximum amount of money robbed if it <code>is robbed</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res= robSub(root);</span><br><span class="line">        <span class="keyword">return</span> max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; robSub(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">0</span>); <span class="comment">//0: w/o root. 1: w/ root</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left= robSub(root-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right= robSub(root-&gt;right);</span><br><span class="line">        <span class="comment">// result without root = add left[1](include left-&gt;val) and right[1](include right-&gt;val)</span></span><br><span class="line">        <span class="comment">// but maximum value could be bypass root-&gt;left or root-&gt;right</span></span><br><span class="line">        <span class="comment">// example:</span></span><br><span class="line">        <span class="comment">// 4-1-1-3</span></span><br><span class="line">        res[<span class="number">0</span>]= max(left[<span class="number">0</span>], left[<span class="number">1</span>])+ max(right[<span class="number">0</span>], right[<span class="number">1</span>]); </span><br><span class="line">        </span><br><span class="line">        res[<span class="number">1</span>]= root-&gt;val+left[<span class="number">0</span>]+right[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>213. House Robber II</title>
      <link href="/2018/06/27/213-House-Robber-II/"/>
      <url>/2018/06/27/213-House-Robber-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p><p>Example 1:</p><p>Input: [2,3,2]<br>Output: 3<br>Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),<br>             because they are adjacent houses.<br>Example 2:</p><p>Input: [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>             Total amount you can rob = 1 + 3 = 4.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This problem is pretty similar to <a href="/2018/06/27/198-House-Robber/" title="198. House Robber">198. House Robber</a>. First, let’s look at the example <code>[1,2,3,1]</code>. If you choose to rob <code>nums[0]</code>, then you must not rob <code>nums[size-1]</code>, and your right boundary would be <code>nums[size-2]</code>. On the other hand, if you choose to rob <code>nums[size-1]</code>, then you must not rob <code>nums[0]</code>, that means you could only start robbing from <code>nums[1]</code>.</p><ul><li>rob nums[0]: <code>0...n-2</code></li><li>not rob nums[0]: <code>1...n-1</code></li></ul><p>Therefore, we can either separate the array into two different array or we can do the search twice. </p><p>In previous question, <a href="/2018/06/27/198-House-Robber/" title="198. House Robber">198. House Robber</a>, we use a simple for loop to do the dynamic programming. We can further extract the for loop as a helper function, which takes left and right boundary as input. </p><p>If you don’t want to build another function, you can use for loop twice as well, like solution 2.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># since it's a circle, if rob nums[0], then can't rob nums[-1]</span></span><br><span class="line">        <span class="comment"># if rob nums[1], then can't rob nums[0]</span></span><br><span class="line">        <span class="comment"># two variables to keep rob, not_rob </span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(nums, i, j)</span>:</span></span><br><span class="line">            <span class="comment"># copy array like nums[:-2] takes O(n), so passing index in here</span></span><br><span class="line">            rob, not_rob = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(i, j+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># the rob, not_rob is from previous iteration</span></span><br><span class="line">                <span class="comment"># if decide not to rob in x, then max is from max(rob, not_rob)</span></span><br><span class="line">                rob, not_rob = not_rob+nums[x], max(rob, not_rob) </span><br><span class="line">            <span class="keyword">return</span> max(rob, not_rob)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rob_0 = helper(nums, <span class="number">0</span>, len(nums)<span class="number">-2</span>)</span><br><span class="line">            rob_1 = helper(nums, <span class="number">1</span>, len(nums)<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> max(rob_0, rob_1)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n= nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n? nums[<span class="number">0</span>]: <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(help(nums, <span class="number">0</span>, n<span class="number">-2</span>), help(nums, <span class="number">1</span>, n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur= <span class="number">0</span>, pre= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= left; i&lt;= right; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = max(nums[i]+ pre, cur);</span><br><span class="line">            pre= cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">0</span>, cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = pre1;</span><br><span class="line">            pre1 = cur1;</span><br><span class="line">            cur1 = max(temp + nums[i], pre1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = pre2;</span><br><span class="line">            pre2 = cur2;</span><br><span class="line">            cur2 = max(temp + nums[i], pre2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(cur1, cur2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>Slicing a list is actually $O(n)$ space in Python. In our case, <code>nums[1:]</code>, <code>nums[:-1]</code> create copies, to avoid this, we can pass indices into the <code>simple_rob</code> function instead of sliced lists. Below is the less elegant, but true $O(1)$ space solution:</p><p>reference:<br><a href="https://goo.gl/NYAGsU" target="_blank" rel="noopener">https://goo.gl/NYAGsU</a><br><a href="https://goo.gl/RA1cb9" target="_blank" rel="noopener">https://goo.gl/RA1cb9</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>198. House Robber</title>
      <link href="/2018/06/27/198-House-Robber/"/>
      <url>/2018/06/27/198-House-Robber/</url>
      <content type="html"><![CDATA[<h2 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure></p><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).</span><br><span class="line">Total amount you can rob = 2 + 9 + 1 = 12.</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>DP solution:<br>For dp solution, we need to know what is the recursion function in it. As you can see in the example, once you pick <code>ith</code> house to rob, you must not came from <code>i-1th</code> house. Therefore, let’s try to think it in this way:<br>Let us look at the case <code>n = 1</code>, clearly <code>f(1) = A1</code>.<br>Now, let us look at <code>n = 2</code>, which <code>f(2) = max(A1, A2)</code>.<br>For <code>n = 3</code>, you have basically the following two options:</p><ol><li>Rob the third house, and add its amount to the first house’s amount.</li><li>Do not rob the third house, and stick with the maximum amount of the first two houses.<br>Clearly, you would want to choose the larger of the two options at each step.<br>Therefore, we could summarize the formula as following:<br><code>f(k) = max(f(k – 2) + Ak, f(k – 1))</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>]*len(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        dp = [<span class="number">0</span>]*len(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+ nums[i], dp[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Edge Cases</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> *max_element(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>]; <span class="comment">//Represent starting from the odd house</span></span><br><span class="line">        dp[<span class="number">1</span>]=max(dp[<span class="number">0</span>], nums[<span class="number">1</span>]);<span class="comment">//Represent max loot at the even house</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//odd, even</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Edge Cases</span></span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">2</span>) <span class="keyword">return</span> *max_element(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> odd,even;</span><br><span class="line">        odd=nums[<span class="number">0</span>]; <span class="comment">//Represent starting from the odd house</span></span><br><span class="line">        even=nums[<span class="number">1</span>];<span class="comment">//Represent starting from the even house</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">2</span>==<span class="number">0</span>) <span class="comment">//Even</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(odd&lt;even) odd=even; <span class="comment">//If robbing even path gives more value then put odd as even</span></span><br><span class="line">                even+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//Odd</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(even&lt;odd) even=odd;</span><br><span class="line">                odd+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(even,odd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5. Longest Palindromic Substring</title>
      <link href="/2018/06/26/5-Longest-Palindromic-Substring/"/>
      <url>/2018/06/26/5-Longest-Palindromic-Substring/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>Example:<br>Input: “babad”<br>Output: “bab”</p><p>Note: “aba” is also a valid answer.</p><p>Example:<br>Input: “cbbd”<br>Output: “bb”<br><a href="https://goo.gl/5cmsJy" target="_blank" rel="noopener">https://goo.gl/5cmsJy</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The basic idea is to use an iterative function to check whether if the left and right character is the same as each others. One thing to notice is that, the center might be in the middle of two character, for example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aabbc, length 5, mid is index[3]</span><br><span class="line">aabb, length 4, mid is in the middle of index[1] index [2]</span><br></pre></td></tr></table></figure></p><p>Therefore, we need to check whether if the center is a character or not. We can use a subfunction to help us check. By using two pointer, <code>left</code> and <code>right</code>, we can use two different input:</p><ol><li>left == right:<br>expand from 1 character<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a a b c d</span><br><span class="line">    |</span><br><span class="line">   r l</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>left != right:<br>expand from 2 characters<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a b c d</span><br><span class="line">  | | </span><br><span class="line">  l r</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>first time </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> c1, <span class="keyword">int</span> c2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> l = c1, r = c2;</span><br><span class="line">      <span class="keyword">int</span> n = s.length();</span><br><span class="line">      <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= n<span class="number">-1</span> &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> s.substr(l+<span class="number">1</span>, r-l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = s.length();</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">      <span class="built_in">string</span> longest = s.substr(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// a single char itself is a palindrome</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> p1 = expandAroundCenter(s, i, i);</span><br><span class="line">        <span class="keyword">if</span> (p1.length() &gt; longest.length())</span><br><span class="line">          longest = p1;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> p2 = expandAroundCenter(s, i, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p2.length() &gt; longest.length())</span><br><span class="line">          longest = p2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>second time:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp1= expand(s, i, i);</span><br><span class="line">            <span class="built_in">string</span> tmp2= expand(s, i, i+<span class="number">1</span>);</span><br><span class="line">            res= res.length()&gt; tmp1.length() ? res: tmp1;</span><br><span class="line">            res= res.length()&gt; tmp2.length() ? res: tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">expand</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= l, right= r;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;= s.length() &amp;&amp; s[left]==s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(left+<span class="number">1</span>, right-left<span class="number">-1</span>); <span class="comment">//since the while loop break because (left-- and right++)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>339. Nested List Weight Sum</title>
      <link href="/2018/06/26/339-Nested-List-Weight-Sum/"/>
      <url>/2018/06/26/339-Nested-List-Weight-Sum/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p><p>Example 1:<br>Given the list [[1,1],2,[1,1]], return 10. (four 1’s at depth 2, one 2 at depth 1)</p><p>Example 2:<br>Given the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4<em>2 + 6</em>3 = 27)</p><h1 id="Solution-DFS"><a href="#Solution-DFS" class="headerlink" title="Solution DFS:"></a>Solution DFS:</h1><p>Traverse the entire array, </p><ul><li>if it’s integer, add to result</li><li>if it’s a list, go to next layer</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depthSum</span><span class="params">(self, nestedList: List[NestedInteger])</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(nestedNode, level)</span>:</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nestedNode:</span><br><span class="line">                <span class="keyword">if</span> node.isInteger():</span><br><span class="line">                    res += node.getInteger()*level</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += dfs(node.getList(), level+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(nestedList, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nestedList, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nestedList.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nestedList[i].isInteger())</span><br><span class="line">                res+= (nestedList[i].getInteger()*depth);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res+= dfs(nestedList[i].getList(), depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution-BFS"><a href="#Solution-BFS" class="headerlink" title="Solution BFS"></a>Solution BFS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depthSum</span><span class="params">(self, nestedList: List[NestedInteger])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nestedList) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nestedList:</span><br><span class="line">            stack.append((n, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            next, d = stack.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> next.isInteger():</span><br><span class="line">                res += d * next.getInteger()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> next.getList():</span><br><span class="line">                    stack.append((i,d+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> easy </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>364. Nested List Weight Sum II</title>
      <link href="/2018/06/26/364-Nested-List-Weight-Sum-II/"/>
      <url>/2018/06/26/364-Nested-List-Weight-Sum-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p><p>Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p><p>Example 1:<br>Given the list [[1,1],2,[1,1]], return 8. (four 1’s at depth 1, one 2 at depth 2)</p><p>Example 2:<br>Given the list [1,[4,[6]]], return 17. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1<em>3 + 4</em>2 + 6*1 = 17)</p><h1 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h1><p>related question: <a href="/2018/06/26/339-Nested-List-Weight-Sum/" title="339. Nested List Weight Sum">339. Nested List Weight Sum</a></p><p>In the given example, <code>[[1,1],2,[1,1]]</code>, we can treat it like this.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   2    = 2*2</span><br><span class="line">1 1 1 1 = 4*1</span><br></pre></td></tr></table></figure></p><p>Therefore, we can use dfs to traverse the whole nestedList, and use a vector<int> to store each layer’s sum.</int></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nestedList, level, cache)</span>:</span></span><br><span class="line">        self.max_level = max(self.max_level, level)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nestedList:</span><br><span class="line">            <span class="keyword">if</span> x.isInteger():</span><br><span class="line">                cache[level] += x.getInteger()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.helper(x.getList(), level+<span class="number">1</span>, cache)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depthSumInverse</span><span class="params">(self, nestedList: List[NestedInteger])</span> -&gt; int:</span></span><br><span class="line">        cache, self.max_level = defaultdict(int), <span class="number">-1</span></span><br><span class="line">        self.helper(nestedList, <span class="number">1</span>, cache)</span><br><span class="line">        total_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> cache.items():</span><br><span class="line">            total_sum = total_sum + v*(self.max_level-k+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> total_sum</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : nestedList) &#123;</span><br><span class="line">            helper(a, <span class="number">0</span>, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res += v[i] * (v.size() - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(NestedInteger ni, <span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= v.size()) v.resize(depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ni.isInteger()) &#123;</span><br><span class="line">            v[depth] += ni.getInteger();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : ni.getList()) &#123;</span><br><span class="line">                helper(a, depth + <span class="number">1</span>, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)<br>space complexity: O(n)</p><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/5615583.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5615583.html</a><br><a href="https://goo.gl/MTbKTN" target="_blank" rel="noopener">https://goo.gl/MTbKTN</a><br><a href="https://goo.gl/FtsdeX" target="_blank" rel="noopener">https://goo.gl/FtsdeX</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>106. Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link href="/2018/06/21/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/"/>
      <url>/2018/06/21/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</url>
      <content type="html"><![CDATA[<p>#Problem description:</p><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given</p><p>inorder = [9,3,15,20,7]<br>postorder = [9,15,7,20,3]<br>Return the following binary tree:</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7</p><p>#Solution:<br>This problem is pretty similar to <a href="/2018/06/05/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/" title="105. Construct Binary Tree from Preorder and Inorder Traversal">105. Construct Binary Tree from Preorder and Inorder Traversal</a>.</p><p>We can see the inorder and postorder array like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           in order</span><br><span class="line">+------------+------+-------------+</span><br><span class="line">| left child | root | right child |</span><br><span class="line">+------------+------+-------------+  </span><br><span class="line"></span><br><span class="line">            post order</span><br><span class="line">+------------+-------------+------+</span><br><span class="line">| left child | right child | root |</span><br><span class="line">+------------+-------------+------+</span><br></pre></td></tr></table></figure></p><p>As you can see, <code>root</code> is in the last position in <code>postorder</code> array. After we find the root, we can get the length of each subarray as follows:</p><ul><li>left tree:<br>inOrder[1 .. p - 1]<br>postOrder[1 .. p - 1]</li><li>right tree:<br>inOrder[p + 1 .. n]<br>postOrder[p .. n - 1]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deal(<span class="number">0</span>, inorder.size() - <span class="number">1</span>, <span class="number">0</span>, postorder.size() - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deal</span><span class="params">(<span class="keyword">int</span> leftInorder, <span class="keyword">int</span> rightInorder, <span class="keyword">int</span> leftPostorder, <span class="keyword">int</span> rightPostorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rightInorder &lt; leftInorder || rightPostorder &lt; leftPostorder) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* rt = <span class="keyword">new</span> TreeNode(postorder[ rightPostorder ]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rightInorder - leftInorder; ++i)</span><br><span class="line">            <span class="keyword">if</span> (inorder[leftInorder + i] == rt -&gt; val) &#123;</span><br><span class="line">                p = i; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        rt -&gt; left  = deal(leftInorder, leftInorder + p - <span class="number">1</span>, leftPostorder, leftPostorder + p - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">        rt -&gt; right = deal(leftInorder + p + <span class="number">1</span>, rightInorder, leftPostorder + p, rightPostorder - <span class="number">1</span>, inorder, postorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>523. Continuous Subarray Sum</title>
      <link href="/2018/06/20/523-Continuous-Subarray-Sum/"/>
      <url>/2018/06/20/523-Continuous-Subarray-Sum/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>/<em><br>Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n</em>k where n is also an integer.</p><p>Example 1:<br><code>Input: [23, 2, 4, 6, 7],  k=6</code><br>Output: True<br>Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</p><p>Example 2:<br><code>Input: [23, 2, 6, 4, 7],  k=6</code><br>Output: True<br>Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</p><p>Note:<br>The length of the array won’t exceed 10,000.<br>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The main idea is to find whether if there’s two subarray that contains equal remainder.<br>Let’s say we have a sum of subarray from <code>i...j</code> look like this:<br>  <code>a[i]+a[i+1]+...+a[j]=n1k+q;</code></p><p>If we can find a <code>n</code>, which is greater than j , that qualified for the following equation,<br>  <code>n&gt;j</code> and <code>a[i]+a[i+1]+...+a[j]+...+a[n]=n2k+q;</code></p><p>We can derive a result that the sum of subarray from <code>j...n</code> should be:<br>  <code>a[j+1]+...+a[n]=(n2−n1)k</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>= &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            sum+= nums[i];</span><br><span class="line">            <span class="keyword">if</span>(k != <span class="number">0</span>)</span><br><span class="line">                sum = sum%k;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.count(sum))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i- <span class="built_in">map</span>[sum] &gt;<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">map</span>[sum]= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)<br>space complexity: O(n)</p><p>reference:<br><a href="https://goo.gl/sieyWJ" target="_blank" rel="noopener">https://goo.gl/sieyWJ</a><br><a href="https://goo.gl/fb8NoY" target="_blank" rel="noopener">https://goo.gl/fb8NoY</a><br><a href="https://goo.gl/fK1cNG" target="_blank" rel="noopener">https://goo.gl/fK1cNG</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>75. Sort Colors</title>
      <link href="/2018/06/20/75-Sort-Colors/"/>
      <url>/2018/06/20/75-Sort-Colors/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p>Note: You are not suppose to use the library’s sort function for this problem.</p><p>Example:</p><p>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]<br>Follow up:</p><p>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.<br>Could you come up with a one-pass algorithm using only constant space?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We can use three pointers to solve this question.<br>low: point to <code>0</code><br>mid: point to <code>1</code><br>high: point to <code>2</code></p><p>If we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array.</p><p>To achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends.</p><p>Take this example:</p><p>Assume our input is: 1 0 2 2 1 0 (short for simplicity).</p><p>Running the algorithm by hand would look something like:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1 0 2 2 1 0</span><br><span class="line">^         ^</span><br><span class="line">L         H</span><br><span class="line">M</span><br><span class="line"></span><br><span class="line">Mid != 0 || 2</span><br><span class="line">Mid++</span><br><span class="line"></span><br><span class="line">1 0 2 2 1 0</span><br><span class="line">^ ^       ^</span><br><span class="line">L M       H</span><br><span class="line"></span><br><span class="line">Mid == 0</span><br><span class="line">Swap Low and Mid</span><br><span class="line">Mid++</span><br><span class="line">Low++</span><br><span class="line"></span><br><span class="line">0 1 2 2 1 0</span><br><span class="line">  ^ ^     ^</span><br><span class="line">  L M     H</span><br><span class="line"></span><br><span class="line">Mid == 2</span><br><span class="line">Swap High and Mid</span><br><span class="line">High--</span><br><span class="line"></span><br><span class="line">0 1 0 2 1 2</span><br><span class="line">  ^ ^   ^</span><br><span class="line">  L M   H</span><br><span class="line"></span><br><span class="line">Mid == 0</span><br><span class="line">Swap Low and Mid</span><br><span class="line">Mid++</span><br><span class="line">Low++</span><br><span class="line"></span><br><span class="line">0 0 1 2 1 2</span><br><span class="line">    ^ ^ ^</span><br><span class="line">    L M H</span><br><span class="line"></span><br><span class="line">Mid == 2</span><br><span class="line">Swap High and Mid</span><br><span class="line">High--</span><br><span class="line"></span><br><span class="line">0 0 1 1 2 2</span><br><span class="line">    ^ ^</span><br><span class="line">    L M</span><br><span class="line">      H</span><br><span class="line"></span><br><span class="line">Mid &lt;= High is our exit case</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low= <span class="number">0</span>, mid= <span class="number">0</span>, high= nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(mid &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums[mid], nums[low]); <span class="comment">//change the value in position 'mid', 'low'</span></span><br><span class="line">                low++;</span><br><span class="line">                mid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == <span class="number">1</span>)&#123; </span><br><span class="line">                mid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                swap(nums[mid], nums[high]);</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/iKdeLx" target="_blank" rel="noopener">https://goo.gl/iKdeLx</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> sort </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>119. Pascal&#39;s Triangle II</title>
      <link href="/2018/06/19/119-Pascal-s-Triangle-II/"/>
      <url>/2018/06/19/119-Pascal-s-Triangle-II/</url>
      <content type="html"><![CDATA[<p>#Problem description:</p><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.</p><p>Note that the row index starts from 0.</p><p>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p><p>Example:</p><p>Input: 3<br>Output: [1,3,3,1]</p><p>Could you optimize your algorithm to use only O(k) extra space?</p><p>#Solution:</p><ol><li>Init an array with size of rowIndex+1.</li><li>Increment the value from the end to beginning.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Init:</span><br><span class="line">  ---------------------</span><br><span class="line">  1 0....             0</span><br><span class="line"></span><br><span class="line">i=1:</span><br><span class="line">  ---------------------</span><br><span class="line">  1 1 0....           0 </span><br><span class="line"></span><br><span class="line">i=2:</span><br><span class="line">  ---------------------</span><br><span class="line">  1 2 1 0....         0</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A(rowIndex+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        A[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;rowIndex+<span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">1</span>; j--)</span><br><span class="line">                A[j] += A[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> rowIndex == <span class="number">0</span>: <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> rowIndex == <span class="number">1</span>: <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        list = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(rowIndex+<span class="number">1</span>)]</span><br><span class="line">        list[<span class="number">0</span>] = [<span class="number">1</span>]</span><br><span class="line">        list[<span class="number">1</span>] = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, rowIndex+<span class="number">1</span>):</span><br><span class="line">            list[i] = [<span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">                list[i][j] = list[i - <span class="number">1</span>][j - <span class="number">1</span>] + list[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> list[rowIndex]</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/4Nkj1c" target="_blank" rel="noopener">https://goo.gl/4Nkj1c</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> easy </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>717. 1-bit and 2-bit Characters</title>
      <link href="/2018/06/19/717-1-bit-and-2-bit-Characters/"/>
      <url>/2018/06/19/717-1-bit-and-2-bit-Characters/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).</p><p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p><p>Example 1:<br>Input:<br>bits = [1, 0, 0]<br>Output: True<br>Explanation:<br>The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.<br>Example 2:<br>Input:<br>bits = [1, 1, 1, 0]<br>Output: False<br>Explanation:<br>The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.<br>Note:</p><p>1 &lt;= len(bits) &lt;= 1000.<br>bits[i] is always 0 or 1.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The idea is to determine whether if the last <code>0</code> is a <code>0</code> itself or belong to a <code>10</code>. We can use a pointer to walk through the array. If the <code>bits[i] == 1</code> then we know we will have a two-bit character. On the other hand, if it’s a <code>0</code>, then we just increment 1.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; bits.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (bits[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == bits.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> easy </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="/2018/06/16/236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
      <url>/2018/06/16/236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p>Given the following binary search tree:  root = <code>[3,5,1,6,2,0,8,null,null,7,4]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line">6      _2       0       8</span><br><span class="line">      /  \</span><br><span class="line">      7   4</span><br></pre></td></tr></table></figure></p><p>Example 1:</p><p>Input: root = <code>[3,5,1,6,2,0,8,null,null,7,4]</code>, p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of of nodes 5 and 1 is 3.<br>Example 2:</p><p>Input: root = <code>[3,5,1,6,2,0,8,null,null,7,4]</code>, p = 5, q = 4<br>Output: 5<br>Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself<br>             according to the LCA definition.<br>Note:</p><p>All of the nodes’ values will be unique.<br>p and q are different and both values will exist in the binary tree.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>Recursively search left and right subtree.<br>If can find a <code>root-&gt;val == p or q</code>, then this root is at least contains one of the node’s ancestor.</p><p>So we find in left subtree and right subtree, if both left and right can find a value, then current root is the ancestor.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = right = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == p-&gt;val ||root-&gt;val == q-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(!left) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(!right) <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(logn)$</p><p>reference:<br><a href="https://goo.gl/NJbDFm" target="_blank" rel="noopener">https://goo.gl/NJbDFm</a><br><a href="https://goo.gl/7BNspr" target="_blank" rel="noopener">https://goo.gl/7BNspr</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> apple </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>654. Maximum Binary Tree</title>
      <link href="/2018/06/16/654-Maximum-Binary-Tree/"/>
      <url>/2018/06/16/654-Maximum-Binary-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:</p><p>The root is the maximum number in the array.<br>The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.<br>The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.<br>Construct the maximum tree by the given array and output the root node of this tree.</p><p>Example 1:<br>Input: [3,2,1,6,0,5]<br>Output: return the tree root node representing the following tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   6</span><br><span class="line"> /   \</span><br><span class="line">3     5</span><br><span class="line"> \    / </span><br><span class="line">  2  0   </span><br><span class="line">    \</span><br><span class="line">     1</span><br></pre></td></tr></table></figure></p><p>Note:<br>The size of the given array will be in the range [1,1000].</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mx= INT_MIN, mx_idx= <span class="number">0</span>; <span class="comment">//find the max num and it's index</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; mx)&#123;</span><br><span class="line">                mx= nums[i];</span><br><span class="line">                mx_idx= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//spilt the nums into half</span></span><br><span class="line">        TreeNode* root= <span class="keyword">new</span> TreeNode(mx);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.begin(), nums.begin()+ mx_idx);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right= <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.begin()+mx_idx+<span class="number">1</span>, nums.end());</span><br><span class="line">        root-&gt;left = constructMaximumBinaryTree(left);</span><br><span class="line">        root-&gt;right= constructMaximumBinaryTree(right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/Nqk7oZ" target="_blank" rel="noopener">https://goo.gl/Nqk7oZ</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>127. Word Ladder</title>
      <link href="/2018/06/14/127-Word-Ladder/"/>
      <url>/2018/06/14/127-Word-Ladder/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p><p>Only one letter can be changed at a time.<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>Note:</p><p>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.<br>Example 1:</p><p>Input:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>Output: 5</p><p>Explanation: As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length 5.<br>Example 2:</p><p>Input:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code></p><p>Output: 0</p><p>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The key idea is to substitute every single character in the <code>beginWord</code> and check whether if there’s any match in the <code>wordList</code>. One thing you need to notice is that you can not use a word twice; therefore, once a word in <code>wordList</code> is used(used means we can find a match after replacing the character), you need to remove it from the list.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(wordList.begin(), wordList.end()); <span class="comment">//put into unordered_set for efficient search</span></span><br><span class="line">        <span class="keyword">if</span> (!dict.count(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        q.push(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = beginWord.length();</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> size = q.size(); size &gt; <span class="number">0</span>; size--) &#123; </span><br><span class="line">                <span class="built_in">string</span> w = q.front(); <span class="comment">//pick a word in queue to do the search</span></span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123; <span class="comment">//the description stated that the length of each word would be the same</span></span><br><span class="line">                    <span class="keyword">char</span> ch = w[i]; <span class="comment">//change each character to find if there's a match</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++) &#123;</span><br><span class="line">                        w[i] = j;</span><br><span class="line">                        <span class="comment">// Found the solution</span></span><br><span class="line">                        <span class="keyword">if</span> (w == endWord) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Not in dict, skip it</span></span><br><span class="line">                        <span class="keyword">if</span> (!dict.count(w)) <span class="keyword">continue</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Remove new word from dict, because we can only use each word in dictionary once</span></span><br><span class="line">                        dict.erase(w);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Add new word into queue</span></span><br><span class="line">                        q.push(w);                    </span><br><span class="line">                    &#125;</span><br><span class="line">                    w[i] = ch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://goo.gl/yJo3ou" target="_blank" rel="noopener">https://goo.gl/yJo3ou</a><br><a href="https://goo.gl/JNAsQE" target="_blank" rel="noopener">https://goo.gl/JNAsQE</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>200. Number of Islands</title>
      <link href="/2018/06/14/200-Number-of-Islands/"/>
      <url>/2018/06/14/200-Number-of-Islands/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p>Example 1:</p><p>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br></pre></td></tr></table></figure></p><p>Output: 1</p><p>Example 2:</p><p>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br></pre></td></tr></table></figure></p><p>Output: 3</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The idea is to treat the 2d grid map as an undirected graph and there is an edge between two horizontally or vertically adjacent nodes of value <code>1</code>.</p><p>Linear scan the 2d grid map, if a node contains a <code>1</code>, then it is a root node that triggers a Depth First Search. During DFS, every visited node should be set as <code>0</code> to mark as visited node. Count the number of root nodes that trigger DFS, this number would be the number of islands since each DFS starting at some root identifies an island.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(grid, i, j)</span>:</span></span><br><span class="line">            grid[i][j] = <span class="string">'-'</span></span><br><span class="line">            <span class="keyword">if</span> i<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[i<span class="number">-1</span>][j] == <span class="string">"1"</span>: dfs(grid, i<span class="number">-1</span>, j)</span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span> &lt; len(grid) <span class="keyword">and</span> grid[i+<span class="number">1</span>][j] == <span class="string">"1"</span>: dfs(grid, i+<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">if</span> j<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[i][j<span class="number">-1</span>] == <span class="string">"1"</span>: dfs(grid, i, j<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span> &lt; len(grid[<span class="number">0</span>]) <span class="keyword">and</span> grid[i][j+<span class="number">1</span>] == <span class="string">"1"</span>: dfs(grid, i, j+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">"1"</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    dfs(grid, i, j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr= grid.size();</span><br><span class="line">        <span class="keyword">int</span> nc= grid[<span class="number">0</span>].size();</span><br><span class="line">      </span><br><span class="line">          grid[r][c] = <span class="string">'0'</span>; <span class="comment">//we already check this island on outer loop, so mark it out</span></span><br><span class="line">          <span class="keyword">if</span>(r<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c]== <span class="string">'1'</span>) dfs(grid, r<span class="number">-1</span>, c); <span class="comment">//check if there's any connected '1', mark it out too</span></span><br><span class="line">          <span class="keyword">if</span>(r+<span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c]== <span class="string">'1'</span>) dfs(grid, r+<span class="number">1</span>, c); <span class="comment">//mark them out is because we already count on outer loop</span></span><br><span class="line">          <span class="keyword">if</span>(c<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>]== <span class="string">'1'</span>) dfs(grid, r, c<span class="number">-1</span>);</span><br><span class="line">          <span class="keyword">if</span>(c+<span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>]== <span class="string">'1'</span>) dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> nr= grid.size();</span><br><span class="line">          <span class="keyword">if</span>(!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> nc= grid[<span class="number">0</span>].size();</span><br><span class="line">          <span class="keyword">int</span> num_island= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">0</span>; r&lt; nr; r++)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">0</span>; c&lt; nc; c++)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(grid[r][c] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                      ++num_island; <span class="comment">//count this first appear island</span></span><br><span class="line">                      dfs(grid, r, c);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> num_island;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(mn)<br>space complexity: O(mn), in worst case the grid is filled with island, DFS goes m*n deep</p><h2 id="Solution-Union-Find"><a href="#Solution-Union-Find" class="headerlink" title="Solution: Union Find"></a>Solution: Union Find</h2><p>Create array parent, the size is grid size. It’s to log the parent for <code>grid[i][j]</code></p><p>Calculate the number of <code>1</code> at the beginning, then decrease the number when we union an island.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        row, col = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> row <span class="keyword">or</span> <span class="keyword">not</span> col:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        self.count = sum(grid[i][j] == <span class="string">'1'</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(row) <span class="keyword">for</span> j <span class="keyword">in</span> range(col))</span><br><span class="line">        parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(row*col)]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> parent[x] != x:</span><br><span class="line">                <span class="keyword">return</span> find(parent[x])</span><br><span class="line">            <span class="keyword">return</span> parent[x]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            xroot, yroot = find(x), find(y)</span><br><span class="line">            <span class="keyword">if</span> xroot == yroot: <span class="keyword">return</span> </span><br><span class="line">            parent[xroot] = yroot</span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># update the parent when we see 1 in grid</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'0'</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                index = i*col + j</span><br><span class="line">                <span class="keyword">if</span> i+<span class="number">1</span> &lt; row <span class="keyword">and</span> grid[i+<span class="number">1</span>][j] == <span class="string">'1'</span>:</span><br><span class="line">                    union(index, index + col)</span><br><span class="line">                <span class="keyword">if</span> j+<span class="number">1</span> &lt; col <span class="keyword">and</span> grid[i][j+<span class="number">1</span>] == <span class="string">'1'</span>:</span><br><span class="line">                    union(index, index + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/S4Hig9" target="_blank" rel="noopener">https://goo.gl/S4Hig9</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> union find </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>102. Binary Tree Level Order Traversal</title>
      <link href="/2018/06/14/102-Binary-Tree-Level-Order-Traversal/"/>
      <url>/2018/06/14/102-Binary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This is a very basic problem, we can use dfs to solve this problem. One thing to notice is that we need to use a <code>depth</code> variable to store the level where we are.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; levelOrder(TreeNode *root) &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == depth) <span class="comment">//need to insert a new layer</span></span><br><span class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        res[depth].push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        dfs(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: O(n)</p><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><p>Use BFS to do traversal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;);</span><br><span class="line">            <span class="keyword">int</span> size= q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; size; i++)&#123;</span><br><span class="line">                TreeNode* tmp= q.front(); q.pop();</span><br><span class="line">                res[res.size()<span class="number">-1</span>].push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left) q.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right) q.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> bfs </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>179. Largest Number</title>
      <link href="/2018/06/14/179-Largest-Number/"/>
      <url>/2018/06/14/179-Largest-Number/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,2]</span><br><span class="line">Output: &quot;210&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,30,34,5,9]</span><br><span class="line">Output: &quot;9534330&quot;</span><br></pre></td></tr></table></figure></p><p>Note: The result may be very large, so you need to return a string instead of an integer.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>First, sort the array based on the combination of two integer.<br>After sorting, we can use the array to create result string.<br>For example:<br>Input: [10,2]<br>  “2”+”10”-&gt; 210<br>  “10”+”2”-&gt; 102</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> to_string(a)+to_string(b)&gt; to_string(b)+to_string(a);&#125;);</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            res = res + to_string(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>406. Queue Reconstruction by Height</title>
      <link href="/2018/06/13/406-Queue-Reconstruction-by-Height/"/>
      <url>/2018/06/13/406-Queue-Reconstruction-by-Height/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.</p><p>Note:<br>The number of people is less than 1,100.</p><p>Example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="comment">//example:</span></span><br><span class="line">        <span class="comment">//before sorting: [7,1], [7,0], [5,2], [4,3]</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        sort(people.begin(), people.end(),[](pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p1, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p2)&#123; <span class="comment">//lamda function</span></span><br><span class="line">            <span class="keyword">return</span> p1.first &gt; p2.first || (p1.first == p2.first &amp;&amp; p1.second &lt; p2.second);</span><br><span class="line">            <span class="comment">//true: [6,0], [4,0] or [6,2], [6,4]</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//after sorting: [7,0], [7,1], [5,2], [4,3]</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; sol;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> person : people)&#123; </span><br><span class="line">            sol.insert(sol.begin() + person.second, person); </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/XfqSmq" target="_blank" rel="noopener">https://goo.gl/XfqSmq</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> greddy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>341. Flatten Nested List Iterator</title>
      <link href="/2018/06/13/341-Flatten-Nested-List-Iterator/"/>
      <url>/2018/06/13/341-Flatten-Nested-List-Iterator/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a nested list of integers, implement an iterator to flatten it.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Given the list [[1,1],2,[1,1]],</span><br><span class="line"></span><br><span class="line">By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Given the list [1,[4,[6]]],</span><br><span class="line"></span><br><span class="line">By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>first, we can store all the elements in reverse order with a stack. The reason that we need to use reverse order is because <code>Stack is Last in First out</code>. We can use the following example to explain.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">index:  0 1 2 3 4 5</span><br><span class="line">data:   a b e d c q</span><br><span class="line"></span><br><span class="line">        ___________</span><br><span class="line">stack   a b e d c q|</span><br><span class="line">        -----------</span><br><span class="line">        |         |  </span><br><span class="line">      last push   |</span><br><span class="line">              first push</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nestedList)</span>:</span></span><br><span class="line">        self.queue = collections.deque(nestedList)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.popleft().getInteger()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.queue:</span><br><span class="line">            <span class="keyword">if</span> self.queue[<span class="number">0</span>].isInteger():</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            first = self.queue.popleft()</span><br><span class="line">            self.queue.extendleft(first.getList()[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="comment">//because the stack is LIFO, so if we want to do A item in stack first, then we need to push item A in the last</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nestedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; </span><br><span class="line">            s.push(nestedList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NestedInteger t = s.top(); </span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">return</span> t.getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            NestedInteger t = s.top(); </span><br><span class="line">            <span class="keyword">if</span> (t.isInteger()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//if this element is a number, return true and let next() do the job</span></span><br><span class="line">            s.pop(); <span class="comment">//this element is a list</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t.getList().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                s.push(t.getList()[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;NestedInteger&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p> reference:<br> <a href="https://goo.gl/Ut4Pns" target="_blank" rel="noopener">https://goo.gl/Ut4Pns</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>98. Validate Binary Search Tree</title>
      <link href="/2018/06/13/98-Validate-Binary-Search-Tree/"/>
      <url>/2018/06/13/98-Validate-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Explanation: The input is: [5,1,4,null,null,3,6]. The root node’s value<br>             is 5 but its right child’s value is 4.</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>Binary search tree:<br>left subtree &lt; node &lt; right subtree<br>this looks like a sorted array, so we can use a stack to keep nodes when we do <code>inorder traversal</code>.</p><p>We can use a variable to store left node and compare with current one.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> validate(root, prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validate</span><span class="params">(TreeNode* root, TreeNode* &amp;prev)</span> </span>&#123;<span class="comment">//do Inorder traversal</span></span><br><span class="line">        <span class="comment">//1. find toward left until the end</span></span><br><span class="line">        <span class="comment">//2. set this leftest node as prev</span></span><br><span class="line">        <span class="comment">//3. check if prev(left) node is smaller than root</span></span><br><span class="line">        <span class="comment">//4. check right subtree</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">if</span> (!validate(root-&gt;left, prev)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; root-&gt;val &lt;= prev-&gt;val ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//previous node is from left side, so it should be smaller than right side node</span></span><br><span class="line">        prev = root; </span><br><span class="line">        <span class="keyword">return</span> validate(root-&gt;right, prev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(logn)$</p><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><p>Another solution is to use BFS, with a stack.<br>Find the left most node, and then start to validate.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p = root, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (p || !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *t = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span> (pre &amp;&amp; t-&gt;val &lt;= pre-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre = t;</span><br><span class="line">            p = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link href="/2018/06/12/150-Evaluate-Reverse-Polish-Notation/"/>
      <url>/2018/06/12/150-Evaluate-Reverse-Polish-Notation/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p><p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p><p>Note:</p><p>Division between two integers should truncate toward zero.<br>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.<br>Example 1:</p><p>Input: [“2”, “1”, “+”, “3”, “<em>“]<br>Output: 9<br>Explanation: ((2 + 1) </em> 3) = 9<br>Example 2:</p><p>Input: [“4”, “13”, “5”, “/“, “+”]<br>Output: 6<br>Explanation: (4 + (13 / 5)) = 6<br>Example 3:</p><p>Input: [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”]<br>Output: 22<br>Explanation:<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = tokens.back(); <span class="comment">//start from back, check if it's operand or operator</span></span><br><span class="line">        tokens.pop_back();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s != <span class="string">"+"</span> &amp;&amp; s != <span class="string">"-"</span> &amp;&amp; s != <span class="string">"*"</span> &amp;&amp; s != <span class="string">"/"</span>) </span><br><span class="line">            <span class="keyword">return</span> stoi(s); <span class="comment">//it's a number</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> r2 = evalRPN(tokens), r1 = evalRPN(tokens); <span class="comment">//s is a operator, so we go deeper to find the operand of it.</span></span><br><span class="line">        <span class="comment">//notice that r2 is close to back, so need to call it first.</span></span><br><span class="line">        <span class="comment">//1, 2, /</span></span><br><span class="line">        <span class="comment">//(1/2)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"+"</span>) <span class="keyword">return</span> r1 + r2;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"-"</span>) <span class="keyword">return</span> r1 - r2;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"*"</span>) <span class="keyword">return</span> r1 * r2;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"/"</span>) <span class="keyword">return</span> r1 / r2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>STL container-Stack</title>
      <link href="/2018/06/12/STL-container-Stack/"/>
      <url>/2018/06/12/STL-container-Stack/</url>
      <content type="html"><![CDATA[<p>Definition:<br><code>LIFO</code> stack<br>Stacks are a type of container adaptor, specifically designed to operate in a LIFO context (last-in first-out), where elements are inserted and extracted only from one end of the container.</p><p>One thing to be notice is that there’re several different container that would be used to </p>]]></content>
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>241. Different Ways to Add Parentheses</title>
      <link href="/2018/06/10/241-Different-Ways-to-Add-Parentheses/"/>
      <url>/2018/06/10/241-Different-Ways-to-Add-Parentheses/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;2-1-1&quot;</span><br><span class="line">Output: [0, 2]</span><br><span class="line">Explanation: </span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;2*3-4*5&quot;</span><br><span class="line">Output: [-34, -14, -10, -10, 10]</span><br><span class="line">Explanation: </span><br><span class="line">(2*(3-(4*5))) = -34 </span><br><span class="line">((2*3)-(4*5)) = -14 </span><br><span class="line">((2*(3-4))*5) = -10 </span><br><span class="line">(2*((3-4)*5)) = -10 </span><br><span class="line">(((2*3)-4)*5) = 10</span><br></pre></td></tr></table></figure><p>#Solution:<br>The key of this problem is that every operators in the string could be the last operator to be operated.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diffWaysToCompute(<span class="built_in">string</span> input) &#123;</span><br><span class="line">        <span class="comment">//output every results of calculation</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; input.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i] == <span class="string">'+'</span> || input[i] == <span class="string">'-'</span> || input[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result1= diffWaysToCompute(input.substr(<span class="number">0</span>, i));</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result2= diffWaysToCompute(input.substr(i+<span class="number">1</span>));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> n1: result1)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> n2: result2)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(input[i] == <span class="string">'+'</span>)</span><br><span class="line">                            res.push_back(n1+n2);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(input[i] == <span class="string">'-'</span>)</span><br><span class="line">                            res.push_back(n1-n2);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            res.push_back(n1*n2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res.empty())</span><br><span class="line">            res.push_back(atoi(input.c_str()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>319. Bulb Switcher</title>
      <link href="/2018/06/09/319-Bulb-Switcher/"/>
      <url>/2018/06/09/319-Bulb-Switcher/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>the initial state all bulbs are off.</p><p>if at last the bulb was toggled odd number of times, it is on.<br>if toggled even number of times, it is off.</p><p>simple enough, and that number is determined by how many factors a number has.<br>note that every number has 1 and itself as a factor. and if it has multiple times of a factor<br>it only counted once.</p><p>1 ——— 1</p><p>2 ——— 1, 2</p><p>3 ——— 1, 3</p><p>4 ——— 1, 2, 4</p><p>5 ——— 1, 5</p><p>6 ——— 1, 2, 3, 6</p><p>7 ——— 1, 7</p><p>8 ——— 1, 2, 4, 8</p><p>9 ——— 1, 3, 9</p><p>see that only square numbers like 1, 4 and 9 has odd number of factors.<br>bulbs at those numbers will left on after all the rounds of toggle.</p><p>so basically, we calculate how many square numbers are there within a given number.<br>and we can get it simply by calculate the square root of that number. of course the decimal part is eliminated.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq(nums.begin(), nums.end()); <span class="comment">//put all elements in priority queue</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) </span><br><span class="line">            pq.pop(); <span class="comment">//remove the elements that is greater than Kth element</span></span><br><span class="line">        <span class="keyword">return</span> pq.top(); <span class="comment">//Now the largest one is Kth </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://leetcode.com/problems/bulb-switcher/discuss/77112/Share-my-o(1)-solution-with-explanation" target="_blank" rel="noopener">https://leetcode.com/problems/bulb-switcher/discuss/77112/Share-my-o(1)-solution-with-explanation</a><br><a href="https://goo.gl/xSEhEb" target="_blank" rel="noopener">https://goo.gl/xSEhEb</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> math </tag>
            
            <tag> brainteaser </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>8. String to Integer (atoi)</title>
      <link href="/2018/06/09/8-String-to-Integer-atoi/"/>
      <url>/2018/06/09/8-String-to-Integer-atoi/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>discards all leading white spaces</li><li>sign of the number</li><li>check overflow, </li><li>invalid input</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[i] == <span class="string">' '</span>) &#123; <span class="comment">//remove white space</span></span><br><span class="line">            i++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>) &#123; <span class="comment">//check the sign of string</span></span><br><span class="line">            sign = <span class="number">1</span> - <span class="number">2</span> * (str[i] == <span class="string">'-'</span>); <span class="comment">//if it equals to '-', then sign is -1</span></span><br><span class="line">            i++; <span class="comment">//move to next position</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base &gt;  INT_MAX / <span class="number">10</span> || (base == INT_MAX / <span class="number">10</span> &amp;&amp; str[i] - <span class="string">'0'</span> &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="comment">//INT_MAX = 2147483647, so if the base equals to (INT_MAX/10), which is 214748364</span></span><br><span class="line">                <span class="comment">//we must check whether if adding the new str[i] would cause overflow</span></span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="number">1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            base  = <span class="number">10</span> * base + (str[i++] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> base * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><ol><li>clean every whitespace</li><li>check the sign by <code>-</code> or <code>+</code></li><li>if first character is not number, it will not go into while loop.</li><li>remember to check the INT_MAX, and return INT_MIN if sign is negative.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i= <span class="number">0</span>, sign= <span class="number">1</span>, res= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">            i++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check sign of the number</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">            sign = str[i]== <span class="string">'-'</span>? <span class="number">-1</span>: <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i]&lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; INT_MAX/<span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; str[i] - <span class="string">'0'</span> &gt; <span class="number">7</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> sign== <span class="number">1</span>? INT_MAX: INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            res= res*<span class="number">10</span>+(str[i++]-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> string </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>148. Sort List</title>
      <link href="/2018/06/08/148-Sort-List/"/>
      <url>/2018/06/08/148-Sort-List/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Sort a linked list in O(n log n) time using constant space complexity.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The description is asking for algorithm that runs within O(nlogn). Therefore, only quicksort, merge sort, heap sort can meet the requirement. </p><ol><li>First of all, we cut the list into half, the code is widely use, make sure to memorize it.</li><li>Then we keep cut it into half, until there’s only one node left.</li><li>Start merging the list and sort it.</li></ol><p><img src="sortlist.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *prev= head, *slow= head, *fast= head;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123; </span><br><span class="line">            <span class="comment">//fast runs twice than slow, so when fast reach end, prev would be the half</span></span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="comment">//cut list into half</span></span><br><span class="line">        <span class="comment">//1. head-&gt;...-&gt;prev-&gt;NULL</span></span><br><span class="line">        <span class="comment">//2. slow-&gt;...-&gt;endNode-&gt;NULL</span></span><br><span class="line">        </span><br><span class="line">        ListNode* l1 = sortList(head);</span><br><span class="line">        ListNode* l2 = sortList(slow);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2; </span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = merge(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = merge(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(nlogn)<br>space complexity: O(logn), it’s the tree’s depth</p><p>reference:<br><a href="https://goo.gl/uJF4wn" target="_blank" rel="noopener">https://goo.gl/uJF4wn</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> sort </tag>
            
            <tag> merge sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>347. Top K Frequent Elements</title>
      <link href="/2018/06/07/347-Top-K-Frequent-Elements/"/>
      <url>/2018/06/07/347-Top-K-Frequent-Elements/</url>
      <content type="html"><![CDATA[<h2 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h2><p>Given a non-empty array of integers, return the k most frequent elements.</p><p>For example,<br>Given [1,1,1,2,2,3] and k = 2, return [1,2].</p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.<br>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>In the problem description, it ask for an algorithm that has time complexity better than O(n log n). We can use bucket sort.</p><ol><li>Create a map to count the element appearance in array, use elements value as key, which takes O(n)</li><li>Then create a 2d array to classify elements with item’s frequency</li><li>Search from the highest to kth frequently item.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        buckets = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num,freq <span class="keyword">in</span> collections.Counter(nums).items():</span><br><span class="line">            print(<span class="string">"num "</span>, num, <span class="string">", freq "</span>, freq)</span><br><span class="line">            buckets[-freq].append(num)</span><br><span class="line">        print(buckets)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> list(itertools.chain(*buckets))[:k]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n: nums)</span><br><span class="line">            ++<span class="built_in">map</span>[n]; <span class="comment">//put elements in map, increase the frequency</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; buckets(nums.size()+<span class="number">1</span>); <span class="comment">//size()+1 is because the sequence might full with the same element</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p: <span class="built_in">map</span>)</span><br><span class="line">            buckets[p.second].push_back(p.first); <span class="comment">//use frequency as index, put elements with same frequency into the same box</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= buckets.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; ans.size() &lt; k; --i)&#123; <span class="comment">//start from right side, because we want to find top k frequent</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num: buckets[i])&#123;</span><br><span class="line">                ans.push_back(num);</span><br><span class="line">                <span class="keyword">if</span>(ans.size() == k)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)<br>space complexity: O(n)</p><h2 id="Solution-2-Heap"><a href="#Solution-2-Heap" class="headerlink" title="Solution 2 Heap"></a>Solution 2 Heap</h2><p>Thought process:<br>Idea is similar to bucket sort. Build frequency map. Then use heap to make the <code>highest frequency</code> element on heap.peek. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># build frequency map</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># use heap to sort by frequency</span></span><br><span class="line">        hq = []</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dic:</span><br><span class="line">            heapq.heappush(hq, (dic[key], key))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># get the top kth</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">            res.append(heapq.heappop(hq)[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time: <code>O(NlogN)</code><br>space: <code>O(N)</code></p><p><strong>Improvment</strong>:</p><p>We don’t have to keep all the elements in heap, just the <code>top K</code> ones. So we can pop out elements when there’s a higher frequency appeared.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># build frequency map</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># use heap to sort by frequency</span></span><br><span class="line">        hq = []</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dic:</span><br><span class="line">            heapq.heappush(hq, (dic[key], key))</span><br><span class="line">            <span class="keyword">if</span> len(hq) &gt; k:</span><br><span class="line">                heapq.heappop(hq)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># get the top kth</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> hq:</span><br><span class="line">            tmp = heapq.heappop(hq)</span><br><span class="line">            res.append(tmp[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>time: <code>O(NlogK)</code><br>space: <code>O(N)</code></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
            <tag> heap </tag>
            
            <tag> bucket sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/2018/06/06/49-Group-Anagrams/"/>
      <url>/2018/06/06/49-Group-Anagrams/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an array of strings, group anagrams together.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>All inputs will be in lowercase.<br>The order of your output does not matter.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The idea is to use an <code>unordered_map</code> to store those strings that are anagrams. We use the <code>sorted string</code> as the key and the string itself as the value. The strings are stored in a multiset since there may be duplicates. Moreover, multiset will sort them by default as we desire.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s: strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = s; </span><br><span class="line">            sort(tmp.begin(), tmp.end());  <span class="comment">//use the sorted string as key to store every similar strings</span></span><br><span class="line">            <span class="built_in">map</span>[tmp].insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m: <span class="built_in">map</span>)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp(m.second.begin(), m.second.end());</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: O(nlogn)</p><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:</span><br><span class="line">        # Use a hash map, and sort the different words in order to compare them.</span><br><span class="line">        # You can only use immutable types as a key in a hash map, so we use tuples as keys.</span><br><span class="line">        # Tuples are just an immutable collection of items, basically an immutable list.</span><br><span class="line">        # Doing tuple(sorted(word)) returns a list of letters sorted alphabetically, ex:</span><br><span class="line">        # word = &quot;eat&quot;</span><br><span class="line">        # sorted(word) = [&apos;a&apos;, &apos;e&apos;, &apos;t&apos;]</span><br><span class="line">        # tuple(sorted(word)) = (&apos;a&apos;, &apos;e&apos;, &apos;t&apos;)</span><br><span class="line">        group = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        for word in strs:</span><br><span class="line">            # Make the word tuple the key, and a list of words as the value.</span><br><span class="line">            key = tuple(sorted(word))</span><br><span class="line">            </span><br><span class="line">            # Here, the [] parameter in the .get function is an optional value to return if the specified</span><br><span class="line">            # key does not exist. It safeguards if we try to add a value to a key that&apos;s not in the map yet.</span><br><span class="line">            group[key] = group.get(key, []) + [word]</span><br><span class="line">            # print(type(key)) (a tuple)</span><br><span class="line">            # print(type(group[key])) (a list)</span><br><span class="line">            </span><br><span class="line">        # More explanation of the above:</span><br><span class="line">        # Sort the current word, make it a tuple, and use it as a key.</span><br><span class="line">        # Add the un-sorted word as the value for that key.</span><br><span class="line">        # Since keys are unique in maps, next time you sort a word and get the same tuple,</span><br><span class="line">        # just add/concatenate the un-sorted word to the value of the existing key, making it a list.</span><br><span class="line">        </span><br><span class="line">        # A note about list.append() vs the + operator on lists:</span><br><span class="line">        # .append() modifies an existing list, mutating it. It doesn&apos;t return anything. (newList = oldList.append(3) fails)</span><br><span class="line">        # The + operator concatenates two lists and returns a new one.</span><br><span class="line">        </span><br><span class="line">        # Returns a list of all the values in the map. So, a list of lists</span><br><span class="line">        return group.values()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>138. Copy List with Random Pointer</title>
      <link href="/2018/06/06/138-Copy-List-with-Random-Pointer/"/>
      <url>/2018/06/06/138-Copy-List-with-Random-Pointer/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.<br>Return a deep copy of the list.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li><p>Copy the list within the original list</p><p> original: A→B→C</p><p> after: A→A’→B→B’→C→C’</p></li><li><p>Copy the random pointer. Notice need to check if it’s <code>None</code></p></li><li>Separate two lists</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            newNode = Node(p.val)</span><br><span class="line">            newNode.next = p.next</span><br><span class="line">            p.next = newNode</span><br><span class="line">            p = p.next.next</span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p.random:</span><br><span class="line">                p.next.random = p.random.next</span><br><span class="line">            p = p.next.next</span><br><span class="line">            </span><br><span class="line">        copy, p = head.next, head.next</span><br><span class="line">        <span class="keyword">while</span> p.next:</span><br><span class="line">            head.next = p.next</span><br><span class="line">            head = head.next</span><br><span class="line">            p.next = head.next</span><br><span class="line">            p = p.next</span><br><span class="line">        head.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> copy</span><br></pre></td></tr></table></figure><p><img style="width: 100%; height: 100%" src="138. Copy List with Random Pointer.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        RandomListNode *newHead, *l1, *l2;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (l1 = head; l1 != <span class="literal">NULL</span>; l1 = l1-&gt;next-&gt;next) &#123;</span><br><span class="line">            l2 = <span class="keyword">new</span> RandomListNode(l1-&gt;label);</span><br><span class="line">            l2-&gt;next = l1-&gt;next;</span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        newHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (l1 = head; l1 != <span class="literal">NULL</span>; l1 = l1-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;random != <span class="literal">NULL</span>) l1-&gt;next-&gt;random = l1-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (l1 = head; l1 != <span class="literal">NULL</span>; l1 = l1-&gt;next) &#123;</span><br><span class="line">            l2 = l1-&gt;next;</span><br><span class="line">            l1-&gt;next = l2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2-&gt;next != <span class="literal">NULL</span>) l2-&gt;next = l2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        RandomListNode *newhead, *l1, *l2;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        l1= head;</span><br><span class="line">        <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">            l2= <span class="keyword">new</span> RandomListNode(l1-&gt;label);</span><br><span class="line">            l2-&gt;next= l1-&gt;next;</span><br><span class="line">            l1-&gt;next= l2;</span><br><span class="line">            l1= l1-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newhead= head-&gt;next;</span><br><span class="line">        l1= head;</span><br><span class="line">        l2= newhead;</span><br><span class="line">        <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;random)</span><br><span class="line">                l1-&gt;next-&gt;random= l1-&gt;random-&gt;next;</span><br><span class="line">            l1= l1-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        l1= head;</span><br><span class="line">        <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">            l2= l1-&gt;next;</span><br><span class="line">            l1-&gt;next= l2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2-&gt;next)</span><br><span class="line">                l2-&gt;next= l2-&gt;next-&gt;next;</span><br><span class="line">            l1= l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/bq52sh" target="_blank" rel="noopener">https://goo.gl/bq52sh</a><br><a href="https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1)-and-linear-time-complexity-O(N)/42652" target="_blank" rel="noopener">https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1)-and-linear-time-complexity-O(N)/42652</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>535. Encode and Decode TinyURL</title>
      <link href="/2018/06/06/535-Encode-and-Decode-TinyURL/"/>
      <url>/2018/06/06/535-Encode-and-Decode-TinyURL/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>TinyURL is a URL shortening service where you enter a URL such as <a href="https://leetcode.com/problems/design-tinyurl" target="_blank" rel="noopener">https://leetcode.com/problems/design-tinyurl</a> and it returns a short URL such as <a href="http://tinyurl.com/4e9iAk" target="_blank" rel="noopener">http://tinyurl.com/4e9iAk</a>.</p><p>Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>use two unordered_map to store the relation of original url and shorten url, <code>shot2long</code> and <code>long2short</code>.</li><li>The whole process can be divided into 2 parts<ol><li>encode: <ul><li>input would be original string</li><li>create a random <code>6 character string</code>, which means we need to have a dictionary to search which character to use.</li><li>after created <code>6 character string</code>, need to check whether if it’s already used.</li></ul></li><li>decode:<ul><li>the input would be shorten url string</li><li>extract 6 character string from input, search whether it is stored in the map.</li></ul></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()&#123;</span><br><span class="line">        dist= <span class="string">"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line">        short2long.clear();</span><br><span class="line">        long2short.clear();</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">encode</span><span class="params">(<span class="built_in">string</span> longUrl)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> _return;</span><br><span class="line">        <span class="keyword">if</span>(long2short.find(longUrl) != long2short.end())</span><br><span class="line">            _return = long2short[longUrl];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> idx= <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> tmp=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">                tmp.push_back(dist[rand() % <span class="number">62</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">while</span>(short2long.count(tmp))&#123;</span><br><span class="line">                tmp[idx] = dist[rand() % <span class="number">62</span>];</span><br><span class="line">                idx = (idx +<span class="number">1</span> )%<span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            short2long[tmp] = longUrl;</span><br><span class="line">            long2short[longUrl] = tmp;</span><br><span class="line">            _return = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt; "http://tinyurl.com/"+_return&lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://tinyurl.com/"</span>+_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decode</span><span class="params">(<span class="built_in">string</span> shortUrl)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> _return;</span><br><span class="line">        </span><br><span class="line">        _return = shortUrl.substr(shortUrl.find_last_of(<span class="string">'/'</span>)+<span class="number">1</span>);</span><br><span class="line">        _return = short2long.count(_return) ? short2long[_return]: shortUrl;</span><br><span class="line">        <span class="keyword">return</span> _return;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; short2long, long2short;</span><br><span class="line">    <span class="built_in">string</span> dist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Solution solution;</span></span><br><span class="line"><span class="comment">// solution.decode(solution.encode(url));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>340. Longest Substring with At Most K Distinct Characters</title>
      <link href="/2018/06/06/340-Longest-Substring-with-At-Most-K-Distinct-Characters/"/>
      <url>/2018/06/06/340-Longest-Substring-with-At-Most-K-Distinct-Characters/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a string, find the length of the longest substring T that contains at most k distinct characters.</p><p>For example, Given s = “eceba” and k = 2,</p><p>T is “ece” which its length is 3.</p><p>Solution:<br>This problem is pretty similar to . Just change the checking size part to k.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++m[s[i]];</span><br><span class="line">            <span class="keyword">while</span> (m.size() &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[s[left]] == <span class="number">0</span>) m.erase(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>159. Longest Substring with At Most Two Distinct Characters</title>
      <link href="/2018/06/06/159-Longest-Substring-with-At-Most-Two-Distinct-Characters/"/>
      <url>/2018/06/06/159-Longest-Substring-with-At-Most-Two-Distinct-Characters/</url>
      <content type="html"><![CDATA[<h2 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h2><p>Given a string s , find the length of the longest substring t  that contains at most 2 distinct characters.</p><p>Example 1:</p><p>Input: “eceba”<br>Output: 3<br>Explanation: t is “ece” which its length is 3.<br>Example 2:</p><p>Input: “ccaabbb”<br>Output: 5<br>Explanation: t is “aabbb” which its length is 5.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>This question belong to the same category as those such as “longest substring without repeating characters”, “minimum window substring”, and “substring with concatenation of all words”. To solve this kind of question we can use two pointers and a hash table. When the key of the hash table is char, we can simply use an array as the hash table. The most important idea in solving this kind of questions is how to update the <code>start</code> pointer.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dic = defaultdict(int)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            dic[s[end]] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> len(dic) &gt; <span class="number">2</span>:</span><br><span class="line">                dic[s[start]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> dic[s[start]] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">del</span> dic[s[start]]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res &lt; (end-start+<span class="number">1</span>):</span><br><span class="line">                res = end-start+<span class="number">1</span></span><br><span class="line">            <span class="comment"># if not res or len(res) &lt; len(s[start:end+1]):</span></span><br><span class="line">            <span class="comment">#     res = s[start:end+1]</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++m[s[i]];</span><br><span class="line">            <span class="keyword">while</span> (m.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[s[left]] == <span class="number">0</span>) m.erase(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">-1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">//current position character is the same as previous one</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; s[right] != s[i]) &#123;</span><br><span class="line">                res = max(res, i - left);</span><br><span class="line">                left = right + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//1. first time would be have two different character</span></span><br><span class="line">            <span class="comment">//2. after that, j means: when see different character, then move the end pointer j to previous substring</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(<span class="keyword">int</span>(s.length()) - left, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        idea: use a map to track how many distinct characters we have right now.</span></span><br><span class="line"><span class="comment">              two pointers to traverse the whole string, adding/subtracting the result length</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        two pointers, start and end. </span></span><br><span class="line"><span class="comment">        end: to traverse the whole string, increasing the length</span></span><br><span class="line"><span class="comment">        start: if we have two distinct chars, use start to substract the length</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> start= <span class="number">0</span>, end= <span class="number">0</span>, res= <span class="number">0</span>, count= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> send= s[end];</span><br><span class="line">            <span class="built_in">map</span>[send]++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[send] == <span class="number">1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            end++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(count &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> stmp= s[start];</span><br><span class="line">                <span class="built_in">map</span>[stmp]--;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[stmp] == <span class="number">0</span>)</span><br><span class="line">                    count--;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            res= max(res, end-start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> two pointers </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/2018/06/06/3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2018/06/06/3-Longest-Substring-Without-Repeating-Characters/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string, find the length of the longest substring without repeating characters.</p><p>Examples:</p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a substring, <code>&quot;pwke&quot;</code> is a sub-sequence and not a substring.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Keep a <code>hashmap</code> which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , meanwhile update the hashmap. If the character is <code>already in the hashmap</code>, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        start = maxLength = <span class="number">0</span></span><br><span class="line">        usedChar = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> usedChar <span class="keyword">and</span> start &lt;= usedChar[s[i]]:</span><br><span class="line">                start = usedChar[s[i]] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxLength = max(maxLength, i - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            usedChar[s[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> maxl = <span class="number">0</span>, left= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(s[i]) != <span class="built_in">map</span>.end())&#123; </span><br><span class="line">                <span class="comment">//check whether if the character already in the map</span></span><br><span class="line">                left = max(<span class="built_in">map</span>.find(s[i])-&gt;second, left); <span class="comment">//if we can find, update the left pointer</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[s[i]] = i; <span class="comment">//update the appearance position of the character in map</span></span><br><span class="line">            maxl = max(maxl, i-left); <span class="comment">//max length would remain the same or (cur position-left pointer)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)</p><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        use an unordered_map to store occurence of words</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> start= <span class="number">0</span>, end= <span class="number">0</span>, res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp= s[end];</span><br><span class="line">            <span class="built_in">map</span>[tmp]++;</span><br><span class="line">            end++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">map</span>[tmp] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">map</span>[s[start++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            res= max(res, end- start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/mUhZjT" target="_blank" rel="noopener">https://goo.gl/mUhZjT</a><br><a href="https://goo.gl/8cQL7W" target="_blank" rel="noopener">https://goo.gl/8cQL7W</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
            <tag> hash table </tag>
            
            <tag> bloomberg </tag>
            
            <tag> adobe </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/2018/06/05/55-Jump-Game/"/>
      <url>/2018/06/05/55-Jump-Game/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>/*<br>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p>Example 1:</p><p>Input: <code>[2,3,1,1,4]</code><br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</p><p>Example 2:</p><p>Input: <code>[3,2,1,0,4]</code><br>Output: false<br>Explanation: You will always arrive at index 3 no matter what. Its maximum<br>             jump length is 0, which makes it impossible to reach the last index.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lastPos = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= lastPos) &#123; <span class="comment">//(current position + steps in this position) &gt; lastPos</span></span><br><span class="line">                lastPos = i;              <span class="comment">//if get to this slot, then we can get to last index</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastPos == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="second-time"><a href="#second-time" class="headerlink" title="second time:"></a>second time:</h1><p>key point is to determine whether current position+ position value can reach to the end</p><ul><li>use a pointer <code>reach</code> to denote the farthest position can reach</li><li>use another pointer <code>i</code> to denote the current position. It should be smaller than <code>array size</code> and <code>reach</code>. Because if <code>i</code> reaches the <code>reach</code>, it means the <code>reach</code> derived from previous steps can not reach to <code>i</code>, so will never reach to position <code>i</code>.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> reach=<span class="number">0</span>; <span class="comment">//where is the farest that it can reach</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//current location</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt; nums.size() &amp;&amp; i&lt;=reach)&#123;</span><br><span class="line">            reach=max(reach, i+nums[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> reach&gt;=nums.size()<span class="number">-1</span>; <span class="comment">//check whether reach is greater than array size</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> i &gt; m:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            m = max(m, i + n)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> microsoft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>18. 4Sum</title>
      <link href="/2018/06/05/18-4Sum/"/>
      <url>/2018/06/05/18-4Sum/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that <code>a + b + c + d = target</code>? Find all unique quadruplets in the array which gives the sum of target.</p><p>Note:</p><p>The solution set must not contain duplicate quadruplets.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This problem is pretty similar to , the key idea is to downgrade it to 2Sum problems. Other conditions is to increase performance.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; total;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">4</span>)  <span class="keyword">return</span> total;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//skip duplicate element</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt;target) <span class="keyword">break</span>; <span class="comment">//because the array is sorted, if 4 elements start from i is greater than target, no need to do the rest</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[n<span class="number">-3</span>]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>; <span class="comment">//because the array is sorted, if 4 elements start from i is smaller than target, we should keep finding upcoming sequence</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n<span class="number">-2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>]&gt;target) <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> left=j+<span class="number">1</span>,right=n<span class="number">-1</span>; <span class="comment">//two pointer to search toward right and left</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=nums[left]+nums[right]+nums[i]+nums[j];</span><br><span class="line">                    <span class="keyword">if</span>(sum&lt;target) left++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target) right--;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        total.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">do</span>&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;<span class="keyword">while</span>(nums[left]==nums[left<span class="number">-1</span>]&amp;&amp;left&lt;right); <span class="comment">//move left at least once then check for duplicate</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">do</span>&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;<span class="keyword">while</span>(nums[right]==nums[right+<span class="number">1</span>]&amp;&amp;left&lt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size()<span class="number">-3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= i+<span class="number">1</span>; j&lt; nums.size()<span class="number">-2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> l= j+<span class="number">1</span>, r= nums.size()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt; r)&#123;                    </span><br><span class="line">                    <span class="keyword">int</span> sum= nums[i]+ nums[j]+ nums[l]+ nums[r];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j], nums[l++], nums[r--]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(l&lt; r &amp;&amp; nums[l] == nums[l<span class="number">-1</span>]) l++;</span><br><span class="line">                        <span class="keyword">while</span>(l&lt; r &amp;&amp; nums[r] == nums[r+<span class="number">1</span>]) r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) l++;</span><br><span class="line">                    <span class="keyword">else</span> r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^3)$<br>space complexity: $O(1)$</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>162. Find Peak Element</title>
      <link href="/2018/06/05/162-Find-Peak-Element/"/>
      <url>/2018/06/05/162-Find-Peak-Element/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array nums, where <code>nums[i] ≠ nums[i+1]</code>, find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,1,3,5,6,4]</span><br><span class="line">Output: 1 or 5 </span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, </span><br><span class="line">             or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure><p>Note:<br>Your solution should be in logarithmic complexity.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>The question is asking for peaking element, if the sequence have multiple peak, anyone of them is fine.</li><li>We can use <code>sequential find</code> or <code>binary search</code></li></ol><p>We can consider the following case:</p><ul><li><p>Sequence is decreasing<br>If we use a <code>mid</code> pointer to find, then the peak must be on the left side.<br><img src="Find_Peak_Case1.png" alt=""></p></li><li><p>Sequence is increasing<br>The peak is on the right part.<br><img src="Find_Peak_Case2.png" alt=""></p></li><li><p>Peak is in the middle<br><img src="Find_Peak_Case3.png" alt=""></p></li></ul><ul><li>sequential find<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.size(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] &lt; num[i<span class="number">-1</span>])</span><br><span class="line">            &#123;<span class="comment">// &lt;</span></span><br><span class="line">                <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: O(n)<br>space complexity: O(1)</p><ul><li>binary search, recursive<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid+<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">return</span> helper(nums, left, mid);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> helper(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: O(logn)<br>space complexity: O(logn). In recursion loop, the search space is reduced in half, so the depth tree is log_2(n)</p><ul><li>binary search, iterative<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt; nums[mid+<span class="number">1</span>])</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: O(logn)<br>space complexity: O(1)</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>90. Subsets II</title>
      <link href="/2018/06/05/90-Subsets-II/"/>
      <url>/2018/06/05/90-Subsets-II/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Solution:<br>This question is very similar to <a href="/2018/06/01/39-Combination-Sum/" title="39. Combination Sum">39. Combination Sum</a> and <a href="/2018/06/05/78-Subsets/" title="78. Subsets">78. Subsets</a>. </p><ol><li>Sort the array</li><li>When recursion, we need to check for the duplicate elements, if <code>i</code> is equal to previous item then bypass it</li><li>A major difference is that we need to use <code>i</code> to do the backtrack, instead of <code>pos+1</code> in combination.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        backtrack(res, tmp, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; pos &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            backtrack(res, tmp, nums, i+<span class="number">1</span>); <span class="comment">//this is the major difference, need to throw in i, instead of pos</span></span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>78. Subsets</title>
      <link href="/2018/06/05/78-Subsets/"/>
      <url>/2018/06/05/78-Subsets/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>DFS + backtracking.<br>This question is very similar to <a href="/2018/06/01/39-Combination-Sum/" title="39. Combination Sum">39. Combination Sum</a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(res, tmp, nums)</span>:</span></span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                dfs(res, tmp+[nums[i]], nums[i+<span class="number">1</span>:])</span><br><span class="line">        res = []</span><br><span class="line">        dfs(res, [], nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        sort(nums.begin(), nums.end())</span><br><span class="line">        backtrack(res, tmp, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        res.push_back(tmp); <span class="comment">//add every set into the result</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            tmp.push_back(nums[i]); <span class="comment">//sequentially add every element in the result</span></span><br><span class="line">            backtrack(res, tmp, nums, i+<span class="number">1</span>);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2018/06/05/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
      <url>/2018/06/05/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">Return the following binary tree:</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p><img src="1.png" alt=""></p><ol><li>First item in <code>preorder</code> is the current root. The value would divide the <code>inorder</code> list to <code>left subtree</code> and <code>right subtree</code></li><li>Python have <code>list.index(value)</code> to find index in O(n). Or could use <code>dictionary</code>.</li><li>Be careful on the index.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> inorder:</span><br><span class="line">            index = inorder.index(preorder.pop(<span class="number">0</span>)) <span class="comment"># first element in list is next node</span></span><br><span class="line">            root = TreeNode(inorder[index])</span><br><span class="line">            root.left = self.buildTree(preorder, inorder[:index])</span><br><span class="line">            root.right = self.buildTree(preorder, inorder[index+<span class="number">1</span>:]) </span><br><span class="line">            <span class="comment"># starting from next node since inorder[index] is processed</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______7______</span><br><span class="line">    /              \</span><br><span class="line"> __10__          ___2</span><br><span class="line">/      \        /</span><br><span class="line">4       3      _8</span><br><span class="line">         \    /</span><br><span class="line">          1  11</span><br></pre></td></tr></table></figure><p>The preorder and inorder traversals for the binary tree above is:</p><p>preorder = <code>{7,10,4,3,1,2,8,11}</code><br>inorder = <code>{4,10,3,1,7,11,8,2}</code></p><p>First of all, we can see that preorder’s 1st element <code>7</code> is Root. The element <code>7</code> is the 4th element in inorder sequence. Since there is no duplicate in the sequence, there is no ambiguity.<br>The characteristic of inorder sequence is that it will follow this visit order <code>left-&gt;root-&gt;right</code>; therefore, we can see that the left elements before <code>7</code> is in <code>left subtree</code>. Other elements to the right must be in the <code>right subtree</code>.</p><p>Preorder traversal follows the sequence of <code>root-&gt;left-&gt;right</code>. Therefore, the left and right subtree’s preorder traversal must be {10, 4, 3, 1} and {2, 8, 11} respectively. Since the left and right subtree are binary trees in their own right, we can solve recursively!</p><p>Then how do we search the root value’s index in the inorder sequence?<br>If we use linear search, assume that the constructed binary tree is always balanced, then we can guarantee the run time complexity to be O(N log N), where N is the number of nodes. However, this is not necessarily the case and the constructed binary tree can be skewed to the left/right, which has the worst complexity of O(N^2).</p><p>A more efficient way is to eliminate the search by using an efficient look-up mechanism such as <code>hash table</code>. By hashing an element’s value to its corresponding index in the inorder sequence, we can do look-ups in constant time. Now, we need only O(N) time to construct the tree, which theoretically is the most efficient way.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++) <span class="built_in">map</span>[inorder[i]] = i;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, inorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>, <span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> m1, <span class="keyword">int</span> n1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> m2, <span class="keyword">int</span> n2, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; <span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m1 &gt; n1) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> curindex = <span class="built_in">map</span>[preorder[m1]];</span><br><span class="line">        <span class="keyword">int</span> new_right_m1 = m1 + curindex - m2 + <span class="number">1</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[m1]);</span><br><span class="line">        root-&gt;left = buildTree(preorder, m1+<span class="number">1</span>, new_right_m1<span class="number">-1</span>, inorder, m2, curindex<span class="number">-1</span>, <span class="built_in">map</span>);</span><br><span class="line">        root-&gt;right = buildTree(preorder, new_right_m1, n1, inorder, curindex+<span class="number">1</span>, n2, <span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tree traversal</title>
      <link href="/2018/06/04/Tree-traversal/"/>
      <url>/2018/06/04/Tree-traversal/</url>
      <content type="html"><![CDATA[<p>example:<br><img src="tree.png" alt=""></p><p>DFS:<br>Inorder:  (Left, Root, Right), 4 2 5 1 3<br>Preorder: (Root, Left, Right), 1 2 4 5 3<br>Postorder:(Left, Right, Root), 4 5 2 3 1</p><p>BFS:(level order)<br>1 2 3 4 5</p><h1 id="In-Order-Traversal"><a href="#In-Order-Traversal" class="headerlink" title="In-Order Traversal"></a>In-Order Traversal</h1><ul><li>visit left branch, then current node, and finally, the right branch.</li><li><code>Left-&gt;Root-&gt;Right</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    visit(root);</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Pre-Order-Traversal"><a href="#Pre-Order-Traversal" class="headerlink" title="Pre-Order Traversal"></a>Pre-Order Traversal</h1><ul><li>visit current node before its child nodes(hence called pre-order)</li><li>In a pre-order traversal, the root is always the first node visited.</li><li><code>Root-&gt;Left-&gt;Right</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    visit(root);</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Post-Order-Traversal"><a href="#Post-Order-Traversal" class="headerlink" title="Post-Order Traversal"></a>Post-Order Traversal</h1><ul><li>visit current node after its child nodes(hence post-order)</li><li>In a post-order, the root is always the last node visited.</li><li><code>Left-&gt;Right-&gt;Root</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">    visit(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>reference:<br><a href="https://goo.gl/vCGqY8" target="_blank" rel="noopener">https://goo.gl/vCGqY8</a></p>]]></content>
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> tree traversal </tag>
            
            <tag> preorder </tag>
            
            <tag> inorder </tag>
            
            <tag> postorder </tag>
            
            <tag> binary tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>442. Find All Duplicates in an Array</title>
      <link href="/2018/06/04/442-Find-All-Duplicates-in-an-Array/"/>
      <url>/2018/06/04/442-Find-All-Duplicates-in-an-Array/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p><p>Find all the elements that appear twice in this array.</p><p>Could you do it without extra space and in O(n) runtime?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure></p><p>Solution:<br>First of all, we should notice that the number is ranged from <code>1...n</code>. So if we use the <code>value-1</code> as the index, it will not out of range. Therefore, we can use the input array to do the checking. When find a number <code>i</code>, flip the number at position <code>i-1</code> to negative. If the number at position <code>i-1</code> is already negative, <code>i</code> is the number that occurs twice.</p><p>Example:<br>input array: [1,2,2,3]<br>round 1: [-1,2,2,3]<br>round 2: [-1,-2,2,3]<br>round 3: [-1,2,2,3] –&gt; the 2nd element become positive after flipping, so add it to result<br>round 4: [-1,2,-2,3]</p><p>time complexity: O(n)<br>space complexity: O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDuplicates(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            nums[<span class="built_in">abs</span>(nums[i])<span class="number">-1</span>] = -nums[<span class="built_in">abs</span>(nums[i])<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">abs</span>(nums[i])<span class="number">-1</span>] &gt; <span class="number">0</span>) </span><br><span class="line">                res.push_back(<span class="built_in">abs</span>(nums [i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>A regular way to do it. Use a set to check if a number showed up.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        dup = set()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> dup:</span><br><span class="line">                res.append(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dup.add(n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>Then I realized the input numbers are <code>1 ≤ a[i] ≤ n (n = size of array)</code>. Also, the duplicate would only appear twice. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> nums[abs(n)<span class="number">-1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                res.append(abs(n))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[abs(n)<span class="number">-1</span>] *= <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>64. Minimum Path Sum</title>
      <link href="/2018/06/04/64-Minimum-Path-Sum/"/>
      <url>/2018/06/04/64-Minimum-Path-Sum/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p><p>Note: You can only move either down or right at any point in time.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure></p><p>Solution:</p><ol><li>2D array DP<br>Use an extra matrix <code>dp</code> of the same size as the original matrix. In this matrix, <code>dp(i, j)</code> represents the minimum sum of the path from the index <code>(i, j)</code> to the bottom rightmost element. We start by initializing the bottom rightmost element of <code>dp</code> as the last element of the given matrix. Then for each element starting from the bottom right, we traverse backwards and fill in the matrix with the required minimum sums. Now, we need to note that at every element, we can move either rightwards or downwards. Therefore, for filling in the minimum sum, we use the equation:</li></ol><p><code>dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; s = grid;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m<span class="number">-1</span>; j&gt;=<span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == n<span class="number">-1</span> &amp;&amp; j != m<span class="number">-1</span>)    <span class="comment">//edge case, last row</span></span><br><span class="line">                    s[i][j] += s[i][j+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i != n<span class="number">-1</span> &amp;&amp; j == m<span class="number">-1</span>)</span><br><span class="line">                    s[i][j] += s[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i != n<span class="number">-1</span> &amp;&amp; j != m<span class="number">-1</span>)</span><br><span class="line">                    s[i][j] = s[i][j] + min(s[i][j+<span class="number">1</span>], s[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(mn)<br>space complexity: O(mn)</p><ol start="2"><li>1D array<br>We can do the same work using a <code>dp</code> array of the row size, since for making the current entry all we need is the dp entry for the bottom and the right element. Thus, we start by initializing only the last element of the array as the last element of the given matrix. The last entry is the bottom rightmost element of the given matrix. Then, we start moving towards the left and update the entry <code>dp(j)</code> as:</li></ol><p><code>dp(j)=grid(i,j)+min(dp(j),dp(j+1))</code></p><p>We repeat the same process for every row as we move upwards. At the end dp(0)dp(0) gives the required minimum sum.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m= grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= n<span class="number">-1</span>; i&gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m<span class="number">-1</span>; j&gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == n<span class="number">-1</span> &amp;&amp; j != m<span class="number">-1</span>) dp[j] = grid[i][j]+ dp[j+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i != n<span class="number">-1</span> &amp;&amp; j == m<span class="number">-1</span>) dp[j] = grid[i][j]+ dp[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i != n<span class="number">-1</span> &amp;&amp; j != m<span class="number">-1</span>) dp[j] = grid[i][j] + min(dp[j], dp[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span> dp[j] = grid[i][j];</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(mn)<br>space complexity: O(n)</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>377. Combination Sum IV</title>
      <link href="/2018/06/04/377-Combination-Sum-IV/"/>
      <url>/2018/06/04/377-Combination-Sum-IV/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">target = 4</span><br><span class="line"></span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">Note that different sequences are counted as different combinations.</span><br><span class="line"></span><br><span class="line">Therefore the output is 7.</span><br></pre></td></tr></table></figure></p><p>Follow up:</p><ul><li>What if negative numbers are allowed in the given array?</li><li>How does it change the problem?</li><li>What limitation we need to add to the question to allow negative numbers?</li></ul><p>Solution:<br>Think about the recurrence relation first. How does the # of combinations of the target related to the # of combinations of numbers that are smaller than the target?</p><p>So we know that target is the sum of numbers in the array. Imagine we only need one more number to reach target, this number can be any one in the array, right? So the # of combinations of target, comb[target] = sum(comb[target - nums[i]]), where 0 &lt;= i &lt; nums.length, and target &gt;= nums[i].</p><p>In the example given, we can actually find the # of combinations of 4 with the # of combinations of 3(4 - 1), 2(4- 2) and 1(4 - 3). As a result, comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1].</p><p>In the code, I use a dp array to represent the combination array.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(target + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n) <span class="keyword">break</span>; <span class="comment">//can not use n as i's candidate</span></span><br><span class="line">                dp[i] += dp[i - n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>216. Combination Sum III</title>
      <link href="/2018/06/04/216-Combination-Sum-III/"/>
      <url>/2018/06/04/216-Combination-Sum-III/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p><p>Note:</p><p>All numbers will be positive integers.<br>The solution set must not contain duplicate combinations.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: k = 3, n = 9</span><br><span class="line">Output: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure><p>Solution:<br>DFS + backtracking.<br>This question is very similar to <a href="/2018/06/01/39-Combination-Sum/" title="39. Combination Sum">39. Combination Sum</a> and . However, we need to create the candidates array, or you can use for loop to walk through 1~9.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidates= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        backtrack(candidates, res, tmp, k, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> k, <span class="keyword">int</span> remain, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k ==<span class="number">0</span> &amp;&amp; remain == <span class="number">0</span>) </span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//tmp.size &lt; k, n still need to fill value</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt; candidates.size() &amp;&amp; k&gt;<span class="number">0</span> &amp;&amp; remain&gt;<span class="number">0</span>; i++)&#123;</span><br><span class="line">                tmp.push_back(candidates[i]);</span><br><span class="line">                backtrack(candidates, res, tmp, k<span class="number">-1</span>, remain- candidates[i], i+<span class="number">1</span>);</span><br><span class="line">                tmp.resize(tmp.size()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>40. Combination Sum II</title>
      <link href="/2018/06/01/40-Combination-Sum-II/"/>
      <url>/2018/06/01/40-Combination-Sum-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p><p>Each number in candidates may only be used once in the combination.</p><p>Note:</p><p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>DFS + backtracking.<br>This question is very similar to <a href="/2018/06/01/39-Combination-Sum/" title="39. Combination Sum">39. Combination Sum</a>. The only difference is that the candidates array have duplicate elements, and we can not have same combination set in result array.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        backtrack(candidates, tmp, res, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> remain, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>) res.push_back(tmp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt; candidates.size(); i++)&#123;</span><br><span class="line">                <span class="comment">//skip duplicate, because the question is asked for unique combination</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; pos &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>]) <span class="keyword">continue</span>; </span><br><span class="line">                </span><br><span class="line">                tmp.push_back(candidates[i]);</span><br><span class="line">                backtrack(candidates, tmp, res, remain-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">                tmp.resize(tmp.size()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>39. Combination Sum</title>
      <link href="/2018/06/01/39-Combination-Sum/"/>
      <url>/2018/06/01/39-Combination-Sum/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p><p>The same repeated number may be chosen from candidates unlimited number of times.</p><p>Note:</p><p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: candidates = [2,3,6,7], target = 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: candidates = [2,3,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>DFS + backtracking.<br>In backtrack(), I use the following 5 inputs.</p><ul><li>vector&lt;vector<int>&gt;&amp; res, store every combination here</int></li><li>vector<int>&amp; temp, this is buffer for recursive, add/remove element depends on depth of dfs</int></li><li>vector<int>&amp; candidates, </int></li><li>int remain, what we targeting, need to input remain-i when dfs into next level</li><li>int start, this is because we can not have duplicate sets, to record what elements we already passed or visited.</li></ul><p>Time complexity: O(n*2^n)<br>The number of recursive calls, T(n) satisfies the recurrence T(n) = T(n - 1) + T(n - 2) + … + T(1) + T(0),which solves to T(n) = O(2^n). Since we spend O(n) time within a call, the time complexity is O(n2^n);</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(res, tmp, candidates, target)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">elif</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(tmp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candidates)):</span><br><span class="line">                    dfs(res, tmp+ [candidates[i]], candidates[i:], target-candidates[i])</span><br><span class="line">                    </span><br><span class="line">        res = []</span><br><span class="line">        dfs(res, [], candidates, target)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        backtrack(res, tmp, candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//did not match the target</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) res.push_back(temp); <span class="comment">//put into the result</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt; candidates.size(); i++)&#123;</span><br><span class="line">                <span class="comment">//search candidate[i] have any combanition</span></span><br><span class="line">                temp.push_back(candidates[i]); </span><br><span class="line">                backtrack(res, temp, candidates, remain-candidates[i], i); </span><br><span class="line">                </span><br><span class="line">                temp.resize(temp.size()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/HkoJaT" target="_blank" rel="noopener">https://goo.gl/HkoJaT</a><br><a href="https://goo.gl/XX6WAv" target="_blank" rel="noopener">https://goo.gl/XX6WAv</a><br><a href="http://www.1point3acres.com/bbs/thread-117602-1-1.html" target="_blank" rel="noopener">http://www.1point3acres.com/bbs/thread-117602-1-1.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>289. Game of Life</title>
      <link href="/2018/06/01/289-Game-of-Life/"/>
      <url>/2018/06/01/289-Game-of-Life/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p><p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p><ul><li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li><li>Any live cell with two or three live neighbors lives on to the next generation.</li><li>Any live cell with more than three live neighbors dies, as if by over-population..</li><li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.<br>Write a function to compute the next state (after one update) of the board given its current state.</li></ul><p>Follow up:<br>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.<br>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>To solve it in place, we use 2 bits to store 2 states:</p><p>[2nd bit, 1st bit] = [next state, current state]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00  dead (next) &lt;- dead (current)</span><br><span class="line">01  dead (next) &lt;- live (current)  </span><br><span class="line">10  live (next) &lt;- dead (current)  </span><br><span class="line">11  live (next) &lt;- live (current)</span><br></pre></td></tr></table></figure></p><ul><li>In the beginning, every cell is either 00 or 01.</li><li>Notice that 1st state is independent of 2nd state.</li><li>Imagine all cells are instantly changing from the 1st to the 2nd state, at the same time.</li><li>Let’s count # of neighbors from 1st state and set 2nd state bit.</li><li>Since every 2nd state is by default dead, no need to consider transition 01 -&gt; 00.</li><li>In the end, delete every cell’s 1st state by doing &gt;&gt; 1.</li></ul><p>For each cell’s 1st bit, check the 8 pixels around itself, and set the cell’s 2nd bit.</p><p>Transition <code>01 -&gt; 11</code>: when <code>board[i][j] == 1</code> and <code>lives &gt;= 2 &amp;&amp; lives &lt;= 3</code>.<br>Transition <code>00 -&gt; 10</code>: when <code>board[i][j] == 0</code> and <code>lives == 3</code>.<br>To get the current state, do <code>board[i][j] &amp; 1</code><br>To get the next state, do <code>board[i][j] &gt;&gt; 1</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty() || board.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n= board[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> lives = liveNeighbor(board, m,n,i,j);</span><br><span class="line">                <span class="comment">// In the beginning, every 2nd bit is 0;</span></span><br><span class="line">                <span class="comment">// So we only need to care about when will the 2nd bit become 1.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; lives &gt;= <span class="number">2</span> &amp;&amp; lives &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="number">3</span>; <span class="comment">// Make the 2nd bit 1: 01 ---&gt; 11</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span>(board[i][j] ==<span class="number">0</span> &amp;&amp; lives == <span class="number">3</span>)&#123;</span><br><span class="line">                    board[i][j]= <span class="number">2</span>; <span class="comment">// Make the 2nd bit 1: 00 ---&gt; 10</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; n; ++j)</span><br><span class="line">                board[i][j] &gt;&gt;=<span class="number">1</span>; <span class="comment">// Get the 2nd state.</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">liveNeighbor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lives= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x= max(i<span class="number">-1</span>, <span class="number">0</span>); x&lt;= min(i+<span class="number">1</span>, m<span class="number">-1</span>); x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y= max(j<span class="number">-1</span>, <span class="number">0</span>); y &lt;= min(j+<span class="number">1</span>, n<span class="number">-1</span>); y++)&#123;</span><br><span class="line">                lives+= board[x][y] &amp;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lives -= board[i][j] &amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> lives;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution-Python-extra-space"><a href="#Solution-Python-extra-space" class="headerlink" title="Solution Python extra space:"></a>Solution Python extra space:</h2><p>Use an additional grid to store the neighbor status. Update <code>board[i][j]</code> once we got all neighbor status in this round.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(self, board: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># status change between dead and live</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">neighbors_of_cell</span><span class="params">(x: int, y: int)</span> -&gt; int:</span></span><br><span class="line">            left = board[x - <span class="number">1</span>][y] <span class="keyword">if</span> x <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            right = board[x + <span class="number">1</span>][y] <span class="keyword">if</span> x + <span class="number">1</span> &lt; m <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            up = board[x][y - <span class="number">1</span>] <span class="keyword">if</span> y <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            down = board[x][y + <span class="number">1</span>] <span class="keyword">if</span> y + <span class="number">1</span> &lt; n <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            left_up = board[x - <span class="number">1</span>][y - <span class="number">1</span>] <span class="keyword">if</span> x <span class="keyword">and</span> y <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            left_down = board[x - <span class="number">1</span>][y + <span class="number">1</span>] <span class="keyword">if</span> x <span class="keyword">and</span> y + <span class="number">1</span> &lt; n <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            right_up = board[x + <span class="number">1</span>][y - <span class="number">1</span>] <span class="keyword">if</span> x + <span class="number">1</span> &lt; m <span class="keyword">and</span> y <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            right_down = board[x + <span class="number">1</span>][y + <span class="number">1</span>] <span class="keyword">if</span> x + <span class="number">1</span> &lt; m <span class="keyword">and</span> y + <span class="number">1</span> &lt; n <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> left + right + up + down + left_up + left_down + right_up + right_down</span><br><span class="line"></span><br><span class="line">        m = len(board)</span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        neighbors = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]  <span class="comment"># represents live neighbors of each cell</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(n):</span><br><span class="line">                neighbors[r][c] = neighbors_of_cell(r, c)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> board[r][c]:  <span class="comment"># live cell</span></span><br><span class="line">                    <span class="keyword">if</span> neighbors[r][c] &gt; <span class="number">3</span>:  <span class="comment"># over-population</span></span><br><span class="line">                        board[r][c] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">elif</span> neighbors[r][c] &lt; <span class="number">2</span>:  <span class="comment"># under-population</span></span><br><span class="line">                        board[r][c] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># dead cell</span></span><br><span class="line">                    <span class="keyword">if</span> neighbors[r][c] == <span class="number">3</span>:  <span class="comment"># reproduction</span></span><br><span class="line">                        board[r][c] = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="Solution-Python-without-extra-space"><a href="#Solution-Python-without-extra-space" class="headerlink" title="Solution Python without extra space:"></a>Solution Python without extra space:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(self, board: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        m,n = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">0</span> <span class="keyword">or</span> board[i][j] == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.nnb(board,i,j) == <span class="number">3</span>:</span><br><span class="line">                        board[i][j] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.nnb(board,i,j) &lt; <span class="number">2</span> <span class="keyword">or</span> self.nnb(board,i,j) &gt;<span class="number">3</span>:</span><br><span class="line">                        board[i][j] = <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">2</span>: board[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="number">3</span>: board[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nnb</span><span class="params">(self, board, i, j)</span>:</span></span><br><span class="line">        m,n = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> j<span class="number">-1</span> &gt;= <span class="number">0</span>:   count += board[i<span class="number">-1</span>][j<span class="number">-1</span>]%<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> i<span class="number">-1</span> &gt;= <span class="number">0</span>:                count += board[i<span class="number">-1</span>][j]%<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> i<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> j+<span class="number">1</span> &lt; n:    count += board[i<span class="number">-1</span>][j+<span class="number">1</span>]%<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> j<span class="number">-1</span> &gt;= <span class="number">0</span>:                count += board[i][j<span class="number">-1</span>]%<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; n:                 count += board[i][j+<span class="number">1</span>]%<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; m <span class="keyword">and</span> j<span class="number">-1</span> &gt;= <span class="number">0</span>:    count += board[i+<span class="number">1</span>][j<span class="number">-1</span>]%<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; m:                 count += board[i+<span class="number">1</span>][j]%<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; m <span class="keyword">and</span> j+<span class="number">1</span> &lt; n:     count += board[i+<span class="number">1</span>][j+<span class="number">1</span>]%<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>31. Next Permutation</title>
      <link href="/2018/06/01/31-Next-Permutation/"/>
      <url>/2018/06/01/31-Next-Permutation/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be in-place and use only constant extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>index: 0,1,2,3,4,5<br>value: 2,3,6,5,4,1</p><p><strong>1. from right to left, find the first number which not increase in a ascending order. In this case which is 3.</strong><br><strong>2. here we can have two situations:</strong></p><ol><li><p>We cannot find the number, all the numbers increasing in a ascending order. This means this permutation is the last permutation, we need to rotate back to the first permutation. So we reverse the whole array, for example, <code>6,5,4,3,2,1</code> we turn it to <code>1,2,3,4,5,6</code>.</p></li><li><p>We can find the number, then the next step, we will start from right most to leftward, try to find the first number which is larger than 3, in this case it is 4.<br>Then we swap 3 and 4, the list turn to <code>2,4,6,5,3,1</code>.<br>Last, we reverse numbers on the right of 4, we finally get <code>2,4,1,3,5,6</code>.</p></li></ol><p>Time complexity: O(3*n)=O(n).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = len(nums)<span class="number">-1</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i<span class="number">-1</span>] &gt;= nums[i]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            nums.reverse()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># Note that in previous while loop, we would stop when nums[i-1] &gt;= nums[i]</span></span><br><span class="line">        <span class="comment"># But we want the first descending element, so we need to take nums[i-1] in the following while loop</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> nums[j] &lt;= nums[i<span class="number">-1</span>]:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        nums[j], nums[i<span class="number">-1</span>] = nums[i<span class="number">-1</span>], nums[j]</span><br><span class="line">        l, r = i, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>; <span class="comment">//for checking whether the array is in descending order</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123; <span class="comment">//From right to left, find 1st number that is not ascending order</span></span><br><span class="line">    k = i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span>) &#123; </span><br><span class="line">            <span class="comment">//can not find the number, this means the array is already the largest type, </span></span><br><span class="line">            <span class="comment">//so reverse it would have the smallest</span></span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">-1</span>; <span class="comment">//From right to left, trying to find 1st number that is greater than nums[k]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt; k; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[k]) &#123;</span><br><span class="line">    l = i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    swap(nums[k], nums[l]); </span><br><span class="line">    reverse(nums.begin() + k + <span class="number">1</span>, nums.end()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Another solution:</strong></p><p>Just for info: There’s a library function that does the job, even going from totally reverse sorted to sorted:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    next_permutation(begin(nums), end(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Another Solution</strong></p><p>Using library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of +1/-1, it all fits exactly.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = is_sorted_until(nums.rbegin(), nums.rend());</span><br><span class="line">    <span class="keyword">if</span> (i != nums.rend())</span><br><span class="line">        swap(*i, *upper_bound(nums.rbegin(), i, *i));</span><br><span class="line">    reverse(nums.rbegin(), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Second-Time"><a href="#Second-Time" class="headerlink" title="Second Time:"></a>Second Time:</h3><p>The last <code>reverse</code> is because, we need to reverse the order after we swap a smaller element to the back.<br>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[1,3,2], left= 0, right= 2</span><br><span class="line"></span><br><span class="line">after swap</span><br><span class="line">[2,3,1]</span><br><span class="line"></span><br><span class="line">we can see that the next permutation should be [2,1,3], which should start with the nums[right] we just swap to the back</span><br><span class="line"></span><br><span class="line">Therefore, we need to reverse the order so it could be in the front and make a</span><br><span class="line">[2,1,3]</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. find a k such that nums[k]&lt; nums[k+1]</span></span><br><span class="line"><span class="comment">        2. if the k does not exist, reverse the entire array</span></span><br><span class="line"><span class="comment">        3. if exist, find a number right such that nums[k]&lt; nums[right]</span></span><br><span class="line"><span class="comment">        4. reverse the rest of the array, so it can be next greater one</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(left= nums.size()<span class="number">-2</span>; left&gt;= <span class="number">0</span>; left--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]&lt; nums[left+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt; <span class="number">0</span>)</span><br><span class="line">            reverse(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(right= nums.size()<span class="number">-1</span>; right&gt; left; right--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[right] &gt; nums[left])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[left], nums[right]);</span><br><span class="line">            reverse(nums.begin()+left+<span class="number">1</span>, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> permutation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>73. Set Matrix Zeroes</title>
      <link href="/2018/05/31/73-Set-Matrix-Zeroes/"/>
      <url>/2018/05/31/73-Set-Matrix-Zeroes/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Follow up:</p><ul><li>A straight forward solution using O(mn) space is probably a bad idea.</li><li>A simple improvement uses O(m + n) space, but still not the best solution.</li><li>Could you devise a constant space solution?</li></ul><p>Solution:</p><ol><li>fr = first row, fc = first col</li><li>Use first row and first column as markers. If matrix[i][j] = 0, mark respected row and col marker = 0 indicating that later this respective row and col must be marked 0; And because you are altering first row and column, we need to have two variables to track their own status. </li><li><p>For example, if any one of the first row is 0, fr = 0, at the end need to set all first row to 0;</p><p>time complexity: O(mn)<br>space complexity: O(1)</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row0, col0 = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> matrix[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span>: row0 = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span> j == <span class="number">0</span>: col0 = <span class="number">0</span></span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Notice this starts from 1 because we use first row/col to store</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> matrix[i][<span class="number">0</span>] <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>][j]:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> row0:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> col0:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        bool fr= false, fc= false;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i&lt; matrix.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j= <span class="number">0</span>; j&lt; matrix[<span class="number">0</span>].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>) fr = true;</span><br><span class="line">                    <span class="keyword">if</span>(j == <span class="number">0</span>) fc = true;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i&lt; matrix.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">1</span>; j&lt; matrix[<span class="number">0</span>].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>)</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fc)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>; i&lt; matrix.size(); ++i)</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j&lt; matrix[<span class="number">0</span>].size(); ++j)</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>79. Word Search</title>
      <link href="/2018/05/31/79-Word-Search/"/>
      <url>/2018/05/31/79-Word-Search/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>Since the question mentioned there’s only one possible solution, we should use DFS.</li><li>Use pre_check to see if any chac in <code>word</code> is not in board</li><li>Temporary set <code>board[i][j]</code> to other character.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.pre_check(board, word):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> self.dfs(board, i, j, word):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pre_check</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        letters = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                letters.add(board[i][j])</span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> letters:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, i, j, word)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(word) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= len(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != word[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># check other directions</span></span><br><span class="line">        tmp = board[i][j]</span><br><span class="line">        board[i][j] = <span class="string">'#'</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, i<span class="number">-1</span>, j, word[<span class="number">1</span>:]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, i+<span class="number">1</span>, j, word[<span class="number">1</span>:]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, i, j<span class="number">-1</span>, word[<span class="number">1</span>:]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, i, j+<span class="number">1</span>, word[<span class="number">1</span>:]):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        board[i][j] = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><hr><ol><li>use DFS to find whether the word exist</li><li>create a 2D bool array to record used elements in each DFS, the range should be [rowNum][colNum]</li><li>find word with start in each slot[i][j]</li></ol><p>In auxiliary function:<br>First we check pos is equal to word.length(), return true if it’s the same.<br>Second, if anything is out of range, then return false.<br>Third, return false if (we already visited this slot) || ([i][j] is different from the word[pos])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty() || !word.length()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//nothing in board || nothing in word</span></span><br><span class="line">        <span class="keyword">int</span> rowNum= board.size(), colNum= board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(rowNum, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(colNum, <span class="literal">false</span>)); <span class="comment">//create a visit array to check if visited</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; rowNum; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; colNum; ++j)&#123;</span><br><span class="line">                <span class="comment">//use [i][j] as start point, search for word</span></span><br><span class="line">                <span class="keyword">if</span>(exist(board, visited, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="built_in">string</span> word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( i&lt; <span class="number">0</span> || j&lt; <span class="number">0</span> || i&gt; board.size()<span class="number">-1</span> || j&gt;board[<span class="number">0</span>].size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//edge case for size</span></span><br><span class="line">        <span class="keyword">if</span>(visited[i][j] || board[i][j] != word.at(pos)) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="comment">//already came this slot || [i][j] is different from word[pos]</span></span><br><span class="line">        </span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//DFS</span></span><br><span class="line">        <span class="keyword">if</span> (exist(board, visited, word, i - <span class="number">1</span>, j, pos + <span class="number">1</span>) <span class="comment">//check toward left</span></span><br><span class="line">            || exist(board, visited, word, i + <span class="number">1</span>, j, pos + <span class="number">1</span>) <span class="comment">//check toward right</span></span><br><span class="line">            || exist(board, visited, word, i, j - <span class="number">1</span>, pos + <span class="number">1</span>) <span class="comment">//check toward top</span></span><br><span class="line">            || exist(board, visited, word, i, j + <span class="number">1</span>, pos + <span class="number">1</span>)) <span class="comment">//check toward bottom</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        </span><br><span class="line">        visited[i][j] = <span class="literal">false</span>; <span class="comment">//this slot can not make a same search word</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://goo.gl/QLs5yW" target="_blank" rel="noopener">https://goo.gl/QLs5yW</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>287. Find the Duplicate Number</title>
      <link href="/2018/05/31/287-Find-the-Duplicate-Number/"/>
      <url>/2018/05/31/287-Find-the-Duplicate-Number/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>You must not modify the array (assume the array is read only).</li><li>You must use only constant, O(1) extra space.</li><li>Your runtime complexity should be less than O(n2).</li><li>There is only one duplicate number in the array, but it could be repeated more than once.</li></ul><p>Solution:</p><h2 id="1-Floyd’s-Tortoise-and-Hare-Algorithm"><a href="#1-Floyd’s-Tortoise-and-Hare-Algorithm" class="headerlink" title="1. Floyd’s Tortoise and Hare Algorithm"></a>1. Floyd’s Tortoise and Hare Algorithm</h2><p>The first while loop ensures you goes in the correct cycle which has duplicates. For example:<br>index = [0 1 2 3 4 5 6 7]; nums = [5 2 1 3 5 7 6 4].<br>(slow)nums[slow] = (0)5 (5)7 (7)4 (4)5; fast = (0)5 (7)4 (5)7 (4)5; —-&gt; when they meets at (idx=4)(value=5), you know you have a cycle.</p><p>Take a look at the cycle by the indices and values:</p><p>idx: 0—&gt;5—&gt;7—&gt;4–&gt;(goes back to idx=5)</p><p>val: 5—&gt;7—&gt;4—&gt;5–&gt;(goes back to val=7)</p><p>The second while loop will stop when “fast=0” and “slow=4” (their values = 5, the duplicate number). The duplicate number 5 is the reason why the two pointers will meet at a same index (next number). In fact, the second loop will always stop right before they meet at the first item of the cycle. </p><p>*Proof of second step:</p><p>Distance traveled by tortoise while meeting = x + y<br>Distance traveled by hare while meeting = (x + y + z) + y = x + 2y + z<br>Since hare travels with double the speed of tortoise,<br>so 2(x+y)= x+2y+z =&gt; x+2y+z = 2x+2y =&gt; x=z</p><p>Hence by moving tortoise to start of linked list, and making both animals to move one node at a time, they both have same distance to cover .<br>They will reach at the point where the loop starts in the linked list</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">while</span> (slow != fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printf("slow:%d, fast:%d\n", slow, fast);</span></span><br><span class="line">                slow = nums[slow];</span><br><span class="line">                fast = nums[nums[fast]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fast = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printf("slow:%d, fast:%d\n", slow, fast);</span></span><br><span class="line">                fast = nums[fast];</span><br><span class="line">                slow = nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf("slow:%d, fast:%d\n", slow, fast);</span></span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Binary-search"><a href="#2-Binary-search" class="headerlink" title="2. Binary search"></a>2. Binary search</h2><p>This solution is based on binary search.</p><p>At first the search space is numbers between 1 to n. Each time I select a number mid (which is the one in the middle) and count all the numbers equal to or less than mid. Then if the count is more than mid, the search space will be [1 mid] otherwise [mid+1 n]. I do this until search space is only one number.</p><p>Let’s say n=10 and I select mid=5. Then I count all the numbers in the array which are less than equal mid. If the there are more than 5 numbers that are less than 5, then by Pigeonhole Principle (<a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pigeonhole_principle</a>) one of them has occurred more than once. So I shrink the search space from [1 10] to [1 5]. Otherwise the duplicate number is in the second half so for the next step the search space would be [6 10].</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high=n;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num&lt;=mid) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"low=%d, high=%d, mid=%d, count=%d\n"</span>, low, high, mid, count);</span><br><span class="line">            <span class="keyword">if</span>(count&gt;mid) high=mid;</span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
            <tag> Floyd&#39;s Tortoise and Hare Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>228. Summary Ranges</title>
      <link href="/2018/05/30/228-Summary-Ranges/"/>
      <url>/2018/05/30/228-Summary-Ranges/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>/*<br>Given a sorted integer array without duplicates, return the summary of its ranges.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:  [0,1,2,4,5,7]</span><br><span class="line">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:  [0,2,3,4,6,8,9]</span><br><span class="line">Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.</span><br></pre></td></tr></table></figure><p>Solution:<br>A range covers consecutive elements. If two adjacent elements have difference larger than 11, the two elements does not belong to the same range.</p><p>To summarize the ranges, we need to know how to separate them. The array is sorted and without duplicates. In such array, two adjacent elements have difference either 1 or larger than 1. If the difference is 1, they should be put in the same range; otherwise, separate ranges.</p><p>We also need to know the start index of a range so that we can put it in the result list. Thus, we keep two indices, representing the two boundaries of current range. For each new element, we check if it extends the current range. If not, we put the current range into the list.</p><p>Don’t forget to put the last range into the list. One can do this by either a special condition in the loop or putting the last range in to the list after the loop.</p><p>Time complexity: O(n)<br>Space complexity: O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; summaryRanges(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            res.push_back(to_string(nums[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur= nums[i];</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt; nums.size() &amp;&amp; (nums[i+<span class="number">1</span>]- nums[i]== <span class="number">1</span>))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != nums[i])</span><br><span class="line">                res.push_back(to_string(cur)+<span class="string">"-&gt;"</span>+to_string(nums[i]));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.push_back(to_string(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>229. Majority Element II</title>
      <link href="/2018/05/30/229-Majority-Element-II/"/>
      <url>/2018/05/30/229-Majority-Element-II/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p><p>Note: The algorithm should run in linear time and in O(1) space.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3,2,3]</span><br><span class="line">Output: [3]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,1,1,3,3,2,2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p>Solution:<br>The essential concepts is you keep a counter for the majority number X. If you find a number Y that is not X, the current counter should deduce 1. The reason is that if there is 5 X and 4 Y, there would be one (5-4) more X than Y. This could be explained as “4 X being paired out by 4 Y”.</p><p>And since the requirement is finding the majority for more than ceiling of [n/3], the answer would be less than or equal to two numbers.<br>So we can modify the algorithm to maintain two counters for two majorities.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; majorityElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> num0 = <span class="number">0</span>, num1 = <span class="number">1</span>, count0 = <span class="number">0</span>, count1 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">            <span class="comment">//find two majority element</span></span><br><span class="line">          <span class="keyword">if</span> (x == num0) count0++;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (x == num1) count1++;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (! count0) num0 = x, count0 = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (! count1) num1 = x, count1 = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> count0--, count1--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//set to zero is because only need to count these two element</span></span><br><span class="line">        count0 = count1 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums)</span><br><span class="line">          <span class="keyword">if</span> (x == num0) count0++;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (x == num1) count1++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (count0 &gt; nums.size()/<span class="number">3</span>) res.push_back(num0);</span><br><span class="line">        <span class="keyword">if</span> (count1 &gt; nums.size()/<span class="number">3</span>) res.push_back(num1);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html" target="_blank" rel="noopener">https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>59. Spiral Matrix II</title>
      <link href="/2018/05/30/59-Spiral-Matrix-II/"/>
      <url>/2018/05/30/59-Spiral-Matrix-II/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res( n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n) );</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( k &lt;= n * n )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">                    <span class="comment">// four steps</span></span><br><span class="line">        <span class="keyword">while</span>( j &lt; n - i )             <span class="comment">// 1. horizonal, left to right</span></span><br><span class="line">        res[i][j++] = k++;</span><br><span class="line">        j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( j &lt; n - i )             <span class="comment">// 2. vertical, top to bottom</span></span><br><span class="line">        res[j++][n-i<span class="number">-1</span>] = k++;</span><br><span class="line">        j = n - i - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>( j &gt; i )                  <span class="comment">// 3. horizonal, right to left </span></span><br><span class="line">        res[n-i<span class="number">-1</span>][j--] = k++;</span><br><span class="line">        j = n - i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( j &gt; i )                  <span class="comment">// 4. vertical, bottom to  top </span></span><br><span class="line">        res[j--][i] = k++;</span><br><span class="line">        i++;      <span class="comment">// next loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h3><p>Define the four edge point to do the traverse.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> top= <span class="number">0</span>, left= <span class="number">0</span>, bot= n<span class="number">-1</span>, right= n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(top&lt;= bot &amp;&amp; left&lt;= right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= left; i&lt;= right; i++)&#123;</span><br><span class="line">                res[top][i]= count++;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= top; i&lt;= bot; i++)&#123;</span><br><span class="line">                res[i][right]= count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= right; i&gt;= left; i--)&#123;</span><br><span class="line">                res[bot][i]= count++;</span><br><span class="line">            &#125;</span><br><span class="line">            bot--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= bot; i&gt;= top; i--)&#123;</span><br><span class="line">                res[i][left]= count++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>54. Spiral Matrix</title>
      <link href="/2018/05/30/54-Spiral-Matrix/"/>
      <url>/2018/05/30/54-Spiral-Matrix/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p>Solution:<br>This is a very simple and easy to understand solution. I traverse right and increment rowBegin, then traverse down and decrement colEnd, then I traverse left and decrement rowEnd, and finally I traverse up and increment colBegin.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()== <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>].size()== <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rowBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowEnd = matrix.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> colBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> colEnd = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd) &#123;</span><br><span class="line">            <span class="comment">// Traverse Right</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colBegin; j &lt;= colEnd; j ++) &#123;</span><br><span class="line">                res.push_back(matrix[rowBegin][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            rowBegin++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Traverse Down</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowBegin; j &lt;= rowEnd; j ++) &#123;</span><br><span class="line">                res.push_back(matrix[j][colEnd]);</span><br><span class="line">            &#125;</span><br><span class="line">            colEnd--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (rowBegin &lt;= rowEnd) &#123;</span><br><span class="line">                <span class="comment">// Traverse Left</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = colEnd; j &gt;= colBegin; j --) &#123;</span><br><span class="line">                    res.push_back(matrix[rowEnd][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rowEnd--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (colBegin &lt;= colEnd) &#123;</span><br><span class="line">                <span class="comment">// Traver Up</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = rowEnd; j &gt;= rowBegin; j --) &#123;</span><br><span class="line">                    res.push_back(matrix[j][colBegin]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            colBegin ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>16. 3Sum Closest</title>
      <link href="/2018/05/29/16-3Sum-Closest/"/>
      <url>/2018/05/29/16-3Sum-Closest/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></p><p>Solution:</p><p>Sort the vector and then no need to run O(N^3) algorithm as each index has a direction to move.</p><p>The code starts from this formation.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">----------------------------------------------------</span><br><span class="line">^  ^                                               ^</span><br><span class="line">|  |                                               |</span><br><span class="line">|  +- second                                     third</span><br><span class="line">+-first</span><br></pre></td></tr></table></figure></p><p>if nums[first] + nums[second] + nums[third] is smaller than the target, we know we have to increase the sum. so only choice is moving the second index forward.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------</span><br><span class="line">^    ^                                             ^</span><br><span class="line">|    |                                             |</span><br><span class="line">|    +- second                                   third</span><br><span class="line">+-first</span><br></pre></td></tr></table></figure></p><p>if the sum is bigger than the target, we know that we need to reduce the sum. so only choice is moving ‘third’ to backward. of course if the sum equals to target, we can immediately return the sum.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------</span><br><span class="line">^    ^                                          ^</span><br><span class="line">|    |                                          |</span><br><span class="line">|    +- second                                third</span><br><span class="line">+-first</span><br></pre></td></tr></table></figure></p><p>when second and third cross, the round is done so start next round by moving ‘first’ and resetting second and third.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------</span><br><span class="line">  ^    ^                                           ^</span><br><span class="line">  |    |                                           |</span><br><span class="line">  |    +- second                                 third</span><br><span class="line">  +-first</span><br></pre></td></tr></table></figure></p><p>while doing this, collect the closest sum of each stage by calculating and comparing delta. Compare abs(target-newSum) and abs(target-closest). At the end of the process the three indexes will eventually be gathered at the end of the array.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------</span><br><span class="line">                                         ^    ^    ^</span><br><span class="line">                                         |    |    `- third</span><br><span class="line">                                         |    +- second</span><br><span class="line">                                         +-first</span><br></pre></td></tr></table></figure></p><p>if no exactly matching sum has been found so far, the value in closest will be the answer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> closest = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]; <span class="comment">//pick a sum value to compare</span></span><br><span class="line">        sort(nums.begin(), nums.end()); <span class="comment">//sort the array, takes O(log n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span> ; first &lt; nums.size()<span class="number">-2</span> ; ++first) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//skip the duplicate items</span></span><br><span class="line">            <span class="keyword">int</span> second = first+<span class="number">1</span>; <span class="comment">//2nd pointer go toward left</span></span><br><span class="line">            <span class="keyword">int</span> third = nums.size()<span class="number">-1</span>; <span class="comment">//3rdd pointer go toward right         </span></span><br><span class="line">            <span class="keyword">while</span>(second &lt; third) &#123; <span class="comment">//use 1st pointer as index, find the set has closest sum</span></span><br><span class="line">                <span class="keyword">int</span> curSum = nums[first]+nums[second]+nums[third];</span><br><span class="line">                <span class="keyword">if</span>(curSum == target) <span class="keyword">return</span> curSum;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(target-curSum)&lt;<span class="built_in">abs</span>(target-closest)) &#123;</span><br><span class="line">                    closest = curSum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curSum &gt; target) &#123; <span class="comment">//because the array is sorted, we can decide where the pointer should move.</span></span><br><span class="line">                    --third;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>81. Search in Rotated Sorted Array II</title>
      <link href="/2018/05/29/81-Search-in-Rotated-Sorted-Array-II/"/>
      <url>/2018/05/29/81-Search-in-Rotated-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).</p><p>You are given a target value to search. If found in the array return true, otherwise return false.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Follow up:</p><p>This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.<br>Would this affect the run-time complexity? How and why?</p><p>Solution:</p><p>1) everytime check if targe == nums[mid], if so, we find it.<br>2) otherwise, we check if the first half is in order (i.e. nums[left]&lt;=nums[mid])<br>  and if so, go to step 3), otherwise, the second half is in order,   go to step 4)<br>3) check if target in the range of [left, mid-1] (i.e. nums[left]&lt;=target &lt; nums[mid]), if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;<br>4)  check if target in the range of [mid+1, right] (i.e. nums[mid]&lt;target &lt;= nums[right]), if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1;</p><p>The only difference is that due to the existence of duplicates, we can have nums[left] == nums[mid] and in that case, the first half could be out of order (i.e. NOT in the ascending order, e.g. [3 1 2 3 3 3 3]) and we have to deal this case separately. In that case, it is guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]== nums[left] == nums[right] before the original logic, and if so, we can move left and right both towards the middle by 1. and repeat.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right =  nums.size()<span class="number">-1</span>, mid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// the only difference from the first one, trickly case, just updat left and right</span></span><br><span class="line">            <span class="keyword">if</span>( (nums[left] == nums[mid]) &amp;&amp; (nums[right] == nums[mid]) ) &#123;++left; --right;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left] &lt;= nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( (nums[left]&lt;=target) &amp;&amp; (nums[mid] &gt; target) ) right = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[mid] &lt; target) &amp;&amp;  (nums[right] &gt;= target) ) left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> linkedin </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>153. Find Minimum in Rotated Sorted Array</title>
      <link href="/2018/05/25/153-Find-Minimum-in-Rotated-Sorted-Array/"/>
      <url>/2018/05/25/153-Find-Minimum-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3,4,5,1,2] </span><br><span class="line">Output: 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p><p>Solution:<br>Case 1. The leftmost value is less than the rightmost value in the list: This means that the list is not rotated.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3 4 5 6 7 ]</span><br></pre></td></tr></table></figure></p><p>Case 2. The value in the middle of the list is greater than the leftmost and rightmost values in the list.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 4 5 6 7 0 1 2 3 ]</span><br></pre></td></tr></table></figure></p><p>Case 3. The value in the middle of the list is less than the leftmost and rightmost values in the list.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 5 6 7 0 1 2 3 4 ]</span><br></pre></td></tr></table></figure></p><p>As you see in the examples above, if we have case 1, we just return the leftmost value in the list. If we have case 2, we just move to the right side of the list. If we have case 3 we need to move to the left side of the list.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=num.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (start&lt;end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[start]&lt;num[end])</span><br><span class="line">                <span class="keyword">return</span> num[start];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num[mid]&gt;=num[start]) &#123;</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>48. Rotate Image</title>
      <link href="/2018/05/25/48-Rotate-Image/"/>
      <url>/2018/05/25/48-Rotate-Image/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given an n x n 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><p>Note:</p><p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given input matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ul><li>clockwise rotate:<br>first reverse up to down, then swap the symmetry <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     7 8 9     7 4 1</span><br><span class="line">4 5 6  =&gt; 4 5 6  =&gt; 8 5 2</span><br><span class="line">7 8 9     1 2 3     9 6 3</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    reverse(matrix.begin(), matrix.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since we only need to do three swaps in 3*3 example, the following code is more readable<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    reverse(matrix.begin(), matrix.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; matrix.size(); i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; i; j++)&#123;</span><br><span class="line">        swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>anticlockwise rotate:<br>first reverse left to right, then swap the symmetry<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     3 2 1     3 6 9</span><br><span class="line">4 5 6  =&gt; 6 5 4  =&gt; 2 5 8</span><br><span class="line">7 8 9     9 8 7     1 4 7</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vi : matrix) reverse(vi.begin(), vi.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^2)$<br>space complexity: $O(1)$</p><h3 id="Another-solution"><a href="#Another-solution" class="headerlink" title="Another solution:"></a>Another solution:</h3><p>The idea is to define the a range to do the swapping every loop.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> top= <span class="number">0</span>, left= <span class="number">0</span>, bot= matrix.size()<span class="number">-1</span>, right= matrix[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n= matrix.size();</span><br><span class="line">        <span class="keyword">while</span>(n&gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp= matrix[top][left+i];</span><br><span class="line">                matrix[top][left+i]= matrix[bot-i][left];</span><br><span class="line">                matrix[bot-i][left]= matrix[bot][right-i];</span><br><span class="line">                matrix[bot][right-i]= matrix[top+i][right];</span><br><span class="line">                matrix[top+i][right]= tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            top++; left++; right--; bot--;</span><br><span class="line">            n-=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/qnuhzL" target="_blank" rel="noopener">https://goo.gl/qnuhzL</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>369. Plus One Linked List</title>
      <link href="/2018/05/21/369-Plus-One-Linked-List/"/>
      <url>/2018/05/21/369-Plus-One-Linked-List/</url>
      <content type="html"><![CDATA[<p>Problem Description:<br>Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.</p><p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p><p>The digits are stored such that the most significant digit is at the head of the list.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:</span><br><span class="line">1-&gt;2-&gt;3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1-&gt;2-&gt;4</span><br></pre></td></tr></table></figure></p><p>Solution:<br>The key point is to find 9’s.<br>For example: 8-&gt;7-&gt;9-&gt;9<br>Add dummy: 0-&gt;8-&gt;7-&gt;9-&gt;9<br>The lastNotNine is 7.<br>7 + 1 = 8<br>9 change to 0.<br>We got 0-&gt;8-&gt;8-&gt;0-&gt;0<br>return dummy.next</p><p>For example: 9-&gt;9-&gt;9<br>Add dummy: 0-&gt;9-&gt;9-&gt;9<br>The lastNotNine is 0.<br>0 + 1 = 1<br>9 change to 0.<br>We got 1-&gt;0-&gt;0-&gt;0<br>return dummy</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">plusOne</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode* dmy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* lastNot9 = dmy;</span><br><span class="line">        dmy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* n = head; n != <span class="literal">NULL</span>; n = n-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n-&gt;val != <span class="number">9</span>) lastNot9 = n; <span class="comment">/* invariant: [lastNot9.next, tail] are all 9*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        lastNot9-&gt;val++;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* n = lastNot9-&gt;next; n != <span class="literal">NULL</span>; n = n-&gt;next) &#123;</span><br><span class="line">            n-&gt;val = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dmy-&gt;val == <span class="number">1</span> ? dmy : head;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>445. Add Two Numbers II</title>
      <link href="/2018/05/19/445-Add-Two-Numbers-II/"/>
      <url>/2018/05/19/445-Add-Two-Numbers-II/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Follow up:<br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: (6 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 6 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure></p><p>Solution:<br>This question is a followup from “2. Add two number.” The different part is that the significant digit comes first. However, we need to start from least significant digit when we do calculation. Even though the question states that you can not modify the input list, we can use a stack, first in last out, to achieve the reverse order calculation.</p><p>Space: O(n)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s1.push(l1-&gt;val);</span><br><span class="line">            l1= l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s2.push(l2-&gt;val);</span><br><span class="line">            l2= l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">        ListNode* <span class="built_in">list</span>= <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() ||!s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!s1.empty()) &#123;</span><br><span class="line">                sum += s1.top();</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s2.empty())&#123;</span><br><span class="line">                sum += s2.top();  </span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="built_in">list</span>-&gt;val = sum %<span class="number">10</span>;</span><br><span class="line">            ListNode* head = <span class="keyword">new</span> ListNode(sum/<span class="number">10</span>);</span><br><span class="line">            head-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">            <span class="built_in">list</span> = head;</span><br><span class="line">            sum/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>-&gt;val ==<span class="number">0</span> ? <span class="built_in">list</span>-&gt;next: <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Second time:<br>Thought process: we need to start calculation from the last node. More specifically, we need to calculate backward, and <code>Stack</code> is a good way to do so. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stk1 = <span class="keyword">new</span> Stack();</span><br><span class="line">        Stack&lt;ListNode&gt; stk2 = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stk1.push(l1);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stk2.push(l2);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head = dummy;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stk1.size() != <span class="number">0</span> || stk2.size() != <span class="number">0</span> || carry != <span class="number">0</span>)&#123;</span><br><span class="line">            ListNode newNode = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            <span class="keyword">if</span>(!stk1.empty())&#123;</span><br><span class="line">                newNode.val += stk1.pop().val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stk2.empty())&#123;</span><br><span class="line">                newNode.val += stk2.pop().val;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            carry = newNode.val/<span class="number">10</span>;</span><br><span class="line">            newNode.val %= <span class="number">10</span>;</span><br><span class="line">            ListNode tmp = head.next;</span><br><span class="line">            newNode.next = tmp;</span><br><span class="line">            head.next = newNode;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>we can simplify the code to this<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stk1 = <span class="keyword">new</span> Stack();</span><br><span class="line">        Stack&lt;ListNode&gt; stk2 = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stk1.push(l1);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stk2.push(l2);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode list = <span class="keyword">null</span>; <span class="comment">//represents the first node of result list, init is null</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stk1.size() != <span class="number">0</span> || stk2.size() != <span class="number">0</span> || carry != <span class="number">0</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!stk1.empty()) carry += stk1.pop().val;</span><br><span class="line">            <span class="keyword">if</span>(!stk2.empty()) carry += stk2.pop().val;</span><br><span class="line">            </span><br><span class="line">            ListNode newHead = <span class="keyword">new</span> ListNode(carry%<span class="number">10</span>);</span><br><span class="line">            newHead.next = list; </span><br><span class="line">            list = newHead;</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p><p>related question:<br><a href="/2020/05/16/2-Add-Two-Numbers/" title="2. Add Two Numbers">2. Add Two Numbers</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/2018/05/15/15-3Sum/"/>
      <url>/2018/05/15/15-3Sum/</url>
      <content type="html"><![CDATA[<h2 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:</p><p>The solution set must not contain duplicate triplets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><ol><li>Sort the array</li><li>Pick indices from 0…n-2. To n-2 is because we need to find 3 item sequence. If we sort the array, need to at least save one spot for right element.</li><li>Bypass duplicate element</li><li>Use two pointers, one goes from i+1 toward right, the other one goes from n toward left</li><li>If the sum of two pointers can not make the sequence zero, move the point.<br>To clarify, we can only move one pointer to make the result close to zero.</li></ol><p>Example:<br>input nums<code>[-1, 0, 1, 2, -1, -4]</code><br>sort  nums<code>[-4, -1, -1, 0, 1, 2]</code></p><p>start from nums[0]= -4, pointer1= nums[1], pointer2= nums[6-1]</p><p>Solution:<br>Time: <code>O(n^2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            l, r = i+<span class="number">1</span>, len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                s = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    l +=<span class="number">1</span> </span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append((nums[i], nums[l], nums[r]))</span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l+<span class="number">1</span>]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r<span class="number">-1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span>; r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span>) <span class="keyword">return</span> res; <span class="comment">//edge case check</span></span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-2</span>; ++i)&#123; <span class="comment">//-2 is because last possible 3Sum sequence could be last 3 item, </span></span><br><span class="line">                                                <span class="comment">//and the center is n-2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="comment">//pass duplicate elements</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>, k=nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span>-nums[i]; <span class="comment">//because the other two elements would make sequence zero</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(j&lt; k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]+ nums[k] == target)&#123;</span><br><span class="line">                    res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k &amp;&amp; nums[j]==nums[j<span class="number">-1</span>]) j++;<span class="comment">//skip same element</span></span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k &amp;&amp; nums[k]==nums[k+<span class="number">1</span>]) k--;<span class="comment">//skip same element</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[j]+ nums[k]&gt;target)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="second-time"><a href="#second-time" class="headerlink" title="second time"></a>second time</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        /*</span><br><span class="line">        1. sort array</span><br><span class="line">        2. totally three pointers, one pointer as a start point, other two traverse</span><br><span class="line">        3. two traverse pointer, left and right, decrease or increase beased on different conditions</span><br><span class="line">        */</span><br><span class="line">        if(nums.size()&lt; 3) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(int i= 0; i&lt; nums.size()-2; i++)&#123;</span><br><span class="line">            if(i&gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;</span><br><span class="line">            int left= i+1, right= nums.size()-1;</span><br><span class="line">            while(left&lt; right)&#123;</span><br><span class="line">                int result= nums[i]+ nums[left]+ nums[right];</span><br><span class="line">                if(result == 0) &#123;</span><br><span class="line">                    res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left++], nums[right--]&#125;);</span><br><span class="line">                    while(left&lt; right &amp;&amp; nums[left]== nums[left-1]) left++;</span><br><span class="line">                    while(left&lt; right &amp;&amp; nums[right]== nums[right+1]) right--;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(result &lt; 0) left++;</span><br><span class="line">                else right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>413. Arithmetic Slices</title>
      <link href="/2018/05/14/413-Arithmetic-Slices/"/>
      <url>/2018/05/14/413-Arithmetic-Slices/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p><p>For example, these are arithmetic sequence:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure></p><p>The following sequence is not arithmetic.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure></p><p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p><p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p><p>The function should return the number of arithmetic slices in the array A.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.</span><br></pre></td></tr></table></figure></p><p>solution1:</p><p>use 1D dp array. When we have a arithmetic slice in 1…i, which can create total X arithmetic slice, and we got the i+1 element with same distance(slice) as before, the i+1 element can create additional X+1 arithmetic slice. And the sum of arithmetic slices create by sequence 1…i+1 elements would be X+(X+1).<br>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      1,3,5,7,9,15,20,25,28,29</span><br><span class="line">dp    0 0 1 2 3 0  0  1  0  0</span><br><span class="line">sum       1 3 6 6  6  7  7  7</span><br></pre></td></tr></table></figure></p><p>In the above example, [1,3,5] can make the first slice.<br>When we add 7 into the sequence, it creates [3,5,7] and [1,3,5,7] slices.<br>Therefore, total slices when we consider sequence [1,3,5,7] would be<br>[1,3,5]: which is created and stored in dp[2]<br>[3,5,7], [1,3,5,7]: in dp[3]<br>Total: 3 slices</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(A.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span> + dp[i - <span class="number">1</span>];</span><br><span class="line">                sum += dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Time: O(n)<br>Space: O(n)</p><p>solution2:<br>Since if we don’t have consecutive sequence, we don’t need the dp. We can use a integer to store the slices created by previous consecutive sequence. When the consecutive sequence end, A[i]-A[i-1] != A[i-1]-A[i-2], just reset the counter to zero.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp+=<span class="number">1</span>;</span><br><span class="line">                sum += dp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Time: O(n)<br>Space: O(1)</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>357. Count Numbers with Unique Digits</title>
      <link href="/2018/05/14/357-Count-Numbers-with-Unique-Digits/"/>
      <url>/2018/05/14/357-Count-Numbers-with-Unique-Digits/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n.</p><p>Example:<br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</p><p>Following the hint. Let f(n) = count of number with unique digits of length n.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f(1) = 10. (0, 1, 2, 3, ...., 9)</span><br><span class="line"></span><br><span class="line">f(2) = 9 * 9. Because for each number i from 1, ..., 9, we can pick j to form a 2-digit number ij and there are 9 numbers that are different from i for j to choose from.</span><br><span class="line"></span><br><span class="line">f(3) = f(2) * 8 = 9 * 9 * 8. Because for each number with unique digits of length 2, say ij, we can pick k to form a 3 digit number ijk and there are 8 numbers that are different from i and j for k to choose from.</span><br><span class="line"></span><br><span class="line">Similarly f(4) = f(3) * 7 = 9 * 9 * 8 * 7....</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">f(10) = 9 * 9 * 8 * 7 * 6 * ... * 1</span><br><span class="line"></span><br><span class="line">f(11) = 0 = f(12) = f(13)....</span><br></pre></td></tr></table></figure></p><p>any number with length &gt; 10 couldn’t be unique digits number.</p><p>The problem is asking for numbers from 0 to 10^n. Hence return f(1) + f(2) + .. + f(n)</p><p>As @4acreg suggests, There are only 11 different ans. You can create a lookup table for it. This problem is O(1) in essence</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">10</span>, base = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n &amp;&amp; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            base *= (<span class="number">9</span> - i + <span class="number">2</span>);</span><br><span class="line">            ans += base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">        if(n == 0) return 1;</span><br><span class="line">        int res = 10; //original case</span><br><span class="line">        int uniqueDigits = 9;</span><br><span class="line">        int available = 9;</span><br><span class="line">        </span><br><span class="line">        while(n-- &gt;1 &amp;&amp; available &gt;0)&#123;</span><br><span class="line">            uniqueDigits = uniqueDigits* available; //recursively multiply the remain digits</span><br><span class="line">            res += uniqueDigits; //The answer ask from 0&lt;=x&lt;= 10^n, so need to add the result</span><br><span class="line">            available--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        */</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> backtracking </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>95. Unique Binary Search Trees II</title>
      <link href="/2018/05/14/95-Unique-Binary-Search-Trees-II/"/>
      <url>/2018/05/14/95-Unique-Binary-Search-Trees-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&apos;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Tree can be divided into three parts<br>Picking ith element in 1…n sequence, the subtree would be<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  V       </span><br><span class="line"> / \      L: 1...i-1</span><br><span class="line">L   R     R: i+1...n</span><br></pre></td></tr></table></figure></p><p>Therefore, we need a function that could generate trees that take 2 inputs, start and end.<br>By recursively calling this subfunction, we can generate different trees.<br>One thing to notice is that, after the recursive, we should have a root node to catch these different left and right trees.<br>That is to say, if we have sequence [1,2,3,4,5] and we pick 3 as root.<br>L would be [1,2], R [4,5].<br>It’s easy to see that the Left tree could have these two shape.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1        2                                                                       3           3</span><br><span class="line">  / \      / \          ==adding the subtree to left side with 3 as root ==&gt;       /           /</span><br><span class="line">null 2    1   null                                                                1           2</span><br><span class="line">                                                                                 / \         / \</span><br><span class="line">                                                                               null 2       1  null</span><br></pre></td></tr></table></figure></p><p>The right part is the same, so I just draw left part on it.<br>Finally, push the new tree to the vector and return it to upper recursive.</p><p>time: O(catalan(n)), <a href="https://goo.gl/umK2Fl" target="_blank" rel="noopener">https://goo.gl/umK2Fl</a><br>space: O(log(n)), tree space is log(n) with total node n</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(l, r)</span>:</span>   <span class="comment"># split between [l, r)</span></span><br><span class="line">            <span class="keyword">if</span> l == r:</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">None</span>]</span><br><span class="line">            nodes = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</span><br><span class="line">                <span class="keyword">for</span> lchild <span class="keyword">in</span> generate(l, i):</span><br><span class="line">                    <span class="keyword">for</span> rchild <span class="keyword">in</span> generate(i+<span class="number">1</span>, r):</span><br><span class="line">                        node = TreeNode(i+<span class="number">1</span>)   </span><br><span class="line">                        <span class="comment"># +1 to convert the index to the actual value</span></span><br><span class="line">                        node.left = lchild</span><br><span class="line">                        node.right = rchild</span><br><span class="line">                        nodes.append(node)</span><br><span class="line">            <span class="keyword">return</span> nodes</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="number">0</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">  struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">      int val;</span></span><br><span class="line"><span class="comment">      TreeNode *left;</span></span><br><span class="line"><span class="comment">      TreeNode *right;</span></span><br><span class="line"><span class="comment">      TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">return</span> genTree(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; genTree(<span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            <span class="built_in">list</span>.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="built_in">list</span>.push_back(<span class="keyword">new</span> TreeNode(start));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; left, right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt;= end; ++i)&#123;</span><br><span class="line">            left = genTree(start, i<span class="number">-1</span>);</span><br><span class="line">            right = genTree(i+<span class="number">1</span>,end);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> lnode: left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> rnode: right)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = lnode;</span><br><span class="line">                    root-&gt;right = rnode;</span><br><span class="line">                    <span class="built_in">list</span>.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>96. Unique Binary Search Trees</title>
      <link href="/2018/05/13/96-Unique-Binary-Search-Trees/"/>
      <url>/2018/05/13/96-Unique-Binary-Search-Trees/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&apos;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The problem can be solved in a dynamic programming way. I’ll explain the intuition and formulas in the following.</p><p>Given a sequence 1…n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1…(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)…n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique, since they have unique roots.</p><p>The problem is to calculate the number of unique BST. To do so, we need to define two functions:</p><p><code>G(n)</code>: the number of unique BST for a sequence of length n.</p><p><code>F(i, n)</code>, 1 &lt;= i &lt;= n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n.</p><p>As one can see, G(n) is the actual function we need to calculate in order to solve the problem. And G(n) can be derived from F(i, n), which at the end, would recursively refer to G(n).</p><p>First of all, given the above definitions, we can see that the total number of unique BST G(n), is the sum of BST F(i) using each number i as a root.<br>i.e.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G(n) = F(1, n) + F(2, n) + ... + F(n, n).</span><br></pre></td></tr></table></figure><p>Particularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree).<br>i.e.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G(0)=1, G(1)=1.</span><br></pre></td></tr></table></figure><p>Given a sequence 1…n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root <code>F(i)</code>, is the cartesian product of the number of BST for its left and right subtrees. For example, <code>F(3, 7)</code>: the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence <code>[1, 2, 3, 4, 5, 6, 7]</code> with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence <code>[1, 2]</code> and another BST out of the right subsequence <code>[4, 5, 6, 7]</code>, and then combine them together (i.e. cartesian product). The tricky part is that we could consider the number of unique BST out of sequence <code>[1,2]</code> as <code>G(2)</code>, and the number of of unique BST out of sequence <code>[4, 5, 6, 7]</code> as <code>G(4)</code>. Therefore, <code>F(3,7) = G(2) * G(4)</code>.</p><p>i.e.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F(i, n) = G(i-1) * G(n-i)1 &lt;= i &lt;= n</span><br></pre></td></tr></table></figure></p><p>Combining the above two formulas, we obtain the recursive formula for G(n). i.e.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)</span><br></pre></td></tr></table></figure></p><p>In terms of calculation, we need to start with the lower number, since the value of G(n) depends on the values of G(0) … G(n-1).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>]* (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># F(i, n) denote as number of tree use i as root when n nodes</span></span><br><span class="line">        <span class="comment"># F(i, n) = G(i-1)* G(n-i)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dp[n] = dp[0]*dp[n-1] + dp[1]*dp[n-2] + ... + dp[n-1]* dp[0]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>]* dp[i-j]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; ++j) &#123;</span><br><span class="line">                G[i] += G[j<span class="number">-1</span>] * G[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Second time<br>Remembered the idea. elaborate the idea below.<br>Use [1,2,3,4,5] as example</li></ul><ol><li><p>Draw graph with each element to be root.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">  [2,3,4,5]</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line"> [1] [3,4,5]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">[1,2] [4,5]</span><br><span class="line"></span><br><span class="line">      4</span><br><span class="line">     / \</span><br><span class="line">[1,2,3] [5]</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     /  </span><br><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure></li><li><p>number of Tree with <code>i</code> as root: <code>T(i)= T(i-1)*T(n-i)</code>, 1&lt;=i&lt;=n</p></li><li>problem description ask for total number of trees from <code>1...i</code>, so need to add it together.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]= dp[<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;= i; j++)&#123;</span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3:"></a>Solution 3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                 1                        n = 1</span><br><span class="line"></span><br><span class="line">             2        1                   n = 2</span><br><span class="line">            /          \</span><br><span class="line">           1            2</span><br><span class="line">  </span><br><span class="line">1         3     3      2      1           n = 3</span><br><span class="line"> \       /     /      / \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> /     /       \                 \</span><br><span class="line">2     1         2                 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[2] =  dp[0] * dp[1]　　　(use 1 as root)</span><br><span class="line">         + dp[1] * dp[0]　　(use 2 as root)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[3] =  dp[0] * dp[2]　　　(use 1 as root)</span><br><span class="line"></span><br><span class="line">　　　　+ dp[1] * dp[1]　　  (use 2 as root)</span><br><span class="line"></span><br><span class="line"> 　　　  + dp[2] * dp[0]　　 (use 3 as root)</span><br></pre></td></tr></table></figure><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/4299608.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4299608.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
            <tag> snapchat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>221. Maximal Square</title>
      <link href="/2018/05/12/221-Maximal-Square/"/>
      <url>/2018/05/12/221-Maximal-Square/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>solution1:<br>time: O(mn)<br>space: O(mn)<br><img src="221_Maximal_Square.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = m&gt;<span class="number">0</span> ? matrix[<span class="number">0</span>].size(): <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j<span class="number">-1</span>], min(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>])) +<span class="number">1</span>;</span><br><span class="line">                    maxlen = max(maxlen, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen*maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>solution2:<br>time: O(mn)<br>space: O(n)<br><img src="221_Maximal_Square1.png" alt=""><br>dp[j] is to store the square that can be made in this<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size(), n = m&gt;0 ? matrix[0].size(): 0;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0);</span><br><span class="line">        int maxlen = 0, prev= 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i&lt;= m; ++i)&#123;</span><br><span class="line">            for(int j= 1; j&lt;= n; ++j)&#123;</span><br><span class="line">                int temp = dp[j];</span><br><span class="line">                //cout&lt;&lt; &quot;dp[&quot;&lt;&lt;j&lt;&lt;&quot;]:&quot;&lt;&lt;dp[j]&lt;&lt;endl;</span><br><span class="line">                //cout&lt;&lt;&quot;temp:&quot;&lt;&lt; temp&lt;&lt;endl;</span><br><span class="line">                if(matrix[i-1][j-1] == &apos;1&apos;)&#123;</span><br><span class="line">                    dp[j] = min(dp[j-1], min(prev, dp[j]))+1;</span><br><span class="line">                    //+1 is because if this element is &apos;1&apos;, it at least can form a square by itself even previous is 0</span><br><span class="line">                    //cout&lt;&lt; &quot;dp[&quot;&lt;&lt;j&lt;&lt;&quot;-1]:&quot;&lt;&lt;dp[j-1];</span><br><span class="line">                    //cout&lt;&lt; &quot;, prev:&quot;&lt;&lt;prev;</span><br><span class="line">                    //cout&lt;&lt; &quot;, dp[&quot;&lt;&lt;j&lt;&lt;&quot;]:&quot;&lt;&lt;dp[j]&lt;&lt;endl;</span><br><span class="line">                    //dp[i][j] = min(dp[i][j-1], min(dp[i-1][j], dp[i-1][j-1])) +1;</span><br><span class="line">                    maxlen = max(maxlen, dp[j]);</span><br><span class="line">                    //cout&lt;&lt;&quot;max=&quot;&lt;&lt;maxlen&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    dp[j] = 0;</span><br><span class="line">                    //cout&lt;&lt; &quot;else dp[&quot;&lt;&lt;j&lt;&lt;&quot;]:&quot;&lt;&lt;dp[j]&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">                prev= temp;</span><br><span class="line">                //cout&lt;&lt;&quot;----&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto n: dp)</span><br><span class="line">            cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">        return maxlen*maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> apple </tag>
            
            <tag> medium </tag>
            
            <tag> airbnb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>85. Maximal Rectangle</title>
      <link href="/2018/05/12/85-Maximal-Rectangle/"/>
      <url>/2018/05/12/85-Maximal-Rectangle/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(matrix.size() &lt;= <span class="number">0</span> || matrix[<span class="number">0</span>].size()&lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size() + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//take care of the size, because we need to calculate the item in stack twice</span></span><br><span class="line">        <span class="comment">//just like 84., also need to push last item to the stack</span></span><br><span class="line">        <span class="keyword">int</span> h= <span class="number">0</span>, w= <span class="number">0</span>, ret= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; height(n, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; n; ++j)&#123;</span><br><span class="line">                <span class="comment">//set height, </span></span><br><span class="line">                <span class="keyword">if</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//this is to check whether the j is the extra boundary case we need to calculate</span></span><br><span class="line">                    <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>) height[j]+= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> height[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//this is pretty similiar to 84</span></span><br><span class="line">                <span class="keyword">while</span>(!s.empty() &amp;&amp; height[s.top()] &gt;= height[j])&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt; s.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    h = height[s.top()];</span><br><span class="line">                    s.pop();</span><br><span class="line">                    w = s.empty() ? j: j-s.top()<span class="number">-1</span>;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt; <span class="string">"h= "</span>&lt;&lt; h&lt;&lt;<span class="string">", w= "</span>&lt;&lt;w&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">if</span>(h*w &gt; ret) ret = h*w;</span><br><span class="line">                &#125;</span><br><span class="line">                s.push(j);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt; <span class="string">"j= "</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;   </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/3yW7Xc" target="_blank" rel="noopener">https://goo.gl/3yW7Xc</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> stack </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>84. Largest Rectangle in Histogram</title>
      <link href="/2018/05/12/84-Largest-Rectangle-in-Histogram/"/>
      <url>/2018/05/12/84-Largest-Rectangle-in-Histogram/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>  Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br>  <img src="1.png" alt=""><br>  Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].<br>  <img src="2.png" alt=""><br>  The largest rectangle is shown in the shaded area, which has area = 10 unit.</p><p>  Example:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        height.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: height)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"i: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">4</span>) <span class="built_in">cout</span>&lt;&lt;index.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">while</span>(index.size() &gt; <span class="number">0</span> &amp;&amp; height[index.back()] &gt;= height[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> h = height[index.back()];</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt; <span class="string">"h:"</span> &lt;&lt;h;</span><br><span class="line">                index.pop_back();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> sidx = index.size() &gt; <span class="number">0</span> ? index.back() : <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt; <span class="string">", sidx:"</span> &lt;&lt;sidx;</span><br><span class="line">                <span class="keyword">if</span>(h * (i-sidx<span class="number">-1</span>) &gt; ret)</span><br><span class="line">                    ret = h * (i-sidx<span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt; <span class="string">", calculate:"</span> &lt;&lt;h * (i-sidx<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"ret: "</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            index.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time"></a>Second time</h1><p>This is a relatively straightforward solution. Use a pointer to find toward right, if a histogram <code>i</code> is greater than <code>i+1</code>, then we find a left boundary of this histogram <code>i</code>. At this time, we traverse back toward left, find every <code>minimum height</code> and multiply with the width to get the area.<br>指針往右遍歷, 當height[i]&lt; height[i+1]: keep go right, 因如果後面比較高, 則maximum area 至少包含後面的 histogram.</p><p>example:<br><code>[2,4,6,5,3]</code></p><ol><li>reach 6, next is 5.<br> minimum height* width= area<pre><code>6*1= 64*2= 82*3= 6</code></pre></li><li>reach 5, next is 3, smaller than 5.<pre><code>5*1= 55*2= 104*3= 122*4= 8</code></pre></li><li>reach 3, end condition<pre><code>3*1= 33*2= 63*3= 93*4= 122*5= 10</code></pre></li><li>max area is 12</li></ol><p>#Solution:</p><pre><code class="c++">    <span class="comment">//O(n^2)</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span><span class="keyword">public</span>:    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>{        <span class="keyword">int</span> res= <span class="number">0</span>;        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; heights.size(); i++){ <span class="comment">//go toward left</span>            <span class="keyword">if</span>(i== heights.size()<span class="number">-1</span> || heights[i]&gt; heights[i+<span class="number">1</span>]){ <span class="comment">//reached end || height[i]&gt; heigh[i+1]</span>                <span class="keyword">int</span> minh= heights[i];                <span class="keyword">for</span>(<span class="keyword">int</span> j= i; j&gt;=<span class="number">0</span>; j--){ <span class="comment">//go toward right, find every rectangle</span>                    minh= min(minh, heights[j]);                    <span class="keyword">int</span> area= minh* (i-j+<span class="number">1</span>);                    res= max(res, area);                }            }        }        <span class="keyword">return</span> res;    }};</code></pre><p>Reference:<br><a href="https://goo.gl/JusVW4" target="_blank" rel="noopener">https://goo.gl/JusVW4</a><br>leetcode.com/problems/maximal-rectangle/discuss/29054/Share-my-DP-solution/27983</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hard </tag>
            
            <tag> stack </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>72. Edit Distance</title>
      <link href="/2018/05/11/72-Edit-Distance/"/>
      <url>/2018/05/11/72-Edit-Distance/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>  Given two words word1 and word2, find the minimum number of operations required to<br>  convert word1 to word2.</p><p>  You have the following 3 operations permitted on a word:</p><p>  Insert a character<br>  Delete a character<br>  Replace a character<br>  Example 1:</p><p>  Input: word1 = “horse”, word2 = “ros”<br>  Output: 3<br>  Explanation:<br>  horse -&gt; rorse (replace ‘h’ with ‘r’)<br>  rorse -&gt; rose (remove ‘r’)<br>  rose -&gt; ros (remove ‘e’)<br>  Example 2:</p><p>  Input: word1 = “intention”, word2 = “execution”<br>  Output: 5<br>  Explanation:<br>  intention -&gt; inention (remove ‘t’)<br>  inention -&gt; enention (replace ‘i’ with ‘e’)<br>  enention -&gt; exention (replace ‘n’ with ‘x’)<br>  exention -&gt; exection (replace ‘n’ with ‘c’)<br>  exection -&gt; execution (insert ‘u’)</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n= word2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//convert word2 to word1 if word2 is empty, so the operation is m times</span></span><br><span class="line">        <span class="comment">//ex: word1: "ABCDE", word2= ""  </span></span><br><span class="line">        <span class="comment">//notice: start from 1 because dp[i][j] denotes word1[0...i-1] are the same as word2[0...j-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= m; ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//convert word1 to word2 if word1 is empty, so the operation is n times</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= n; ++i)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//replace: means till the dp[i-1][j-1] is the same, add 1 operation by replacement</span></span><br><span class="line">                    <span class="comment">//  example: word1: "ABCDE", word2: "ABCDF" </span></span><br><span class="line">                    <span class="comment">//           therefore, only needs to 1 move based on dp[i-1][j-1]</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//deletion: the question is convert from word1 to word2, </span></span><br><span class="line">                    <span class="comment">//          means till the dp[i-1][j] is the same, add 1 ...</span></span><br><span class="line">                    <span class="comment">//  example: word1: "ABCDE", word2: "ABCD". i=4 j=3</span></span><br><span class="line">                    <span class="comment">//           add 1 move based on dp[i-1][j]</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//insertion: the question is convert from word1 to word2, </span></span><br><span class="line">                    <span class="comment">//          means till the dp[i][j-1] is the same, add 1 ...</span></span><br><span class="line">                    <span class="comment">//  example: word1: "ABCD", word2: "ABCDE". i=3 j=4</span></span><br><span class="line">                    <span class="comment">//           add 1 move based on dp[i][j-1]</span></span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>, min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>, dp[i][j<span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>companylist</title>
      <link href="/2018/04/20/companylist/"/>
      <url>/2018/04/20/companylist/</url>
      <content type="html"><![CDATA[<p>——已推——</p><p>  Walmart Sam’s Club Technology 8/14, 8/29 tech interview<br>  <a href="https://goo.gl/BWxxLS" target="_blank" rel="noopener">https://goo.gl/BWxxLS</a></p><p>  FB, 8/15, 8/17 recruiter, 8/27 phone interview, 8/28 notify onsite, 9/24 onsite<br>  <a href="https://www.facebook.com/careers/life/preparing-for-your-software-engineering-interview-at-facebook" target="_blank" rel="noopener">https://www.facebook.com/careers/life/preparing-for-your-software-engineering-interview-at-facebook</a><br>  <a href="http://www.1point3acres.com/bbs/thread-435755-1-1.html" target="_blank" rel="noopener">http://www.1point3acres.com/bbs/thread-435755-1-1.html</a><br>  <a href="https://www.facebook.com/careers/jobs/a0I1H00000LCQMWUA5/" target="_blank" rel="noopener">https://www.facebook.com/careers/jobs/a0I1H00000LCQMWUA5/</a><br>  <a href="https://www.facebook.com/careers/jobs/a0I1H00000LBiNYUA1/" target="_blank" rel="noopener">https://www.facebook.com/careers/jobs/a0I1H00000LBiNYUA1/</a><br>  <a href="https://www.facebook.com/careers/jobs/a0I1200000JA4R2EAL/" target="_blank" rel="noopener">https://www.facebook.com/careers/jobs/a0I1200000JA4R2EAL/</a></p><p>  Amazon, 8/16, 8/17 confirm letter, 8/24 application information completed and submitted, 9/3 OA-9/16, 9/10 part II submitted, 12/6 VO 3 rounds, 12/7 reject<br>  kevin lai<br>  <a href="https://www.amazon.jobs/zh/jobs/697789/2019-software-development-engineer-united-states" target="_blank" rel="noopener">https://www.amazon.jobs/zh/jobs/697789/2019-software-development-engineer-united-states</a><br>  <a href="https://www.amazon.jobs/zh/jobs/678630/software-development-engineer" target="_blank" rel="noopener">https://www.amazon.jobs/zh/jobs/678630/software-development-engineer</a><br>  <a href="https://www.amazon.jobs/zh/jobs/697755/software-development-engineer" target="_blank" rel="noopener">https://www.amazon.jobs/zh/jobs/697755/software-development-engineer</a><br>  <a href="https://www.amazonuniversity.jobs/dashboard" target="_blank" rel="noopener">https://www.amazonuniversity.jobs/dashboard</a></p><p>  airbnb, 8/19, 8/21 reply will refer later, 8/27 refer<br>  <a href="https://goo.gl/koXpJ8" target="_blank" rel="noopener">https://goo.gl/koXpJ8</a></p><p>  VMWare propel program, 8/19, 9/1 refer<br>  <a href="https://goo.gl/Xguhhv" target="_blank" rel="noopener">https://goo.gl/Xguhhv</a></p><p>  Dropbox, 8/21<br>  <a href="https://goo.gl/h4dK78" target="_blank" rel="noopener">https://goo.gl/h4dK78</a><br>  <a href="https://www.dropbox.com/jobs/listing/1234094" target="_blank" rel="noopener">https://www.dropbox.com/jobs/listing/1234094</a><br>  9/1<br>  <a href="https://goo.gl/uHtGES" target="_blank" rel="noopener">https://goo.gl/uHtGES</a></p><p>  Microsoft, 8/24<br>  <a href="https://goo.gl/HTHD7h" target="_blank" rel="noopener">https://goo.gl/HTHD7h</a></p><p>  Twitter, 8/24, 9/12 OA received<br>  <a href="https://careers.twitter.com/en/university.html" target="_blank" rel="noopener">https://careers.twitter.com/en/university.html</a></p><p>  Bloomberg, 8/25, 8/28 reply and submitted application<br>  <a href="https://goo.gl/9XyYFh" target="_blank" rel="noopener">https://goo.gl/9XyYFh</a></p><p>  Linkedin, 8/27, OA received<br>  <a href="http://www.1point3acres.com/bbs/thread-439285-1-1.html" target="_blank" rel="noopener">http://www.1point3acres.com/bbs/thread-439285-1-1.html</a><br>  9/1<br>  <a href="https://goo.gl/bb75hg" target="_blank" rel="noopener">https://goo.gl/bb75hg</a></p><p>  Google, 8/28, 9/2 apply<br>  Chiawei</p><p>  Lockheed Martin, 9/4 career fair, 9/5 into pool should hear back in next week or 10 days. Check on 9/12</p><p>  Apple<br>  <a href="https://goo.gl/1NSyKy" target="_blank" rel="noopener">https://goo.gl/1NSyKy</a></p><p>  Box: wait for 2019 new grad position<br>  <a href="https://www.box.com/careers/open-positions" target="_blank" rel="noopener">https://www.box.com/careers/open-positions</a></p><p>  Fujitsu: 2/4 campus interview,<br>  L3: 2/12 phone interview, 2/28 onsite, 3/5 offer<br>  Google: phone interview on end of March, 3/29 onsite<br>  Amazon: 2/21 received OA, 2/25 finished OA, 3/13 phone interview, 3/22 onsite, 3/26 unofficial offer<br>    1st: team manager, bq<br>    2nd: bar raiser from other team, bq<br>    3rd: tech+bq: design a program that can get files in certain directory that<br>      a. have certain pattern in filename<br>      b. match the result of filesize(greater, equal, smaller)<br>    4th: LRU+bq<br>    5th: bq+batch of tasks, every batch is 100 task, try to make the same tasks in the same batch.</p><p>Rejected:<br>Cerner: 2/4 ask refer and submit, reject<br>Rally Health new grad, reject<br>Capsher: 1/23 career, 1/29 manager phone, reject<br>VISA: 10/9 received OA(3 day limitation), 10/12 finished OA,<br>TwoSigma: 10/2 received OA, 10/16 hr screen, reject<br>Mathworks: 10/10 submit application, 10/11 hm contact, 10/17 1st phone interview,reject<br>Citrix: 10/21 recruiter contacted from linkedin, 10/30 received schedule karat interview, 11/6 first phone interview, 11/30 onsite, reject<br>SAS: 11/4 received bq online<br>Viasat: hr email 2/20, 3/1 hr phone, check point, reject<br>Facebook/Instagram: Vlad referred on 2/20, should hear back 2/27, reject<br>Charles Schwab: 1/3 received email, 1/16 1st round hr screen, wait for March round over, 2/22 sent email check, 3/11 should hear back, not going to keep process<br>Goldman Sachs: 1/28 hr phone, 2/7 sent email check, 2/22 sent email check<br>JPMorgan Chase: 1/25 received OA, 2/7 hr phone, not responded and called<br>ARM: 2/5 received OA,<br>Ultimate Software: 2/26 hr phone, 3/3 finished OA<br>Expedia: 1/18 ask refer, 2/5 submit application<br>IBM: recruiter contacted, hr call 10/31<br>IBM 188447BR : Linux Networking Engineer EP</p><p>1/17<br>asked refer<br><a href="https://boards.greenhouse.io/thumbtack/jobs/38623?t=grtm7q&amp;s=LinkedIn&amp;source=LinkedIn" target="_blank" rel="noopener">https://boards.greenhouse.io/thumbtack/jobs/38623?t=grtm7q&amp;s=LinkedIn&amp;source=LinkedIn</a><br>google intern submit</p><p>1/18<br><a href="https://usaajobs.com/search/jobdetails/servicenow-developer---entry-level/3d887ad7-343e-4844-a9fe-f6f939ea257d?s_cid=linkedin" target="_blank" rel="noopener">https://usaajobs.com/search/jobdetails/servicenow-developer---entry-level/3d887ad7-343e-4844-a9fe-f6f939ea257d?s_cid=linkedin</a></p><p>1/19<br>Affirm<br><a href="https://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=472841#pid5505802" target="_blank" rel="noopener">https://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;tid=472841#pid5505802</a><br>——未推——<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">| Tier | company   | where found                                            | email                             | job search | freeze   | remark |</span><br><span class="line">|------|-----------|--------------------------------------------------------|-----------------------------------|------------|----------|--------|</span><br><span class="line">| 1    | Google    | https://goo.gl/Wp6XDs                                  | emily.ggrefer@gmail.com           |            |          |        |</span><br><span class="line">|      |           | https://goo.gl/ihocNf                                  | lgrefer78@gmail.com               |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Facebook  | https://goo.gl/MkCvdg                                  | fancyusc@gmail.com                |            | 6/21 end |        |</span><br><span class="line">|      |           | https://goo.gl/N9CjJA                                  | facebooksde@gmail.com             |            |          |        |</span><br><span class="line">|      |           | http://www.1point3acres.com/bbs/thread-429788-1-1.html | fbreferral.anyposition@gmail.com  |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Linkedin  | https://goo.gl/5ovfPo                                  |                                   |            |          |        |</span><br><span class="line">|      |           | https://goo.gl/jsafs7                                  | lkndreferral@gmail.com            |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Microsoft | https://goo.gl/q6AzJm                                  |                                   |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Amazon    | https://goo.gl/8jBf3T,                                 | infinity.730@outlook.com          |            |          |        |</span><br><span class="line">|      |           | https://goo.gl/Kga1fu                                  | referalamazon65@gmail.com         |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Apple     |                                                        |                                   |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | VMWare    | https://goo.gl/jD8siQ                                  |                                   |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Dropbox   | https://goo.gl/vw1cQW                                  | diuhezi@gmail.com                 |            |          | -      |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| Tier | company  | where found            | email                       | job search | freeze | remark |</span><br><span class="line">|------|----------|------------------------|-----------------------------|------------|--------|--------|</span><br><span class="line">| 2    | Paypal   | https://goo.gl/3X5odc  | paypal.refer.2018@gmail.com |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Adobe    | https://goo.gl/yAVixp  |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Airbnb   | https://goo.gl/z8k4st  | referralairbnb@gmail.com    |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Uber     |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Lyft     |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Docker   |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Whatsapp |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Netflix  |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Twitter  |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Snapchat |                        |                             |            |        | -      |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| Tier | company                       | where found                                            | email                       | job search                     | freeze | remark |</span><br><span class="line">|------|-------------------------------|--------------------------------------------------------|-----------------------------|--------------------------------|--------|--------|</span><br><span class="line">| 3    | Chase                         | https://goo.gl/ZEdmuV                                  | jpmc.referral815@gmail.com. | https://jobs.jpmorganchase.com |        |        |</span><br><span class="line">|      |                               |                                                        |                             |                                |        |        |</span><br><span class="line">|      | Upgrade Inc. series A funding | https://goo.gl/sGnrqF                                  | yrefer18@gmail.com          | https://jobs.lever.co/upgrade  |        | fitech |</span><br><span class="line">|      |                               |                                                        |                             |                                |        |        |</span><br><span class="line">|      | Morganstanley                 | http://www.1point3acres.com/bbs/thread-429994-1-1.html | morganrefer@gmail.com       |                                |        | -      |</span><br></pre></td></tr></table></figure></p><p>Lyft<br>Google</p><p>Apple<br>eBay<br>SAP<br>Oracle<br>Linkedin<br>cisco<br>snapchat</p><p>salesforce<br>2 sigma</p><p>zenefits<br>zulily<br>trip advisor<br>Nutanix<br>Zillow<br>yahoo(oath)<br>cloudra<br>Yelp<br>eBay<br>citadel<br>Rubrik<br>QUACOMM<br>squre<br>VMware</p><p>houzz<br>wepay<br>Akamia<br>Zillow<br>coursera<br>pocket gems</p><p>Quora<br>Pinterest<br>Wish<br>twillo</p><p>Arista<br>spotify<br>Stripe<br>Robinhood<br>Netflix<br>Slack<br>tasla<br>samsung<br>hulu<br>indeed<br>Priceline<br>OpenTable<br>looking glass<br>AppDyanmics(好像沒有ＮＥＷ＿ＧＲＡＤ)<br>box<br>citrix</p><p>go daddy<br>Nvidia<br>Palantir<br>SAP<br>3Ｍ<br>groupon<br>ＩＸＬ<br>intuit<br>Expedia<br>  <a href="https://goo.gl/u3h63v" target="_blank" rel="noopener">https://goo.gl/u3h63v</a>, <a href="mailto:expediarefer@gmail.com" target="_blank" rel="noopener">expediarefer@gmail.com</a></p><p>Chase<br>  <a href="https://goo.gl/fiYPPx" target="_blank" rel="noopener">https://goo.gl/fiYPPx</a> <a href="mailto:jpmc.referral815@gmail.com" target="_blank" rel="noopener">jpmc.referral815@gmail.com</a></p>]]></content>
      
      
        <tags>
            
            <tag> refer </tag>
            
            <tag> job </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LC24. Swap Nodes in Pairs</title>
      <link href="/2018/03/31/LC24-Swap-Nodes-in-Pairs/"/>
      <url>/2018/03/31/LC24-Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>  Given a linked list, swap every two adjacent nodes and return its head.</p><p>  For example,<br>  Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p><p>  Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode* newhead = <span class="keyword">new</span> ListNode(INT_MIN);</span><br><span class="line">        newhead-&gt;next = head;</span><br><span class="line">        ListNode* tmp = newhead;</span><br><span class="line">        </span><br><span class="line">        ListNode *one = <span class="literal">NULL</span>, *two = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next &amp;&amp; tmp-&gt;next-&gt;next)&#123;</span><br><span class="line">            one = tmp-&gt;next;</span><br><span class="line">            two = tmp-&gt;next-&gt;next;</span><br><span class="line">            </span><br><span class="line">            one-&gt;next = two-&gt;next;</span><br><span class="line">            two-&gt;next = one;</span><br><span class="line">            tmp-&gt;next = two;</span><br><span class="line">            tmp = one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11046/My-simple-JAVA-solution-for-share/11919" target="_blank" rel="noopener">https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11046/My-simple-JAVA-solution-for-share/11919</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> cycle detection </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LC142. Linked List Cycle II</title>
      <link href="/2018/03/30/LC142-Linked-List-Cycle-II/"/>
      <url>/2018/03/30/LC142-Linked-List-Cycle-II/</url>
      <content type="html"><![CDATA[<p>Reference:<br><a href="https://en.wikipedia.org/wiki/Cycle_detection" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cycle_detection</a><br><a href="https://leetcode.com/problems/linked-list-cycle-ii/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/solution/</a><br><a href="https://goo.gl/SpP3Yb" target="_blank" rel="noopener">https://goo.gl/SpP3Yb</a><br><a href="https://goo.gl/UNFB98" target="_blank" rel="noopener">https://goo.gl/UNFB98</a></p>]]></content>
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> cycle detection </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LC147. Insertion Sort List</title>
      <link href="/2018/03/29/LC147-Insertion-Sort-List/"/>
      <url>/2018/03/29/LC147-Insertion-Sort-List/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Sort a linked list using insertion sort.</p><p>Analysis:<br>The insertion sort of linked list can be done in O(1) space. In this solution, I create a node, result, to contain the result. The result would be look like the following graph.</p><pre><code>-init state-Original: 1 3 2 4 5result-&gt;null-first round-Original: 3 2 4 5result-&gt;1-&gt;NULL</code></pre><p>I use the next pointer to temporally save the position in the original list. The iter already move to the position in the result list that contains value higher than head-&gt;val. Then adjust the pointer in these item to direct head node to result list and move to next item in original list.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">insertionSortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">result</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            ListNode* iter = &amp;result;</span><br><span class="line">            <span class="keyword">while</span>(iter-&gt;next &amp;&amp; (iter-&gt;next-&gt;val &lt; head-&gt;val))&#123; </span><br><span class="line">                <span class="comment">//when result list gets long, use this to find proper position in result list.</span></span><br><span class="line">                iter = iter-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            head-&gt;next = iter-&gt;next;</span><br><span class="line">            iter-&gt;next = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://goo.gl/dzL3m1" target="_blank" rel="noopener">https://goo.gl/dzL3m1</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LC148.Sort List</title>
      <link href="/2018/03/28/LC148-Sort-List/"/>
      <url>/2018/03/28/LC148-Sort-List/</url>
      <content type="html"><![CDATA[<p>Sort a linked list in O(nlogn) time using constant space complexity.</p><p>When it comes to the algorithm that can sort in O(nlogn), it should be Merge sort, Quick sort, Heap sort. The difficult part in this question is the space complexity. If you choose recursive, the program stack will exceed the requirement and might lead to stack overflow. If you use Top-down merge sort, you will use another recursive in your program.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://goo.gl/xgNMT4</span></span><br><span class="line"><span class="comment"> * Merge sort use bottom-up policy, </span></span><br><span class="line"><span class="comment"> * so Space Complexity is O(1)</span></span><br><span class="line"><span class="comment"> * Time Complexity is O(NlgN)</span></span><br><span class="line"><span class="comment"> * stable sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!head || !(head-&gt;next)) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the linked list's length</span></span><br><span class="line">ListNode* cur = head;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cur)&#123;</span><br><span class="line">length++;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">dummy.next = head;</span><br><span class="line">ListNode *left, *right, *tail;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt; length; step &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">cur = dummy.next;</span><br><span class="line">tail = &amp;dummy;</span><br><span class="line"><span class="keyword">while</span>(cur)&#123;</span><br><span class="line">left = cur;</span><br><span class="line">right = split(left, step);</span><br><span class="line">cur = split(right,step);</span><br><span class="line">tail = merge(left, right, tail);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Divide the linked list into two lists,</span></span><br><span class="line"><span class="comment">     * while the first list contains first n ndoes</span></span><br><span class="line"><span class="comment"> * return the second list's head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//if(!head) return NULL;</span></span><br><span class="line">        <span class="comment">//1. point to the position that want to spilt</span></span><br><span class="line">        <span class="comment">//2. separate two linked list, which are from start-&gt;head, second</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; head &amp;&amp; i &lt; n; i++) head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">ListNode *second = head-&gt;next; </span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>; <span class="comment">//end the list</span></span><br><span class="line"><span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * merge the two sorted linked list l1 and l2,</span></span><br><span class="line"><span class="comment">  * then append the merged sorted linked list to the node head</span></span><br><span class="line"><span class="comment">  * return the tail of the merged sorted linked list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2, ListNode* head)</span></span>&#123;</span><br><span class="line">ListNode *cur = head;</span><br><span class="line"><span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line"><span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">cur-&gt;next = l2;</span><br><span class="line">cur = l2;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cur-&gt;next = l1;</span><br><span class="line">cur = l1;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur-&gt;next = (l1 ? l1 : l2);</span><br><span class="line"><span class="keyword">while</span>(cur-&gt;next) cur = cur-&gt;next;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://goo.gl/xgNMT4" target="_blank" rel="noopener">https://goo.gl/xgNMT4</a><br><a href="https://goo.gl/zgWtLT" target="_blank" rel="noopener">https://goo.gl/zgWtLT</a><br><a href="https://goo.gl/JY6o7o" target="_blank" rel="noopener">https://goo.gl/JY6o7o</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> merge sort </tag>
            
            <tag> space complexity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Space complexity between recursion and iterative</title>
      <link href="/2018/03/28/Space%20complexity/"/>
      <url>/2018/03/28/Space%20complexity/</url>
      <content type="html"><![CDATA[<p>Basically, a recursive algorithm will add overhead since you store recursive calls in the execution stack.</p><p>But if the recursive function is  <strong>the last line of the call (tail recursion)</strong> then there is no additional penalty.</p><p>That is of course both algorithms are the same.</p><p><strong><em>Space complexity in Merge-sort</em></strong></p><p>Reference:<br><a href="https://www.codeproject.com/Articles/21194/Iterative-vs-Recursive-Approaches" target="_blank" rel="noopener">https://www.codeproject.com/Articles/21194/Iterative-vs-Recursive-Approaches</a><br><a href="https://stackoverflow.com/questions/10821059/space-complexity-of-recursive-algorithm" target="_blank" rel="noopener">https://stackoverflow.com/questions/10821059/space-complexity-of-recursive-algorithm</a><br><a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Tail_call</a><br><a href="https://goo.gl/JY6o7o" target="_blank" rel="noopener">https://goo.gl/JY6o7o</a></p>]]></content>
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>How to setup a webpage</title>
      <link href="/2018/03/25/how%20to%20setup%20webpage/"/>
      <url>/2018/03/25/how%20to%20setup%20webpage/</url>
      <content type="html"><![CDATA[<p>It’s not that familiar for me, who basically use c++ and python, to setup a website. So I checked some options, and decided to use Hexo.<br>Setting up website through Hexo is pretty simple, which I believe can be done in half an hour. Let’s begin.</p><p>My Environment:<br>Mac Sierra: 10.12.6<br>NodeJS: v8.10.0<br>Git: git version 2.10.1 (Apple Git-78)</p><h2 id="Download-package"><a href="#Download-package" class="headerlink" title="Download package"></a>Download package</h2><p>First of all, the Hexo is based on two packages, NodeJS and Git. For those who don’t have/don’t know if you have these two packages, you can use the following commands on your terminal to check.</p><p>I follow the original steps of these installations. </p><h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure><p>if you don’t have NodeJS installed on you machine, you can go download it through this site.<br><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git version</span><br></pre></td></tr></table></figure><p>if you don’t have Git installed on you machine, you can go download it through this site.<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><h3 id="Hexo-Installation"><a href="#Hexo-Installation" class="headerlink" title="Hexo Installation"></a>Hexo Installation</h3><p>To install hexo, we need to use node project manager to download it. I had permission error, so I use sudo to fix it. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="Create-webpage"><a href="#Create-webpage" class="headerlink" title="Create webpage"></a>Create webpage</h2><h3 id="Create-new-project"><a href="#Create-new-project" class="headerlink" title="Create new project"></a>Create new project</h3><p>After successfully install hexo, you should be able to create your own project. Here, I use “hexo_tmp” as the project name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo_tmp</span><br></pre></td></tr></table></figure><h3 id="Create-new-web-page"><a href="#Create-new-web-page" class="headerlink" title="Create new web page"></a>Create new web page</h3><p>Check the source_posts folder, add a markdown file, and you’re good to go.</p><h2 id="Publish-the-webpage-on-github"><a href="#Publish-the-webpage-on-github" class="headerlink" title="Publish the webpage on github"></a>Publish the webpage on github</h2><p>Each github account can publish a webpage use github pages. The following steps would help you setup the webpage on github. </p><ol><li>Create github repository</li><li>Change configuration in hexo</li><li>Public the data to github</li></ol><h3 id="Create-github-repository"><a href="#Create-github-repository" class="headerlink" title="Create github repository"></a>Create github repository</h3><p>Login to you github and create a new repository like this. Notice that each account only have one free github page, and the name is restricted to “username.github.io”<br>The following picture is screenshot after I created the blog, so you should be okay to create a repository like this.</p><p><img src="github1.png" alt=""></p><h3 id="Change-configuration-in-hexo"><a href="#Change-configuration-in-hexo" class="headerlink" title="Change configuration in hexo"></a>Change configuration in hexo</h3><p>The most frequently used file in hexo should be “hexofolder/_config.yml”<br>You should be able to find these two parts of code in your _config.yml. Change the “username” to your account name.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: https://username.github.io</span><br><span class="line">#root:</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/username/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="Public-the-data-to-github"><a href="#Public-the-data-to-github" class="headerlink" title="Public the data to github"></a>Public the data to github</h3><p>Finish above steps, you are on step to publish you website. Type the following command and you can see your website on <a href="https://username.github.io" target="_blank" rel="noopener">https://username.github.io</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> tutorial </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
