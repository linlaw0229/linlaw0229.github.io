<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>157. Read N Characters Given Read4</title>
      <link href="/2018/09/03/157-Read-N-Characters-Given-Read4/"/>
      <url>/2018/09/03/157-Read-N-Characters-Given-Read4/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>The API: int read4(char *buf) reads 4 characters at a time from a file.</p><p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p><p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: buf = &quot;abc&quot;, n = 4</span><br><span class="line">Output: &quot;abc&quot;</span><br><span class="line">Explanation: The actual number of characters read is 3, which is &quot;abc&quot;.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: buf = &quot;abcde&quot;, n = 5 </span><br><span class="line">Output: &quot;abcde&quot;</span><br></pre></td></tr></table></figure></p><p>Note:<br>The read function will only be called once for each test case.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question to ask:</p><ol><li>read4 can be use multiple times?</li><li>output type</li></ol><p>One thing to notice is that the <code>read</code> will only be called once. The <code>read4</code> will return how many characters it read from the input <code>char *buf</code>. So we can use a variable to cumulate the sum of characters that read by <code>read4</code>. Once the return value of <code>read4</code> is smaller than 4, that means we reached the last position. </p><p>Make sure to move the position in <code>char *buf</code> for <code>read4</code> to read next position.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the read4 API.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read4</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Maximum number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> complete= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = min(read4(buf), n);</span><br><span class="line">            complete+= tmp;</span><br><span class="line">            buf+= tmp; <span class="comment">//move the char pointer to next position</span></span><br><span class="line">            <span class="keyword">if</span>(tmp&lt; <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            n-= <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> complete;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>129. Sum Root to Leaf Numbers</title>
      <link href="/2018/09/02/129-Sum-Root-to-Leaf-Numbers/"/>
      <url>/2018/09/02/129-Sum-Root-to-Leaf-Numbers/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p><p>Find the total sum of all root-to-leaf numbers.</p><p>Note: A leaf is a node with no children.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum = 12 + 13 = 25.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>A simple DFS solution, use an integer to store the current sum. For every node, update the val as val*10 plus node’s data.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;right &amp;&amp; !root-&gt;left)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span> * x + root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">            val += helper(root-&gt;left, <span class="number">10</span> * x + root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">            val += helper(root-&gt;right, <span class="number">10</span> * x + root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: $O(n)$<br>space complexity: $O(logn)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>30. Substring with Concatenation of All Words</title>
      <link href="/2018/09/01/30-Substring-with-Concatenation-of-All-Words/"/>
      <url>/2018/09/01/30-Substring-with-Concatenation-of-All-Words/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">Output: [0,9]</span><br><span class="line">Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.</span><br><span class="line">The output order does not matter, returning [9,0] is fine too.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;wordgoodstudentgoodword&quot;,</span><br><span class="line">  words = [&quot;word&quot;,&quot;student&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two hash table. </p><ol><li>First hash table, <code>map</code>, stores every words.</li><li>Second hash table, <code>seen</code>, determine if a substring is in the <code>map</code> or not. If the substring is not in the map, it means the substring is not a word in given words. In addition, it can only appear once in current search, so if the count in <code>seen</code> is greater than in the <code>map</code>, we should break the loop.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(s.empty() || words.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word: words)</span><br><span class="line">            <span class="built_in">map</span>[word]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n= s.length(), num= words.size(), len= words[<span class="number">0</span>].length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n- num*len+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; seen;</span><br><span class="line">            <span class="keyword">int</span> j= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j&lt; num; j++)&#123;</span><br><span class="line">                <span class="built_in">string</span> word= s.substr(i+j*len, len);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>.find(word) != <span class="built_in">map</span>.end())&#123;</span><br><span class="line">                    seen[word]++;</span><br><span class="line">                    <span class="keyword">if</span>(seen[word]&gt; <span class="built_in">map</span>[word])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == num) res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n*num)$<br>space complexity: $O(words.size())$<br>reference:<br><a href="https://goo.gl/wy6wAq" target="_blank" rel="noopener">https://goo.gl/wy6wAq</a><br><a href="https://goo.gl/MAkUfJ" target="_blank" rel="noopener">https://goo.gl/MAkUfJ</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> hash table </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>23. Merge k Sorted Lists</title>
      <link href="/2018/09/01/23-Merge-k-Sorted-Lists/"/>
      <url>/2018/09/01/23-Merge-k-Sorted-Lists/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure></p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>Use the concept of merge two list. Divide the <code>n</code> lists into <code>n/2</code> parts and merge every 2 lists until only one list left.<br>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">totally 10 lists</span><br><span class="line">  1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">merge i and i+k together, which k= (n+1)/2</span><br><span class="line"></span><br><span class="line">merge(1,6) merge(2,7), merge(3,8), merge(4,9), merge(5,10)</span><br><span class="line"></span><br><span class="line">merge(1,4), merge(2,5), 3</span><br><span class="line"></span><br><span class="line">merge(1,3), 2</span><br><span class="line"></span><br><span class="line">merge(1,2)</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//divide lists into half, merge every two list together until only one left</span></span><br><span class="line">        <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n= lists.size();</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k= (n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; n/<span class="number">2</span>; i++)&#123;</span><br><span class="line">                lists[i]= mergeList(lists[i], lists[i+k]);</span><br><span class="line">            &#125;</span><br><span class="line">            n= k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* head= <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur= head;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next= l1;</span><br><span class="line">                l1= l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next= l2;</span><br><span class="line">                l2= l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur= cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1)</span><br><span class="line">            cur-&gt;next= l1;</span><br><span class="line">        <span class="keyword">if</span>(l2)</span><br><span class="line">            cur-&gt;next= l2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nklog(k))$, n: average length of lists, there are k lists.<br>firstly, merge every two list need nk/2; in the next round, the length of list becomes 2n, the number of lists becomes k/2, so the complexity is still nk/2. Keep such rounds until k == 1, that would be log(k) rounds. so the total complexity is $O(nklog(k))$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/wUqWfW" target="_blank" rel="noopener">https://goo.gl/wUqWfW</a></p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2:"></a>Solution 2:</h3><p>Use a priority_queue to implement. Put every head of the list into the priority_queue, it will sort the value automatically. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, comp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; lists.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i]) q.push(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* head= <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur= head, *tmp= <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            tmp= q.top(); <span class="comment">//it's the smallest element right now</span></span><br><span class="line">            q.pop();</span><br><span class="line">            cur-&gt;next= tmp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;next) q.push(tmp-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogk)$, n: average length of lists, there are k lists. The height of the priority_queue would be $logk$.<br>space complexity: $O(logk)$<br>reference:<br><a href="https://goo.gl/nM8sHt" target="_blank" rel="noopener">https://goo.gl/nM8sHt</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> linked list </tag>
            
            <tag> heap </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>399. Evaluate Division</title>
      <link href="/2018/09/01/399-Evaluate-Division/"/>
      <url>/2018/09/01/399-Evaluate-Division/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given a / b = 2.0, b / c = 3.0. </span><br><span class="line">queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . </span><br><span class="line">return [6.0, 0.5, -1.0, 1.0, -1.0 ].</span><br></pre></td></tr></table></figure></p><p>The input is: vector&lt;pair&lt;string, string&gt;&gt; equations, vector<double>&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector<double>.</double></double></p><p>According to the example above:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],</span><br><span class="line">values = [2.0, 3.0],</span><br><span class="line">queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].</span><br></pre></td></tr></table></figure></p><p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Think every character as a node, the equation result would be the weight between them. In addition, if we have a equation from a to b, then we can also get b to a.<br>ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if we know</span><br><span class="line"> a-&gt;b, weight= 2.0</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"> b-&gt;a, would be (1/2.0)= 0.5</span><br><span class="line"> a-&gt;a, would be 1</span><br><span class="line"> b-&gt;b, 1</span><br></pre></td></tr></table></figure></p><p>After we generate the graph, we can use BFS to scan the graph. Use an unordered_set to store every node that already visited.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; calcEquation(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; g; <span class="comment">//vertex, &lt;vertex, weight&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; equations.size(); i++)&#123;</span><br><span class="line">            </span><br><span class="line">            g[equations[i].first].emplace(equations[i].second, values[i]); <span class="comment">//from A-&gt;B, weight value[i]</span></span><br><span class="line">            g[equations[i].first].emplace(equations[i].first, <span class="number">1.0</span>); <span class="comment">//from A-&gt;A, weight 1</span></span><br><span class="line">            g[equations[i].second].emplace(equations[i].first, <span class="number">1.0</span>/values[i]); <span class="comment">//from B-&gt;A, weight (1.0/value[i])</span></span><br><span class="line">            g[equations[i].second].emplace(equations[i].second, <span class="number">1.0</span>); <span class="comment">//from B-&gt;B, weight 1</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            //use insert will be generate extra template element</span></span><br><span class="line"><span class="comment">            g[equations[i].first].insert(make_pair(equations[i].second, values[i])); //from A-&gt;B, weight value[i]</span></span><br><span class="line"><span class="comment">            g[equations[i].first].insert(make_pair(equations[i].first, 1.0)); //from A-&gt;A, weight 1</span></span><br><span class="line"><span class="comment">            g[equations[i].second].insert(make_pair(equations[i].first, 1.0/values[i])); //from B-&gt;A, weight (1.0/value[i])</span></span><br><span class="line"><span class="comment">            g[equations[i].second].insert(make_pair(equations[i].second, 1.0)); //from B-&gt;B, weight 1</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> query: queries)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!g.count(query.first) || !g.count(query.second)) res.push_back(<span class="number">-1.0</span>); <span class="comment">//can not find one of the vertex, return -1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; q;</span><br><span class="line">                <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; used&#123;query.first&#125;;</span><br><span class="line">                <span class="keyword">bool</span> find= <span class="literal">false</span>;</span><br><span class="line">                q.push(&#123;query.first, <span class="number">1.0</span>&#125;);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(!q.empty() &amp;&amp; !find)&#123;</span><br><span class="line">                    <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; next;</span><br><span class="line">                    <span class="keyword">while</span>(!q.empty() &amp;&amp; !find)&#123;</span><br><span class="line">                        pair&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; t= q.front(); q.pop();</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;"tmp: "&lt;&lt;t.first&lt;&lt;": "&lt;&lt;t.second&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(t.first == query.second)&#123;</span><br><span class="line">                            find = <span class="literal">true</span>;</span><br><span class="line">                            <span class="comment">//cout&lt;&lt;" res: "&lt;&lt; t.first&lt;&lt; ": "&lt;&lt;t.second&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">                            res.push_back(t.second);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor: g[t.first])&#123; <span class="comment">//call by value, so does not affect original neighbor list</span></span><br><span class="line">                            <span class="keyword">if</span>(!used.count(neighbor.first))&#123; </span><br><span class="line">                                <span class="comment">//cout&lt;&lt;t.first&lt;&lt; "-&gt;" &lt;&lt; neighbor.first&lt;&lt; ": "&lt;&lt;neighbor.second&lt;&lt; endl;</span></span><br><span class="line">                                neighbor.second *= t.second; </span><br><span class="line">                                <span class="comment">//cout&lt;&lt;" "&lt;&lt;t.first&lt;&lt; "-&gt;" &lt;&lt; neighbor.first&lt;&lt; ": "&lt;&lt;neighbor.second&lt;&lt; endl;</span></span><br><span class="line">                                next.push(neighbor);</span><br><span class="line">                                used.insert(neighbor.first);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q= next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!find) res.push_back(<span class="number">-1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(N+E)$, N: number of variables, E: number of equations.<br>building the graph takes O(E), each query takes O(N)<br>space complexity: $O(E)$<br>reference:<br><a href="https://goo.gl/XWzasp" target="_blank" rel="noopener">https://goo.gl/XWzasp</a><br><a href="https://goo.gl/C4au3C" target="_blank" rel="noopener">https://goo.gl/C4au3C</a><br><a href="https://goo.gl/Hcce9D" target="_blank" rel="noopener">https://goo.gl/Hcce9D</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>491. Increasing Subsequences</title>
      <link href="/2018/08/31/491-Increasing-Subsequences/"/>
      <url>/2018/08/31/491-Increasing-Subsequences/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4, 6, 7, 7]</span><br><span class="line">Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure></p><p>Note:<br>The length of the given array will not exceed 15.<br>The range of integer in the given array is [-100,100].<br>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We can use dfs template to solve this question.<br>The tricky part is to use an unordered_set to store the numbers that already in current layer to avoid duplicate elements.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSubsequences(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(res, nums, tmp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size() &gt;= <span class="number">2</span>) res.push_back(tmp);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; dict;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= index; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tmp.empty() &amp;&amp; tmp.back()&gt; nums[i] || dict.count(nums[i])) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            dict.insert(nums[i]);</span><br><span class="line">            dfs(res, nums, tmp, i+<span class="number">1</span>);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(2^n))$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/wp2sbS" target="_blank" rel="noopener">https://goo.gl/wp2sbS</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>636. Exclusive Time of Functions</title>
      <link href="/2018/08/31/636-Exclusive-Time-of-Functions/"/>
      <url>/2018/08/31/636-Exclusive-Time-of-Functions/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.</p><p>Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.</p><p>A log is a string has this format : function_id:start_or_end:timestamp. For example, “0:start:0” means function 0 starts from the very beginning of time 0. “0:end:0” means function 0 ends to the very end of time 0.</p><p>Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function’s exclusive time. You should return the exclusive time of each function sorted by their function id.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">n = 2</span><br><span class="line">logs = </span><br><span class="line">[&quot;0:start:0&quot;,</span><br><span class="line"> &quot;1:start:2&quot;,</span><br><span class="line"> &quot;1:end:5&quot;,</span><br><span class="line"> &quot;0:end:6&quot;]</span><br><span class="line">Output:[3, 4]</span><br><span class="line">Explanation:</span><br><span class="line">Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. </span><br><span class="line">Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.</span><br><span class="line">Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. </span><br><span class="line">So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.</span><br></pre></td></tr></table></figure></p><p>Note:</p><ol><li>Input logs will be sorted by timestamp, NOT log id.</li><li>Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.</li><li>Two functions won’t start or end at the same time.</li><li>Functions could be called recursively, and will always end.</li><li>1 &lt;= n &lt;= 100</li></ol><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The exclusive time of function means how many times that CPU spent on this function.<br>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[&quot;A:start:0&quot;,&quot;A:start:2&quot;,&quot;A:end:5&quot;,&quot;B:start:7&quot;,&quot;B:end:7&quot;,&quot;A:end:8&quot;]</span><br><span class="line"></span><br><span class="line">   time 0</span><br><span class="line">        |---|---|---|---|---|---|---|---|---|---|---|---|</span><br><span class="line">process A------&gt;             -------   &gt;A</span><br><span class="line">                A----------&gt;A           </span><br><span class="line">                                    B--&gt;B</span><br><span class="line">       start   start       end   start  end</span><br><span class="line"></span><br><span class="line">The answer would be [8,1], A has exclusive 8 slots, B has exclusive 1 slot.</span><br></pre></td></tr></table></figure></p><p>With this example, we can know that if a function hasn’t end, we need to keep it until it ends. So we can use a <code>stack</code> to store the functions. The stack only needs to store the index of each function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; exclusiveTime(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; logs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> preTime= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="built_in">log</span>: logs)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//extract information from log, which function, start or end, happened time</span></span><br><span class="line">            <span class="keyword">int</span> found1= <span class="built_in">log</span>.find(<span class="string">":"</span>); <span class="comment">//get index of function</span></span><br><span class="line">            <span class="keyword">int</span> found2= <span class="built_in">log</span>.find_last_of(<span class="string">":"</span>); <span class="comment">//time frame</span></span><br><span class="line">            <span class="keyword">int</span> idx= stoi(<span class="built_in">log</span>.substr(<span class="number">0</span>, found1));</span><br><span class="line">            <span class="built_in">string</span> type= <span class="built_in">log</span>.substr(found1+<span class="number">1</span>, found2-found1<span class="number">-1</span>); <span class="comment">//"start" or "end"</span></span><br><span class="line">            <span class="keyword">int</span> time = stoi(<span class="built_in">log</span>.substr(found2+<span class="number">1</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!stk.empty())&#123;</span><br><span class="line">                res[stk.top()]+= time-preTime;</span><br><span class="line">            &#125;</span><br><span class="line">            preTime = time;</span><br><span class="line">            <span class="keyword">if</span>(type == <span class="string">"start"</span>) stk.push(idx);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp= stk.top(); stk.pop();</span><br><span class="line">                ++res[tmp];</span><br><span class="line">                ++preTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/63GMUn" target="_blank" rel="noopener">https://goo.gl/63GMUn</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> uber </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>429. N-ary Tree Level Order Traversal</title>
      <link href="/2018/08/31/429-N-ary-Tree-Level-Order-Traversal/"/>
      <url>/2018/08/31/429-N-ary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an n-ary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example, given a 3-ary tree:</p><p><img src="NaryTreeExample.png" alt=""></p><p>We should return its level order traversal:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">     [3,2,4],</span><br><span class="line">     [5,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>The depth of the tree is at most 1000.<br>The total number of nodes is at most 5000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val = NULL;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(Node* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="comment">//BFS traversal</span></span><br><span class="line">            <span class="keyword">int</span> size= q.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; size; i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp= q.front(); q.pop();</span><br><span class="line">                level.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> n: tmp-&gt;children)</span><br><span class="line">                    q.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>251. Flatten 2D Vector</title>
      <link href="/2018/08/30/251-Flatten-2D-Vector/"/>
      <url>/2018/08/30/251-Flatten-2D-Vector/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Implement an iterator to flatten a 2d vector.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 2d vector =</span><br><span class="line">[</span><br><span class="line">  [1,2],</span><br><span class="line">  [3],</span><br><span class="line">  [4,5,6]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,5,6]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, </span><br><span class="line">             the order of elements returned by next should be: [1,2,3,4,5,6].</span><br></pre></td></tr></table></figure></p><p>Follow up:<br>As an added challenge, try to code it using only iterators in C++ or iterators in Java.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two iterator to denote the begin and end of the row of 2D vector. Another integer variable for the current position in the vector column.</p><p>Another thing to notice is that we need to use (*cur) to get the value in the vector.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         pos</span><br><span class="line">       [ |</span><br><span class="line">cur -&gt;  [1,2],</span><br><span class="line">        [3],</span><br><span class="line">        [4,5,6]</span><br><span class="line">end -&gt; ]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector2D(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; vec2d) &#123;</span><br><span class="line">        cur= vec2d.begin();</span><br><span class="line">        end= vec2d.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*cur)[pos++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != end &amp;&amp; pos == (*cur).size())&#123;</span><br><span class="line">            cur++;</span><br><span class="line">            pos= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur != end; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator cur, end;</span><br><span class="line">    <span class="keyword">int</span> pos= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Vector2D object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Vector2D i(vec2d);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/HAhXuq" target="_blank" rel="noopener">https://goo.gl/HAhXuq</a><br><a href="https://goo.gl/cJtZ2Y" target="_blank" rel="noopener">https://goo.gl/cJtZ2Y</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
            <tag> airbnb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>281. Zigzag Iterator</title>
      <link href="/2018/08/30/281-Zigzag-Iterator/"/>
      <url>/2018/08/30/281-Zigzag-Iterator/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two 1d vectors, implement an iterator to return their elements alternately.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">v1 = [1,2]</span><br><span class="line">v2 = [3,4,5,6] </span><br><span class="line"></span><br><span class="line">Output: [1,3,2,4,5,6]</span><br></pre></td></tr></table></figure></p><p>Explanation: By calling next repeatedly until hasNext returns false,<br>             the order of elements returned by next should be: [1,3,2,4,5,6].<br>Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?</p><p>Clarification for the follow up question:<br>The “Zigzag” order is not clearly defined and is ambiguous for k &gt; 2 cases. If “Zigzag” does not look right to you, replace “Zigzag” with “Cyclic”. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line">[4,5,6,7]</span><br><span class="line">[8,9]</span><br><span class="line"></span><br><span class="line">Output: [1,4,8,2,5,9,3,6,7].</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea of this problem is to use a queue to store the current iterator of each vector. At start, we need to store the <code>begin</code> and <code>end</code> iterator of each vector. Every time we need to output a value, we take the <code>pair&lt;begin, end&gt;</code> from the queue. After we get the <code>pair</code>, we can use the <code>begin</code> iterator to find next element in that vector.</p><ol><li>Use a queue to store iterators of each vector, push pairs of iterators with the zigzag order.</li><li>Take the front element of the queue, pop it out. If we add 1 to the begin iterator, then we can get to the next element in the vector. However, if the begin iterator is equal to the end iterator, that means we reach to the end. And we don’t need to push the pair in to queue again.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZigzagIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZigzagIterator(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!v1.empty()) q.push(make_pair(v1.begin(), v1.end()));</span><br><span class="line">        <span class="keyword">if</span>(!v2.empty()) q.push(make_pair(v2.begin(), v2.end()));</span><br><span class="line">        <span class="comment">//if there're multiple vectors, then push it into the queue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it= q.front().first, end= q.front().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(it+<span class="number">1</span> != end) q.push(make_pair(it+<span class="number">1</span>, end));</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !q.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt;&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ZigzagIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ZigzagIterator i(v1, v2);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>825. Friends Of Appropriate Ages</title>
      <link href="/2018/08/29/825-Friends-Of-Appropriate-Ages/"/>
      <url>/2018/08/29/825-Friends-Of-Appropriate-Ages/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. </p><p>Person A will NOT friend request person B (B != A) if any of the following conditions are true:</p><p>age[B] &lt;= 0.5 * age[A] + 7<br>age[B] &gt; age[A]<br>age[B] &gt; 100 &amp;&amp; age[A] &lt; 100<br>Otherwise, A will friend request B.</p><p>Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.</p><p>How many total friend requests are made?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [16,16]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 2 people friend request each other.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [16,17,18]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [20,30,100,110,120]</span><br><span class="line">Output: </span><br><span class="line">Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.</span><br></pre></td></tr></table></figure></p><p>Notes:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= ages.length &lt;= 20000.</span><br><span class="line">1 &lt;= ages[i] &lt;= 120.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a map to gather all the same ages together, then use a function to check whether if the input ages will send request.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numFriendRequests</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a: ages)</span><br><span class="line">            count[a]++; <span class="comment">//calculate the same ages together</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: count)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> y: count)&#123;</span><br><span class="line">                <span class="keyword">if</span>(request(x.first, y.first))</span><br><span class="line">                    res += x.second * (y.second - (x.first == y.first ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">request</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(b &lt;= <span class="number">0.5</span> * a + <span class="number">7</span> || b &gt; a || (b &gt; <span class="number">100</span> &amp;&amp; a &lt; <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^2)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/XQgtCY" target="_blank" rel="noopener">https://goo.gl/XQgtCY</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>311. Sparse Matrix Multiplication</title>
      <link href="/2018/08/29/311-Sparse-Matrix-Multiplication/"/>
      <url>/2018/08/29/311-Sparse-Matrix-Multiplication/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two sparse matrices A and B, return the result of AB.</p><p>You may assume that A’s column number is equal to B’s row number.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">A = [</span><br><span class="line">  [ 1, 0, 0],</span><br><span class="line">  [-1, 0, 3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">B = [</span><br><span class="line">  [ 7, 0, 0 ],</span><br><span class="line">  [ 0, 0, 0 ],</span><br><span class="line">  [ 0, 0, 1 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |</span><br><span class="line">AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |</span><br><span class="line">                  | 0 0 1 |</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Matrix multiply: </p><ul><li>A[i][k]* B[k][j]= C[i][j]</li><li>C[i][j]= A[i][0]<em>B[0][j]+ A[i][1]</em>B[1][j]+ … +A[i][k]*B[k][j]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; multiply(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(A.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(B[<span class="number">0</span>].size(), <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; A.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k= <span class="number">0</span>; k&lt; A[<span class="number">0</span>].size(); k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][k] != <span class="number">0</span>)&#123; <span class="comment">//it's sparse matrix, this can reduce redundant calculation</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; B[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(B[k][j] != <span class="number">0</span>) res[i][j]+= A[i][k]* B[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(AB)$, $A: A.size()*A[0].size(), B: B.size()*B[0].size()$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/yDQCx2" target="_blank" rel="noopener">https://goo.gl/yDQCx2</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>819. Most Common Word</title>
      <link href="/2018/08/29/819-Most-Common-Word/"/>
      <url>/2018/08/29/819-Most-Common-Word/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn’t banned, and that the answer is unique.</p><p>Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: </span><br><span class="line">paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;</span><br><span class="line">banned = [&quot;hit&quot;]</span><br><span class="line">Output: &quot;ball&quot;</span><br><span class="line">Explanation: </span><br><span class="line">&quot;hit&quot; occurs 3 times, but it is a banned word.</span><br><span class="line">&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. </span><br><span class="line">Note that words in the paragraph are not case sensitive,</span><br><span class="line">that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;), </span><br><span class="line">and that &quot;hit&quot; isn&apos;t the answer even though it occurs more because it is banned.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>1 &lt;= paragraph.length &lt;= 1000.<br>1 &lt;= banned.length &lt;= 100.<br>1 &lt;= banned[i].length &lt;= 10.<br>The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.)<br>paragraph only consists of letters, spaces, or the punctuation symbols !?’,;.<br>Different words in paragraph are always separated by a space.<br>There are no hyphens or hyphenated words.<br>Words only consist of letters, never apostrophes or other punctuation symbols.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a unordered_set to store the banned strings, so that we can have <code>O(1)</code> on searching.<br>Since the <code>paragraph</code> would contain upper case letter and symbols, we need to</p><ul><li>convert every character to lower case</li><li>remove every symbols and use <code>&#39; &#39;</code> instead.</li></ul><p>For string handling, we can use <code>stringstream</code>, because it can spilt words by whitespaces.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mostCommonWord</span><span class="params">(<span class="built_in">string</span> paragraph, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; banned)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(banned.begin(), banned.end());</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c: paragraph)</span><br><span class="line">            c= <span class="built_in">isalpha</span>(c)? <span class="built_in">tolower</span>(c): <span class="string">' '</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(paragraph)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; res&#123;<span class="string">""</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(is&gt;&gt; tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dict.find(tmp) == dict.end() &amp;&amp; ++count[tmp] &gt; res.second)&#123;</span><br><span class="line">                res= make_pair(tmp, count[tmp]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/tzoaYC" target="_blank" rel="noopener">https://goo.gl/tzoaYC</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> easy </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>4. Median of Two Sorted Arrays</title>
      <link href="/2018/08/28/4-Median-of-Two-Sorted-Arrays/"/>
      <url>/2018/08/28/4-Median-of-Two-Sorted-Arrays/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><p>Example 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>The median is 2.0<br>Example 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>The median is (2 + 3)/2 = 2.5</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>If the total number of elements are odd, then what we have to do is to find the <code>K</code>th number of element.<br>If the total number of elements are even, then what we have to do is to find the <code>K</code>th and <code>K+1</code> number of element, then divided it to half to get the median.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = nums1.size()+ nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(total %<span class="number">2</span> == <span class="number">1</span>) <span class="comment">//the array have odd number of elements, can find a middle one</span></span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total/<span class="number">2</span> +<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//can not find a middle one, so need to find two numbers and divide by 2</span></span><br><span class="line">            <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total/<span class="number">2</span>)+ findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total/<span class="number">2</span> +<span class="number">1</span>))/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.size()- i &gt; nums2.size()- j) <span class="keyword">return</span> findKth(nums2, j, nums1, i, k);</span><br><span class="line">        <span class="keyword">if</span>(nums1.size() == i) <span class="keyword">return</span> nums2[j+k<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[i], nums2[j]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pa= min(i+k/<span class="number">2</span>, <span class="keyword">int</span>(nums1.size()) );</span><br><span class="line">        <span class="keyword">int</span> pb= j+k-pa+i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums1[pa<span class="number">-1</span>] &lt; nums2[pb<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, pa, nums2, j, k-pa+i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[pa<span class="number">-1</span>]&gt; nums2[pb<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, i, nums2, pb, k-pb+j);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> nums1[pa<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
            <tag> binary search </tag>
            
            <tag> divide and conquer </tag>
            
            <tag> adobe facebook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>721. Accounts Merge</title>
      <link href="/2018/08/27/721-Accounts-Merge/"/>
      <url>/2018/08/27/721-Accounts-Merge/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.</p><p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p><p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">Output: [[&quot;John&quot;, &apos;john00@mail.com&apos;, &apos;john_newyork@mail.com&apos;, &apos;johnsmith@mail.com&apos;],  [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">Explanation: </span><br><span class="line">The first and third John&apos;s are the same person as they have the common email &quot;johnsmith@mail.com&quot;.</span><br><span class="line">The second John and Mary are different people as none of their email addresses are used by other accounts.</span><br><span class="line">We could return these lists in any order, for example the answer [[&apos;Mary&apos;, &apos;mary@mail.com&apos;], [&apos;John&apos;, &apos;johnnybravo@mail.com&apos;], </span><br><span class="line">[&apos;John&apos;, &apos;john00@mail.com&apos;, &apos;john_newyork@mail.com&apos;, &apos;johnsmith@mail.com&apos;]] would still be accepted.</span><br></pre></td></tr></table></figure></p><p>Note:<br>The length of accounts will be in the range [1, 1000].<br>The length of accounts[i] will be in the range [1, 10].<br>The length of accounts[i][j] will be in the range [1, 30].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Union find: make every node it’s root. traverse all connection and make it in a union.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; root; <span class="comment">//"john00@mail.com", "johnsmith@mail.com", </span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; owner; <span class="comment">//email, Name. ex: "johnsmith@mail.com", "John"</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> account: accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; account.size(); i++)&#123;</span><br><span class="line">                root[account[i]]= account[i];  <span class="comment">//let every email in different group "johnsmith@mail.com", "johnsmith@mail.com".</span></span><br><span class="line">                owner[account[i]]= account[<span class="number">0</span>]; <span class="comment">//every account[i] owners is the first one</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> account: accounts)&#123;</span><br><span class="line">            <span class="built_in">string</span> p= find(account[<span class="number">1</span>], root);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">2</span>; i&lt; account.size(); i++)&#123;</span><br><span class="line">                root[find(account[i], root)]= p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> account: accounts)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; account.size(); i++)&#123;</span><br><span class="line">                m[find(account[i], root)].insert(account[i]); <span class="comment">//put into same set</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : m) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v(a.second.begin(), a.second.end());</span><br><span class="line">            v.insert(v.begin(), owner[a.first]);</span><br><span class="line">            res.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&amp; root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// to check if s is in the same root group </span></span><br><span class="line">        <span class="keyword">return</span> root[s]== s? s: find(root[s], root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>13. Roman to Integer</title>
      <link href="/2018/08/27/13-Roman-to-Integer/"/>
      <url>/2018/08/27/13-Roman-to-Integer/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: C = 100, L = 50, XXX = 30 and III = 3.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; T = &#123; &#123; <span class="string">'I'</span> , <span class="number">1</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'V'</span> , <span class="number">5</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'X'</span> , <span class="number">10</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'L'</span> , <span class="number">50</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'C'</span> , <span class="number">100</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'D'</span> , <span class="number">500</span> &#125;,</span><br><span class="line">                                   &#123; <span class="string">'M'</span> , <span class="number">1000</span> &#125; &#125;;</span><br><span class="line">                                   </span><br><span class="line">        <span class="keyword">int</span> sum = T[s.back()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T[s[i]] &lt; T[s[i + <span class="number">1</span>]])&#123;</span><br><span class="line">                sum -= T[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum += T[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>99. Recover Binary Search Tree</title>
      <link href="/2018/08/27/99-Recover-Binary-Search-Tree/"/>
      <url>/2018/08/27/99-Recover-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Two elements of a binary search tree (BST) are swapped by mistake.</p><p>Recover the tree without changing its structure.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  /</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  3</span><br></pre></td></tr></table></figure></p><p>Follow up:</p><p>A solution using O(n) space is pretty straight forward.<br>Could you devise a constant space solution?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *first, *second; <span class="comment">//store the position that needs to be swap</span></span><br><span class="line">    TreeNode *prev; <span class="comment">// store the previous position in tree</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        first = second = prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//inorder traversal</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">NULL</span> &amp;&amp; second != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = first -&gt; val;</span><br><span class="line">            first -&gt; val = second -&gt; val;</span><br><span class="line">            second -&gt; val = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// check left first</span></span><br><span class="line">        <span class="keyword">if</span> (root -&gt; left != <span class="literal">NULL</span>) dfs(root -&gt; left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if there's any disorder, store the position. </span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; prev -&gt; val &gt; root -&gt; val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">NULL</span>) </span><br><span class="line">                first = prev;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">NULL</span>) </span><br><span class="line">                second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// current root become prev</span></span><br><span class="line">        prev = root;</span><br><span class="line">        <span class="comment">// right subtree</span></span><br><span class="line">        <span class="keyword">if</span> (root -&gt; right != <span class="literal">NULL</span>) dfs(root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(logn)$<br>reference:<br><a href="https://goo.gl/35YynW" target="_blank" rel="noopener">https://goo.gl/35YynW</a><br><a href="https://goo.gl/SVX1A6" target="_blank" rel="noopener">https://goo.gl/SVX1A6</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>63. Unique Paths II</title>
      <link href="/2018/08/27/63-Unique-Paths-II/"/>
      <url>/2018/08/27/63-Unique-Paths-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p><img src="robot_maze.png" alt=""></p><p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p><p>Note: m and n will be at most 100.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the 3x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid.empty() || obstacleGrid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size(), n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[j] += dp[j - <span class="number">1</span>]; <span class="comment">//current cell = top cell + left cell</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(mn)$<br>space complexity: $O(m)$<br>reference:<br><a href="https://goo.gl/KXyXji" target="_blank" rel="noopener">https://goo.gl/KXyXji</a><br><a href="https://goo.gl/oQm7Qe" target="_blank" rel="noopener">https://goo.gl/oQm7Qe</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>In-place conversion of Sorted DLL to Balanced BST</title>
      <link href="/2018/08/27/In-place-conversion-of-Sorted-DLL-to-Balanced-BST/"/>
      <url>/2018/08/27/In-place-conversion-of-Sorted-DLL-to-Balanced-BST/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a Doubly Linked List which has data members sorted in ascending order. Construct a Balanced Binary Search Tree which has same data members as the given Doubly Linked List. The tree must be constructed in-place (No new node should be allocated for tree conversion)</p><p>Examples:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Input:  Doubly Linked List 1  2  3</span><br><span class="line">Output: A Balanced BST </span><br><span class="line">     2   </span><br><span class="line">   /  \  </span><br><span class="line">  1    3 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: Doubly Linked List 1  2 3  4 5  6  7</span><br><span class="line">Output: A Balanced BST</span><br><span class="line">        4</span><br><span class="line">      /   \</span><br><span class="line">     2     6</span><br><span class="line">   /  \   / \</span><br><span class="line">  1   3  4   7  </span><br><span class="line"></span><br><span class="line">Input: Doubly Linked List 1  2  3  4</span><br><span class="line">Output: A Balanced BST</span><br><span class="line">      3   </span><br><span class="line">    /  \  </span><br><span class="line">   2    4 </span><br><span class="line"> / </span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">Input:  Doubly Linked List 1  2  3  4  5  6</span><br><span class="line">Output: A Balanced BST</span><br><span class="line">      4   </span><br><span class="line">    /   \  </span><br><span class="line">   2     6 </span><br><span class="line"> /  \   / </span><br><span class="line">1   3  5</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ul><li><p>Naive solution:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) Get the Middle of the linked list and make it root.</span><br><span class="line">2) Recursively do same for left half and right half.</span><br><span class="line">       a) Get the middle of left half and make it left child of the root</span><br><span class="line">          created in step 1.</span><br><span class="line">       b) Get the middle of right half and make it right child of the</span><br><span class="line">          root created in step 1.</span><br></pre></td></tr></table></figure></li><li><p>Better run time solution:<br>Construct from leaves to root. The idea is to insert nodes in BST in the same order as the appear in Doubly Linked List, so that the tree can be constructed in O(n) time complexity. We first count the number of nodes in the given Linked List. Let the count be n. After counting nodes, we take left n/2 nodes and recursively construct the left subtree. After left subtree is constructed, we assign middle node to root and link the left subtree with root. Finally, we recursively construct the right subtree and link it with root.<br>While constructing the BST, we also keep moving the list head pointer to next so that we have the appropriate pointer in each recursive call.</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A Doubly Linked List node that will also be used as a tree node */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; </span><br><span class="line">    <span class="comment">// For tree, next pointer can be used as right subtree pointer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// For tree, prev pointer can be used as left subtree pointer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//to count nodes in a Linked List, so we can know when is half</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(struct Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(temp)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">struct Node* <span class="title">sortedListToBSTRecur</span><span class="params">(struct Node **head_ref, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">struct Node* <span class="title">sortedListToBST</span><span class="params">(struct Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = countNodes(head);</span><br><span class="line">    <span class="keyword">return</span> sortedListToBSTRecur(&amp;head, n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The main function that constructs balanced BST and returns root of it.</span></span><br><span class="line"><span class="comment">       head_ref --&gt;  Pointer to pointer to head node of Doubly linked list</span></span><br><span class="line"><span class="comment">       n  --&gt; No. of nodes in the Doubly Linked List */</span></span><br><span class="line"><span class="function">struct Node* <span class="title">sortedListToBSTRecur</span><span class="params">(struct Node **head_ref, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Base Case */</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Recursively construct the left subtree */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span> = <span class="title">sortedListToBSTRecur</span>(<span class="title">head_ref</span>, <span class="title">n</span>/2);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* head_ref now refers to middle node, make middle node as root of BST*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">root</span> = *<span class="title">head_ref</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Set pointer to left subtree</span></span><br><span class="line">    root-&gt;prev = left;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Change head pointer of Linked List for parent recursive calls */</span></span><br><span class="line">    *head_ref = (*head_ref)-&gt;next;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Recursively construct the right subtree and link it with root</span></span><br><span class="line"><span class="comment">      The number of nodes in right subtree  is total nodes - nodes in</span></span><br><span class="line"><span class="comment">      left subtree - 1 (for root) */</span></span><br><span class="line">    root-&gt;next = sortedListToBSTRecur(head_ref, n-n/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/jEcKjy" target="_blank" rel="noopener">https://goo.gl/jEcKjy</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> double linked list </tag>
            
            <tag> BST </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/2018/08/26/42-Trapping-Rain-Water/"/>
      <url>/2018/08/26/42-Trapping-Rain-Water/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p><img src="rainwatertrap.png" alt=""></p><p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p><p>Example:</p><p>Input: [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two variables to store the left_max and right_max. The reason doing this is because the water trapped ata any element= <code>min(left_max, right_max)- height[i]</code>. So we can calculate the water trapped on smaller element out of height[left] and height[right] first, then move the pointers till <code>left &lt;= right</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left_max= <span class="number">0</span>, right_max= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt; height[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[left]&gt; left_max)</span><br><span class="line">                    left_max= height[left];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res += left_max-height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[right]&gt; right_max)</span><br><span class="line">                    right_max= height[right];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res+= right_max-height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/rNJVRc" target="_blank" rel="noopener">https://goo.gl/rNJVRc</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>158. Read N Characters Given Read4 II - Call multiple times</title>
      <link href="/2018/08/26/158-Read-N-Characters-Given-Read4-II-Call-multiple-times/"/>
      <url>/2018/08/26/158-Read-N-Characters-Given-Read4-II-Call-multiple-times/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>The API: int read4(char *buf) reads 4 characters at a time from a file.</p><p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p><p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p><p>Note:<br>The read function may be called multiple times.</p><p>Example 1: </p><p>Given buf = “abc”<br>read(“abc”, 1) // returns “a”<br>read(“abc”, 2); // returns “bc”<br>read(“abc”, 1); // returns “”<br>Example 2: </p><p>Given buf = “abc”<br>read(“abc”, 4) // returns “abc”<br>read(“abc”, 1); // returns “”</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two variable, readPos and writePos to store the position of read and write. Scanning from 0…n, if the position of read and write are equal, the call <code>read4</code> and give the return value to writePos because it’s the number characters read from input buffer. One thing to notice is that, if <code>writePos == 0</code>, it means input buffer is empty, we should return current location <code>i</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the read4 API.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read4</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Maximum number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (readPos == writePos) &#123;</span><br><span class="line">                writePos = read4(buff); <span class="comment">//return 3 if only 3 char left</span></span><br><span class="line">                readPos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (writePos == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = buff[readPos++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> readPos = <span class="number">0</span>, writePos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Another-solution"><a href="#Another-solution" class="headerlink" title="Another solution:"></a>Another solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the read4 API.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read4</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param buf Destination buffer</span></span><br><span class="line"><span class="comment">     * @param n   Maximum number of characters to read</span></span><br><span class="line"><span class="comment">     * @return    The number of characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> buffPtr= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buffCnt= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ptr= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptr&lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buffPtr== <span class="number">0</span>)&#123;</span><br><span class="line">                buffCnt= read4(buff);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">while</span>(ptr&lt; n &amp;&amp; buffPtr&lt; buffCnt)&#123;</span><br><span class="line">                buf[ptr++]= buff[buffPtr++];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// all chars in buff used up, set pointer to 0</span></span><br><span class="line">            <span class="keyword">if</span>(buffPtr== buffCnt) buffPtr= <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// read4 returns less than 4, end of file</span></span><br><span class="line">            <span class="keyword">if</span>(buffCnt &lt; <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> uber </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>128. Longest Consecutive Sequence</title>
      <link href="/2018/08/26/128-Longest-Consecutive-Sequence/"/>
      <url>/2018/08/26/128-Longest-Consecutive-Sequence/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p><p>Your algorithm should run in O(n) complexity.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is, when we have a number <code>n</code>, check it’s <code>n+1</code> and <code>n-1</code> to get the maximum length, and erase them from the set. Because if they’re consecutive, only need to count once.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; record(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!record.count(n)) <span class="keyword">continue</span>;</span><br><span class="line">            record.erase(n);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//use two pointer search toward left and right to find the largest range</span></span><br><span class="line">            <span class="keyword">int</span> left= n<span class="number">-1</span>, right= n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(record.count(left)) record.erase(left--);</span><br><span class="line">            <span class="keyword">while</span>(record.count(right)) record.erase(right++);</span><br><span class="line">            </span><br><span class="line">            res= max(res, right-left<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
            <tag> union find </tag>
            
            <tag> uber </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>161. One Edit Distance</title>
      <link href="/2018/08/26/161-One-Edit-Distance/"/>
      <url>/2018/08/26/161-One-Edit-Distance/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two strings s and t, determine if they are both one edit distance apart.</p><p>Note: </p><p>There are 3 possiblities to satisify one edit distance apart:</p><p>Insert a character into s to get t<br>Delete a character from s to get t<br>Replace a character of s to get t<br>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ab&quot;, t = &quot;acb&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We can insert &apos;c&apos; into s to get t.</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;cab&quot;, t = &quot;ad&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We cannot get t from s by only one step.</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;1203&quot;, t = &quot;1213&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We can replace &apos;0&apos; with &apos;1&apos; to get t.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneEditDistance</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        discussed into two parts, same length or diff length</span></span><br><span class="line"><span class="comment">        1. same length</span></span><br><span class="line"><span class="comment">            check if only one char is different</span></span><br><span class="line"><span class="comment">        2. diff length</span></span><br><span class="line"><span class="comment">            check if w/o the first one different character, the remain is equal or not.</span></span><br><span class="line"><span class="comment">            Once thing to notice is that, we should use longer string to be the delete character one.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> m= s.length(), n= t.length();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(m-n) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == t.length()) <span class="keyword">return</span> sizeEqual(s, t);</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; t.length()) <span class="keyword">return</span> sizeDiff(s, t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sizeDiff(t, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sizeDiff</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>, j= <span class="number">0</span>; i&lt; s.length()&amp;&amp; j&lt; t.length(); i++, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!= t[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> s.substr(i+<span class="number">1</span>) == t.substr(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sizeEqual</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != t[i]) diff++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> yelp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>114. Flatten Binary Tree to Linked List</title>
      <link href="/2018/08/26/114-Flatten-Binary-Tree-to-Linked-List/"/>
      <url>/2018/08/26/114-Flatten-Binary-Tree-to-Linked-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example, given the following tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure></p><p>The flattened tree should look like:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Recursive solution:</p><p>Use a global variable to store a previous node, and traverse the tree with post-order traversal.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">prev= NULL</span><br><span class="line"></span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">prev= 3</span><br><span class="line"></span><br><span class="line">  1</span><br><span class="line"> / </span><br><span class="line">2 </span><br><span class="line"> \</span><br><span class="line">  3</span><br><span class="line"></span><br><span class="line">prev= 2</span><br><span class="line">  1</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">     \</span><br><span class="line">      3</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* prev= <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) flatten(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) flatten(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        root-&gt;right= prev;</span><br><span class="line">        root-&gt;left= <span class="literal">NULL</span>;</span><br><span class="line">        prev= root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>463. Island Perimeter</title>
      <link href="/2018/08/25/463-Island-Perimeter/"/>
      <url>/2018/08/25/463-Island-Perimeter/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p><p>Example:</p><p>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]</p><p>Answer: 16<br>Explanation: The perimeter is the 16 yellow stripes in the image below:<br><img src="island.png" alt=""></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Count the total number of grid that is 1 from <code>top to down</code> and from <code>left to right</code>.</p><p>When we’re counting the perimeter, if there’s any neighbor of a grid, it will cancel off two edges.<br>ex:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> ---</span><br><span class="line">|   |  perimeter: 4</span><br><span class="line"> ---</span><br><span class="line"></span><br><span class="line"> ---</span><br><span class="line">|   |  perimeter: 6, 4*2-2</span><br><span class="line">|   |</span><br><span class="line"> ---</span><br></pre></td></tr></table></figure></p><p>While we’re scanning the grid, we need to know how many neighbor does this grid have. Since we’re scanning from top to down, we only need to count the neighbor its row is above the grid. </p><p>Same thing about the neighbor that has different column, only need to count neighbor that is on the left side.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> neighbor= <span class="number">0</span>, count= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">0</span>; r&lt; grid.size(); r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">0</span>; c&lt; grid[<span class="number">0</span>].size(); c++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[r][c] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//this is 1, search how many neighbor around it.</span></span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span>(r != <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c]== <span class="number">1</span>) neighbor++;</span><br><span class="line">                    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>]== <span class="number">1</span>) neighbor++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count*<span class="number">4</span>-neighbor*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(mn)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/5rZHRg" target="_blank" rel="noopener">https://goo.gl/5rZHRg</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> easy </tag>
            
            <tag> bloomberg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="/2018/08/25/206-Reverse-Linked-List/"/>
      <url>/2018/08/25/206-Reverse-Linked-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Reverse a singly linked list.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure></p><p>Follow up:</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Iteratively solution:<br>Create a dummy node in front of the <code>head</code> node. Use <code>pre</code> and <code>cur</code> to do the swap. But when we do the swapping, we need to use a <code>tmp</code> node to store the <code>cur</code> to avoid dropping nodes in between.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy= <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next= head;</span><br><span class="line">        ListNode *pre= dummy, *cur= head;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;next)&#123;</span><br><span class="line">            ListNode* tmp= pre-&gt;next;</span><br><span class="line">            pre-&gt;next= cur-&gt;next;</span><br><span class="line">            cur-&gt;next= cur-&gt;next-&gt;next;</span><br><span class="line">            pre-&gt;next-&gt;next= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n))$<br>space complexity: $O(1)$</p><p>Recursive solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head -&gt; next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* node = reverseList(head -&gt; next);</span><br><span class="line">        head -&gt; next -&gt; next = head;</span><br><span class="line">        head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/HSqym3" target="_blank" rel="noopener">https://goo.gl/HSqym3</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> easy </tag>
            
            <tag> amazon </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>252. Meeting Rooms</title>
      <link href="/2018/08/25/252-Meeting-Rooms/"/>
      <url>/2018/08/25/252-Meeting-Rooms/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,30],[5,10],[15,20]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[7,10],[2,4]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use lambda function to sort, if previous meeting is longer than the latter meeting, then the person can not attend all meetings.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [&amp;](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start&lt; b.start;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i<span class="number">-1</span>].end &gt; intervals[i].start)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$, sorting<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> easy </tag>
            
            <tag> amazon </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>34. Find First and Last Position of Element in Sorted Array</title>
      <link href="/2018/08/25/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/"/>
      <url>/2018/08/25/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>If the target is not found in the array, return [-1, -1].</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>First, let’s find the left boundary of the range. We initialize the range to <code>[left=0, right=n-1]</code>. In each step, calculate the middle element <code>mid = left+(right-left)/2</code>. Now according to the relative value of A[mid] to target, there are three possibilities:</p><ol><li>If <code>A[mid] &lt; target</code>, the target range must begins on the right of mid (hence <code>left = mid+1</code> for the next iteration)</li><li>If <code>A[mid] &gt; target</code>, it means the range must begins on the left of mid (<code>right = mid-1</code>)</li><li>If <code>A[mid] = target</code>, then the range must begins on the left of or at mid (<code>right= mid</code>)</li></ol><p>With above mid finding way, the mid will always biased toward left. So we can find the <code>left boundary</code> of target.</p><p>That is to say, if we make <code>mid</code> biased toward right, we can find <code>right boundary</code> of target.<br>We can use <code>mid = left+(right-left)/2 +1</code>. </p><ol><li>If A[mid] &gt; target, then the range must begins on the left of mid (<code>right = mid-1</code>)</li><li>If A[mid] &lt; target, then the range must begins on the right of mid (hence <code>left = mid+1</code> for the next iteration)</li><li>If A[mid] = target, then the range must begins on the right of or at mid (<code>left= mid</code>)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> high= nums.size()<span class="number">-1</span>, low= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(nums.size()== <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//search for left side</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= low+(high-low)/<span class="number">2</span>; <span class="comment">//with this mid finding, the mid will always biased toward left </span></span><br><span class="line">            <span class="keyword">if</span>(target&gt; nums[mid])</span><br><span class="line">                low= mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high= mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res[<span class="number">0</span>] = (target == nums[low])? low: <span class="number">-1</span>;</span><br><span class="line">        high= nums.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low&lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= low+(high-low)/<span class="number">2</span> +<span class="number">1</span>; <span class="comment">//notice for the mid value, add one so it will biased toward right</span></span><br><span class="line">            <span class="keyword">if</span>(target&gt;=nums[mid])</span><br><span class="line">                low= mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high= mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = (target == nums[high])? high: <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(logn)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/hL7qEx" target="_blank" rel="noopener">https://goo.gl/hL7qEx</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
            <tag> uber </tag>
            
            <tag> linkedin </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>269. Alien Dictionary</title>
      <link href="/2018/08/24/269-Alien-Dictionary/"/>
      <url>/2018/08/24/269-Alien-Dictionary/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;wrt&quot;,</span><br><span class="line">  &quot;wrf&quot;,</span><br><span class="line">  &quot;er&quot;,</span><br><span class="line">  &quot;ett&quot;,</span><br><span class="line">  &quot;rftt&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output: &quot;wertf&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;z&quot;,</span><br><span class="line">  &quot;x&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output: &quot;zx&quot;</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;z&quot;,</span><br><span class="line">  &quot;x&quot;,</span><br><span class="line">  &quot;z&quot;</span><br><span class="line">] </span><br><span class="line"></span><br><span class="line">Output: &quot;&quot; </span><br><span class="line"></span><br><span class="line">Explanation: The order is invalid, so return &quot;&quot;.</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>You may assume all letters are in lowercase.<br>You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.<br>If the order is invalid, return an empty string.<br>There may be multiple valid order of letters, return any one of them is fine.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>First, build a degree map for each character in all the words:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w:0</span><br><span class="line">r:0</span><br><span class="line">t:0</span><br><span class="line">f:0</span><br><span class="line">e:0</span><br></pre></td></tr></table></figure></p><p>Then build the hashmap by comparing the adjacent words, the first character that is different between two adjacent words reflect the lexicographical order. For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;wrt&quot;,</span><br><span class="line">&quot;wrf&quot;,</span><br><span class="line">   first different character is 3rd letter, so t comes before f</span><br><span class="line"></span><br><span class="line">&quot;wrf&quot;,</span><br><span class="line">&quot;er&quot;,</span><br><span class="line">   first different character is 1rd letter, so w comes before e</span><br></pre></td></tr></table></figure></p><p>The characters in set come after the key. x-&gt;y means letter x comes before letter y. x -&gt; set: y,z,t,w means x comes before all the letters in the set. The final HashMap “map” looks like.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t -&gt; set: f    </span><br><span class="line">w -&gt; set: e</span><br><span class="line">r -&gt; set: t</span><br><span class="line">e -&gt; set: r</span><br></pre></td></tr></table></figure></p><p>and final HashMap “degree” looks like, the number means “how many letters come before the key”:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w:0</span><br><span class="line">r:1</span><br><span class="line">t:1</span><br><span class="line">f:1</span><br><span class="line">e:1</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">alienOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; indegree;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">multiset</span>&lt;<span class="keyword">char</span>&gt;&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word: words)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ch: word)</span><br><span class="line">                indegree[ch]= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; words.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k= <span class="number">0</span>, len1= words[i<span class="number">-1</span>].length(), len2= words[i].length();</span><br><span class="line">            <span class="comment">//example: wrt, wrf</span></span><br><span class="line">            <span class="keyword">while</span>(words[i<span class="number">-1</span>][k] == words[i][k]) <span class="comment">//skip same characters</span></span><br><span class="line">                k++; <span class="comment">//ex: wrt, wrf. skip 'w', 'r'</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(k&gt;= min(len1, len2)) <span class="keyword">continue</span>; <span class="comment">//exceed one of the length</span></span><br><span class="line">            indegree[words[i][k]]++; <span class="comment">//ex: 'f' comes after 't', so indegree[f]++.</span></span><br><span class="line">            hash[words[i<span class="number">-1</span>][k]].insert(words[i][k]); <span class="comment">//since wrf is after wrt. hash[t]= [f, ...]</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; indegree.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch= <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> val: indegree)&#123; <span class="comment">//ex: indegree[t]= 0, indegree[f]= 1</span></span><br><span class="line">                <span class="keyword">if</span>(!val.second)&#123; <span class="comment">//find node that indegree == 0</span></span><br><span class="line">                    ch= val.first;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">' '</span>) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">//no one is indegree 0, that means have a cycle and is invalid</span></span><br><span class="line">            ans+= ch; <span class="comment">//append character with indegree= 0 to result</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;"ch: "&lt;&lt;ch&lt;&lt;" ,"&lt;&lt;indegree[ch];</span></span><br><span class="line">            indegree[ch]--; </span><br><span class="line">            <span class="comment">//cout&lt;&lt;", "&lt;&lt;indegree[ch]&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> val: hash[ch]) </span><br><span class="line">                indegree[val]--; <span class="comment">//every string comes after </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n+V))$, n: words averge length, V: alpha number of characters in given alphabet<br>space complexity: $O(V)$</p><p>The first step to create a graph takes O(n + alhpa) time where n is number of given words and alpha is number of characters in given alphabet. The second step is also topological sorting. Note that there would be alpha vertices and at-most (n-1) edges in the graph. The time complexity of topological sorting is O(V+E) which is O(n + aplha) here. So overall time complexity is O(n + aplha) + O(n + aplha) which is O(n + aplha).<br>reference:<br><a href="https://goo.gl/fKXTmg" target="_blank" rel="noopener">https://goo.gl/fKXTmg</a><br><a href="https://goo.gl/DDsvde" target="_blank" rel="noopener">https://goo.gl/DDsvde</a><br><a href="https://goo.gl/Lb26cZ" target="_blank" rel="noopener">https://goo.gl/Lb26cZ</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> graph </tag>
            
            <tag> topological sort </tag>
            
            <tag> airbnb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>33. Search in Rotated Sorted Array</title>
      <link href="/2018/08/24/33-Search-in-Rotated-Sorted-Array/"/>
      <url>/2018/08/24/33-Search-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm’s runtime complexity must be in the order of O(log n).</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We can use binary search to solve this question. The important part is to find the ascending part in the array.</p><p>For a Rotated Sorted Array, it must at some point follow the ascending order. We can check if <code>nums[mid] &gt;= nums[left]</code>, the first half would be a sorted array if it’s true. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= nums.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left])  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt; target &amp;&amp; nums[left] &lt;= target)  </span><br><span class="line">                    right = mid - <span class="number">1</span>;  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                    left = mid + <span class="number">1</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O()$<br>space complexity: $O()$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> apple </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
            <tag> linkedin </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>346. Moving Average from Data Stream</title>
      <link href="/2018/08/23/346-Moving-Average-from-Data-Stream/"/>
      <url>/2018/08/23/346-Moving-Average-from-Data-Stream/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MovingAverage m = new MovingAverage(3);</span><br><span class="line">m.next(1) = 1</span><br><span class="line">m.next(10) = (1 + 10) / 2</span><br><span class="line">m.next(3) = (1 + 10 + 3) / 3</span><br><span class="line">m.next(5) = (10 + 3 + 5) / 3</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use a queue to store the input and check if the size exceed the limit.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MovingAverage(<span class="keyword">int</span> size): sum(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;size= size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.size()&gt;= size)&#123;</span><br><span class="line">            sum-= q.front(); q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(val);</span><br><span class="line">        sum+= val;</span><br><span class="line">        <span class="keyword">return</span> q.size() == size? (sum/size): (sum/q.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj.next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(1)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/R1YzHh" target="_blank" rel="noopener">https://goo.gl/R1YzHh</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> easy </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>348. Design Tic-Tac-Toe</title>
      <link href="/2018/08/23/348-Design-Tic-Tac-Toe/"/>
      <url>/2018/08/23/348-Design-Tic-Tac-Toe/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a Tic-tac-toe game that is played between two players on a n x n grid.</p><p>You may assume the following rules:</p><p>A move is guaranteed to be valid and is placed on an empty block.<br>Once a winning condition is reached, no more moves is allowed.<br>A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Given n = 3, assume that player 1 is &quot;X&quot; and player 2 is &quot;O&quot; in the board.</span><br><span class="line"></span><br><span class="line">TicTacToe toe = new TicTacToe(3);</span><br><span class="line"></span><br><span class="line">toe.move(0, 0, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| | |</span><br><span class="line">| | | |    // Player 1 makes a move at (0, 0).</span><br><span class="line">| | | |</span><br><span class="line"></span><br><span class="line">toe.move(0, 2, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| | | |    // Player 2 makes a move at (0, 2).</span><br><span class="line">| | | |</span><br><span class="line"></span><br><span class="line">toe.move(2, 2, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| | | |    // Player 1 makes a move at (2, 2).</span><br><span class="line">| | |X|</span><br><span class="line"></span><br><span class="line">toe.move(1, 1, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| |O| |    // Player 2 makes a move at (1, 1).</span><br><span class="line">| | |X|</span><br><span class="line"></span><br><span class="line">toe.move(2, 0, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| |O| |    // Player 1 makes a move at (2, 0).</span><br><span class="line">|X| |X|</span><br><span class="line"></span><br><span class="line">toe.move(1, 0, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">|O|O| |    // Player 2 makes a move at (1, 0).</span><br><span class="line">|X| |X|</span><br><span class="line"></span><br><span class="line">toe.move(2, 1, 1); -&gt; Returns 1 (player 1 wins)</span><br><span class="line">|X| |O|</span><br><span class="line">|O|O| |    // Player 1 makes a move at (2, 1).</span><br><span class="line">|X|X|X|</span><br></pre></td></tr></table></figure></p><p>Follow up:<br>Could you do better than O(n2) per move() operation?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>If a player wins a Tic-Tac-Toe, it will achieve one of the following conditions:</p><ol><li>Totally <code>n</code> move on the same row.</li><li>Totally <code>n</code> move on the same column.</li><li>Totally <code>n</code> move on diagonal line.</li><li>Totally <code>n</code> move on anti-diagonal line.</li></ol><p>Therefore, we can use two 1D array and two variable to solve this question.<br>For each move, add the value to rows, columns, diagonal and anti-diagonal. If at any time a row or column matches the size of the board then that player has won.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicTacToe</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rows;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols;</span><br><span class="line">    <span class="keyword">int</span> diagonal= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> antiDiagonal= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    TicTacToe(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        rows.resize(n, <span class="number">0</span>);</span><br><span class="line">        cols.resize(n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;).</span></span><br><span class="line"><span class="comment">        @param row The row of the board.</span></span><br><span class="line"><span class="comment">        @param col The column of the board.</span></span><br><span class="line"><span class="comment">        @param player The player, can be either 1 or 2.</span></span><br><span class="line"><span class="comment">        @return The current winning condition, can be either:</span></span><br><span class="line"><span class="comment">                0: No one wins.</span></span><br><span class="line"><span class="comment">                1: Player 1 wins.</span></span><br><span class="line"><span class="comment">                2: Player 2 wins. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> toAdd= player == <span class="number">1</span>? <span class="number">1</span>: <span class="number">-1</span>;</span><br><span class="line">        rows[row]+= toAdd;</span><br><span class="line">        cols[col]+= toAdd;</span><br><span class="line">        <span class="keyword">if</span>(row == col)</span><br><span class="line">            diagonal+= toAdd;</span><br><span class="line">        <span class="keyword">if</span>(col == cols.size()- row<span class="number">-1</span>)</span><br><span class="line">            antiDiagonal+= toAdd;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(rows[row]) == rows.size() ||</span><br><span class="line">           <span class="built_in">abs</span>(cols[col]) == rows.size() ||</span><br><span class="line">           <span class="built_in">abs</span>(diagonal) == rows.size() ||</span><br><span class="line">           <span class="built_in">abs</span>(antiDiagonal) == rows.size())</span><br><span class="line">            <span class="keyword">return</span> player;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TicTacToe object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TicTacToe obj = new TicTacToe(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.move(row,col,player);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/YR2JYd" target="_blank" rel="noopener">https://goo.gl/YR2JYd</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>785. Is Graph Bipartite?</title>
      <link href="/2018/08/23/785-Is-Graph-Bipartite/"/>
      <url>/2018/08/23/785-Is-Graph-Bipartite/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an undirected graph, return true if and only if it is bipartite.</p><p>Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p><p>The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn’t contain any element twice.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">graph will have length in range [1, 100].</span><br><span class="line">graph[i] will contain integers in range [0, graph.length - 1].</span><br><span class="line">graph[i] will not contain i or duplicate values.</span><br><span class="line">The graph is undirected: if any element j is in graph[i], then i will be in graph[j].</span><br><span class="line"></span><br><span class="line">### Solution:</span><br><span class="line"></span><br><span class="line">The goal is to use two colors to paint the graph and see if there are any adjacent nodes having the same color.</span><br><span class="line">Initialize a color[] array for each node. Here are three states for colors[] array:</span><br><span class="line">1: color 1</span><br><span class="line">0: Haven&apos;t been colored.</span><br><span class="line">-1: color 2</span><br><span class="line"></span><br><span class="line">For each node,</span><br><span class="line">1. If it hasn&apos;t been colored, use a color to color it. Then use the other color to color all its adjacent nodes (DFS).</span><br><span class="line">2. If it has been colored, check if the current color is the same as the color that is going to be used to color it.</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;</span><br><span class="line">        int n= graph.size();</span><br><span class="line">        vector&lt;int&gt; colors(n, 0); </span><br><span class="line">        //three states</span><br><span class="line">        //0: not painted</span><br><span class="line">        //1: color 1</span><br><span class="line">        //-1: color 2</span><br><span class="line">        for(int i= 0; i&lt; n; i++)&#123;</span><br><span class="line">            if(colors[i] == 0 &amp;&amp; !paint(graph, colors, i, 1))</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool paint(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; colors, int index, int color)&#123;</span><br><span class="line">        if(colors[index] != 0)</span><br><span class="line">            return colors[index] == color;</span><br><span class="line">        </span><br><span class="line">        //color = 0, means not painted yet. Assign color to node[index]</span><br><span class="line">        colors[index]= color;</span><br><span class="line">        </span><br><span class="line">        for(int i= 0; i&lt; graph[index].size(); i++)&#123;</span><br><span class="line">            if(!paint(graph, colors, graph[index][i], -color)) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(V+E)$<br>space complexity: $O(E)$<br>reference:<br><a href="https://goo.gl/w53FV8" target="_blank" rel="noopener">https://goo.gl/w53FV8</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
            <tag> amazon </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>211. Add and Search Word - Data structure design</title>
      <link href="/2018/08/23/211-Add-and-Search-Word-Data-structure-design/"/>
      <url>/2018/08/23/211-Add-and-Search-Word-Data-structure-design/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Design a data structure that supports the following two operations:</p><p>void addWord(word)<br>bool search(word)<br>search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">addWord(&quot;bad&quot;)</span><br><span class="line">addWord(&quot;dad&quot;)</span><br><span class="line">addWord(&quot;mad&quot;)</span><br><span class="line">search(&quot;pad&quot;) -&gt; false</span><br><span class="line">search(&quot;bad&quot;) -&gt; true</span><br><span class="line">search(&quot;.ad&quot;) -&gt; true</span><br><span class="line">search(&quot;b..&quot;) -&gt; true</span><br></pre></td></tr></table></figure></p><p>Note:<br>You may assume that all words are consist of lowercase letters a-z.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Most of the part is similar to <a href="/2018/08/23/208-Implement-Trie-Prefix-Tree/" title="208. Implement Trie (Prefix Tree)">208. Implement Trie (Prefix Tree)</a>. The only thing we need to modify is the search part.</p><p>Since we now have <code>&#39;.&#39;</code> to check, we can use DFS to check whether if the trie tree contains the string after the <code>&#39;.&#39;</code>. If there’s at least one subtree return true, that means we can find a word in trie.</p><p>Another follow up for this question is adding <code>&#39;*&#39;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//design a TrieNode class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    TrieNode(): isWord(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c: child)</span><br><span class="line">            c= <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* root; <span class="comment">//global variable root</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode* tmp= root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: word)&#123;</span><br><span class="line">            <span class="keyword">int</span> i= c- <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!tmp-&gt;child[i]) </span><br><span class="line">                tmp-&gt;child[i]= <span class="keyword">new</span> TrieNode();</span><br><span class="line">            </span><br><span class="line">            tmp = tmp-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;isWord= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//need to consider the '.'</span></span><br><span class="line">        <span class="comment">//follow up: '*'</span></span><br><span class="line">        <span class="keyword">return</span> searchWord(word, root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchWord</span><span class="params">(<span class="built_in">string</span> &amp;word, TrieNode *p, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == word.length()) <span class="keyword">return</span> p-&gt;isWord;</span><br><span class="line">        <span class="keyword">if</span>(word[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c: p-&gt;child)&#123;</span><br><span class="line">                <span class="comment">//DFS, if child c is existed and we can find next character in trie, return true</span></span><br><span class="line">                <span class="keyword">if</span>(c &amp;&amp; searchWord(word, c, i+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* follow up for '*'</span></span><br><span class="line"><span class="comment">        else if (word[i] == '*') &#123;</span></span><br><span class="line"><span class="comment">            if (i + 1 == word.size()) return true;</span></span><br><span class="line"><span class="comment">            if (searchWord(word, p, i + 1)) return true; // Skip *</span></span><br><span class="line"><span class="comment">            for (auto &amp;a : p-&gt;child) &#123;</span></span><br><span class="line"><span class="comment">                if (a &amp;&amp; (a-&gt;child[word[i + 1] - 'a'] || word[i + 1] == '.' || word[i + 1] == '*') &amp;&amp; searchWord(word, a, i + 1)) return true;</span></span><br><span class="line"><span class="comment">                if (a &amp;&amp; searchWord(word, a, i)) return true;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index= word[i]- <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;child[index] &amp;&amp; searchWord(word, p-&gt;child[index], i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj.addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>addWord:<br>time complexity: $O(l)$, l is the average length of word<br>space complexity: $O(l)$</p><p>search:<br>time complexity: $O(26^l)$, l is the average length of word<br>space complexity: $O(1)$</p><p>Overall space Complexity - $O(26^l)$, l is the average length of word</p><p>reference:<br><a href="https://goo.gl/2AQFjo" target="_blank" rel="noopener">https://goo.gl/2AQFjo</a><br><a href="https://goo.gl/pihuH1" target="_blank" rel="noopener">https://goo.gl/pihuH1</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> trie </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>208. Implement Trie (Prefix Tree)</title>
      <link href="/2018/08/23/208-Implement-Trie-Prefix-Tree/"/>
      <url>/2018/08/23/208-Implement-Trie-Prefix-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Implement a trie with insert, search, and startsWith methods.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // returns true</span><br><span class="line">trie.search(&quot;app&quot;);     // returns false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // returns true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     // returns true</span><br></pre></td></tr></table></figure></p><p>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.<br>All inputs are guaranteed to be non-empty strings.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Trie is an important data structure that frequently appeared in interviews. To design a <code>TrieNode</code>, we need a word collection <code>child[26]</code>, which is from a-z, and a boolean value <code>isWord</code> that denotes whether this node is a word or not.</p><p>Insertion in trie<br><img src="1.png" alt=""></p><p>Searching in trie<br><img src="2.png" width="60%"></p><p>Searching prefix in trie<br><img src="3.png" width="60%"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">        </span><br><span class="line">    TrieNode(): isWord(<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c: child)</span><br><span class="line">            c= <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    TrieNode* root;</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root= <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode* p= root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a: word)&#123;</span><br><span class="line">            <span class="keyword">int</span> i= a-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[i]) </span><br><span class="line">                p-&gt;child[i]= <span class="keyword">new</span> TrieNode();</span><br><span class="line">            </span><br><span class="line">            p= p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isWord= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">        TrieNode* p= root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: key)&#123;</span><br><span class="line">            <span class="keyword">int</span> i= c- <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p= p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* p= root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: prefix)&#123;</span><br><span class="line">            <span class="keyword">int</span> i= c- <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p= p-&gt;child[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>Insertion:<br>  time complexity: $O(m)$, m is key length<br>  space complexity: $O(m)$, m is key length</p><p>Search:<br>  time complexity: $O(m)$, m is key length<br>  space complexity: $O(1)$</p><p>Search prefix:<br>  time complexity: $O(m)$, m is key length<br>  space complexity: $O(1)</p><p>reference:<br><a href="https://goo.gl/JjdfdH" target="_blank" rel="noopener">https://goo.gl/JjdfdH</a><br><a href="https://goo.gl/oYnq3P" target="_blank" rel="noopener">https://goo.gl/oYnq3P</a><br><a href="https://goo.gl/QvAJQx" target="_blank" rel="noopener">https://goo.gl/QvAJQx</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>88. Merge Sorted Array</title>
      <link href="/2018/08/23/88-Merge-Sorted-Array/"/>
      <url>/2018/08/23/88-Merge-Sorted-Array/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p><p>Note:</p><p>The number of elements initialized in nums1 and nums2 are m and n respectively.<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two pointers to solve this question.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">round 0:</span><br><span class="line">     m     i</span><br><span class="line">[1,2,3,0,0,0]</span><br><span class="line">[2,5,6]</span><br><span class="line">     n</span><br><span class="line"></span><br><span class="line">round 1:</span><br><span class="line">     m   i  </span><br><span class="line">[1,2,3,0,0,6]</span><br><span class="line">[2,5,6]</span><br><span class="line">   n</span><br><span class="line"></span><br><span class="line">round 2:</span><br><span class="line">     m i    </span><br><span class="line">[1,2,3,0,5,6]</span><br><span class="line">[2,5,6]</span><br><span class="line"> n      </span><br><span class="line"></span><br><span class="line">round 3:</span><br><span class="line">   m i    </span><br><span class="line">[1,2,3,3,5,6]</span><br><span class="line">[2,5,6]</span><br><span class="line"> n      </span><br><span class="line"></span><br><span class="line">round 4:</span><br><span class="line">  mi    </span><br><span class="line">[1,2,2,3,5,6]</span><br><span class="line">[2,5,6]</span><br><span class="line"> n</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = m<span class="number">-1</span>, b= n<span class="number">-1</span>, i=m+n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(a&gt;=<span class="number">0</span> &amp;&amp; b&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i--] = (nums1[a] &gt; nums2[b]) ? nums1[a--] : nums2[b--];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(b&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[i--] = nums2[b--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> easy </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>278. First Bad Version</title>
      <link href="/2018/08/23/278-First-Bad-Version/"/>
      <url>/2018/08/23/278-First-Bad-Version/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given n = 5, and version = 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use binary search to solve this question.</p><p>example1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">x x x v v</span><br><span class="line"></span><br><span class="line">left= 1, right= 5</span><br><span class="line">  mid= 3, badVersion, left= 4</span><br><span class="line"></span><br><span class="line">left= 4, right= 5</span><br><span class="line">  mid= 4, goodVersion, right= 4</span><br><span class="line"></span><br><span class="line">left== right</span><br><span class="line">  stop while loop</span><br><span class="line"></span><br><span class="line">the first bad version is right= 4</span><br></pre></td></tr></table></figure></p><p>example2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">x v v v v</span><br><span class="line"></span><br><span class="line">left= 1, right= 5</span><br><span class="line">  mid= 3, goodVersion, right= 3</span><br><span class="line"></span><br><span class="line">left= 1, right= 3</span><br><span class="line">  mid= 2, goodVersion, right= 2</span><br><span class="line"></span><br><span class="line">left= 1, right= 2</span><br><span class="line">  mid= 1, badVersion, left= 2</span><br><span class="line"></span><br><span class="line">left== right</span><br><span class="line">  stop while loop</span><br><span class="line"></span><br><span class="line">the first bad version is right= 2</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">1</span>, right= n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= left+ (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                right= mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left= mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(logn)$<br>space complexity: $O(1)$<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> easy </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>325. Maximum Size Subarray Sum Equals k</title>
      <link href="/2018/08/23/325-Maximum-Size-Subarray-Sum-Equals-k/"/>
      <url>/2018/08/23/325-Maximum-Size-Subarray-Sum-Equals-k/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn’t one, return 0 instead.</p><p>Note:<br>The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, -1, 5, -2, 3], k = 3</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.</p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2, -1, 2, 1], k = 1</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Explanation: The subarray [-1, 2] sums to 1 and is the longest.</p><p>Follow Up:<br>Can you do it in O(n) time?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use an unordered_map with current sum as index, and index in the array as value.</p><p>But to construct <code>k</code> might not be straightforward, so we can see this example.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6], k= 9</span><br><span class="line">-------|</span><br><span class="line">sum= 6</span><br><span class="line">-------------|</span><br><span class="line">      sum= 15</span><br></pre></td></tr></table></figure><p>We want to find <code>k=9</code> in the above example. When we get to 5, we can see that 15-6= 9. That is to say, if we have a current sum equals to <code>y</code>, and we can find a previous sum <code>x</code> equals to <code>y-k</code>, then we find a subarray that can construct <code>k</code>.</p><p>In the above example.y= 15, k= 9, x= 6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">//sum, index</span></span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>, cur_sum= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            cur_sum+= nums[i];</span><br><span class="line">            <span class="keyword">if</span>(cur_sum == k)</span><br><span class="line">                res= i+<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(cur_sum-k) != <span class="built_in">map</span>.end()) <span class="comment">//can construct a k with some part of the array</span></span><br><span class="line">                res= max(res, i-<span class="built_in">map</span>[cur_sum-k]); <span class="comment">//compare current maximum result with the new one</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(cur_sum) == <span class="built_in">map</span>.end()) <span class="comment">//can not find cur_sum in map</span></span><br><span class="line">                <span class="built_in">map</span>[cur_sum]= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/JNXSBp" target="_blank" rel="noopener">https://goo.gl/JNXSBp</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>277. Find the Celebrity</title>
      <link href="/2018/08/22/277-Find-the-Celebrity/"/>
      <url>/2018/08/22/277-Find-the-Celebrity/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.</p><p>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: “Hi, A. Do you know B?” to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).</p><p>You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.</p><p>Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity’s label if there is a celebrity in the party. If there is no celebrity, return -1.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to first find a person that does not know everyone.</p><p>Since celebrity don’t know anyone else, so if candidate knows i, candidate is definitely not celebrity.</p><ol><li>If A knows B: A must not be celebrity, B possible</li><li>If A doesn’t know B: A possible, B must not be celebrity.</li></ol><p>After we got a candidate like this, we need to check two things.</p><ol><li>This candidate does not know any one else</li><li>Everyone knows the candidate</li></ol><p>One thing to improve is that we can use the index to help. Since we’ve already did the <code>knows(candidate, i)</code> in previous loop, we only need to check <code>!knows(i, candidate)</code> if <code>i&gt; candidate</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of the knows API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">knows</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">0</span>; <span class="comment">//set first person as candidate</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(knows(candidate, i))&#123; </span><br><span class="line">                candidate = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">// speed up the searching process, because part of the check did it before.</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;candidate &amp;&amp; knows(candidate, i) || !knows(i, candidate)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;candidate &amp;&amp; !knows(i, candidate)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/tyBj1e" target="_blank" rel="noopener">https://goo.gl/tyBj1e</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>133. Clone Graph</title>
      <link href="/2018/08/22/133-Clone-Graph/"/>
      <url>/2018/08/22/133-Clone-Graph/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p><p>OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.</p><p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p><p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p><p>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.<br>Second node is labeled as 1. Connect node 1 to node 2.<br>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.<br>Visually, the graph looks like the following:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line">  / \</span><br><span class="line"> /   \</span><br><span class="line">0 --- 2</span><br><span class="line">     / \</span><br><span class="line">     \_/</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a map to store every node that has already been copied. While adding every neighbor, call recursive function to apply dfs.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for undirected graph.</span></span><br><span class="line"><span class="comment"> * struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//use map to store the nodes that have already been copied</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; <span class="built_in">map</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.find(node) == <span class="built_in">map</span>.end())&#123; <span class="comment">//not cloned yet</span></span><br><span class="line">            UndirectedGraphNode* tmp= <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);</span><br><span class="line">            <span class="built_in">map</span>[node]= tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n: node-&gt;neighbors)&#123;</span><br><span class="line">                tmp-&gt;neighbors.push_back(cloneGraph(n));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(V+E)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/BGsAmT" target="_blank" rel="noopener">https://goo.gl/BGsAmT</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
            <tag> amazon </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>791. Custom Sort String</title>
      <link href="/2018/08/22/791-Custom-Sort-String/"/>
      <url>/2018/08/22/791-Custom-Sort-String/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>S and T are strings composed of lowercase letters. In S, no letter occurs more than once.</p><p>S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string.</p><p>Return any permutation of T (as a string) that satisfies this property.</p><p>Example :<br>Input:<br>S = “cba”<br>T = “abcd”<br>Output: “cbad”<br>Explanation:<br>“a”, “b”, “c” appear in S, so the order of “a”, “b”, “c” should be “c”, “b”, and “a”.<br>Since “d” does not appear in S, it can be at any position in T. “dcba”, “cdba”, “cbda” are also valid outputs.</p><p>Note:</p><p>S has length at most 26, and no character is repeated in S.<br>T has length at most 200.<br>S and T consist of lowercase letters only.</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>Use STL to solve this question.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">customSortString</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        sort(T.begin(), T.end(),</span><br><span class="line">             [&amp;](<span class="keyword">char</span> a, <span class="keyword">char</span> b) &#123; <span class="keyword">return</span> S.find(a) &lt; S.find(b); &#125;);</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>space complexity: $O(1)$</p><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><p>S: customer order<br>T: string to be sorted</p><ol><li>Use bucket sort to store all the characters in <code>bucket</code>. </li><li>Walk through <code>customer order</code>, the bucket[c] contains the number of occurrence in T. We need to append that many times of <code>c</code> in the result string.</li><li>Append remaining characters in result string. </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">customSortString</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        bucket sort</span></span><br><span class="line"><span class="comment">        1. put the string into the bucket</span></span><br><span class="line"><span class="comment">        2. append every same character into string</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//S: cba</span></span><br><span class="line">        <span class="comment">//T: abcd</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: T)</span><br><span class="line">            bucket[c-<span class="string">'a'</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res= <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: S)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; bucket[c-<span class="string">'a'</span>]; i++)&#123;</span><br><span class="line">                res+= c;</span><br><span class="line">            &#125;</span><br><span class="line">            bucket[c-<span class="string">'a'</span>]= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; bucket.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; bucket[i]; j++)</span><br><span class="line">                res+= (i+<span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/Lef54y" target="_blank" rel="noopener">https://goo.gl/Lef54y</a><br><a href="https://goo.gl/aX25f1" target="_blank" rel="noopener">https://goo.gl/aX25f1</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="/2018/08/22/125-Valid-Palindrome/"/>
      <url>/2018/08/22/125-Valid-Palindrome/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p><p>Example 1:<br>Input: “A man, a plan, a canal: Panama”<br>Output: true</p><p>Example 2:<br>Input: “race a car”<br>Output: false</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use two pointers to solve this question.<br><code>isalnum</code> can check if the character is numeric or alphabetic.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= s.length()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(s[left])) left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(s[right])) right--;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[left])!= <span class="built_in">tolower</span>(s[right]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left++; right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/vyjCpj" target="_blank" rel="noopener">https://goo.gl/vyjCpj</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> apple </tag>
            
            <tag> easy </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>257. Binary Tree Paths</title>
      <link href="/2018/08/22/257-Binary-Tree-Paths/"/>
      <url>/2018/08/22/257-Binary-Tree-Paths/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, return all root-to-leaf paths.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure></p><p>Output: <code>[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</code></p><p>Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use dfs to find every leaf. The definition for leaf is it does not have left child or right child.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">string</span> tmp= <span class="string">""</span>;</span><br><span class="line">        helper(res, tmp, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span> tmp, TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="comment">//reach a leaf</span></span><br><span class="line">            res.push_back(tmp+to_string(root-&gt;val));</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) helper(res, tmp+to_string(root-&gt;val)+<span class="string">"-&gt;"</span>, root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) helper(res, tmp+to_string(root-&gt;val)+<span class="string">"-&gt;"</span>, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$, because visit every node once<br>space complexity: $O(logn)$, height of the tree<br>reference:<br><a href="https://goo.gl/RvfssD" target="_blank" rel="noopener">https://goo.gl/RvfssD</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>247. Strobogrammatic Number II</title>
      <link href="/2018/08/22/247-Strobogrammatic-Number-II/"/>
      <url>/2018/08/22/247-Strobogrammatic-Number-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p><p>Find all strobogrammatic numbers that are of length = n.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  n = 2</span><br><span class="line">Output: [&quot;11&quot;,&quot;69&quot;,&quot;88&quot;,&quot;96&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>First, we use some example to find the pattern. If given n= 4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = 0:   none</span><br><span class="line"></span><br><span class="line">n = 1:   0, 1, 8</span><br><span class="line"></span><br><span class="line">n = 2:   11, 69, 88, 96</span><br><span class="line"></span><br><span class="line">n = 3:   101, 609, 808, 906, 111, 619, 818, 916, 181, 689, 888, 986</span><br><span class="line"></span><br><span class="line">n = 4:   1001, 6009, 8008, 9006, 1111, 6119, 8118, 9116, 1691, 6699, 8698, 9696, 1881, 6889, 8888, 9886, 1961, 6969, 8968, 9966</span><br></pre></td></tr></table></figure><p>Observe <code>n == 0</code> and <code>n == 2</code>, we can see that the latter one is base on the previous one with [1 1], [6 9], [8 8], [9 6] on both side. The same thing happens on <code>n==1</code> and <code>n==3</code>.</p><p>One thing to notice is that when <code>n == 4</code>, we can not put <code>0</code> on each side.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findStrobogrammatic(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> find(n, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; find(<span class="keyword">int</span> m, <span class="keyword">int</span> n) &#123; <span class="comment">//m: which layer currently at. n: which layer need to reach</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="string">""</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"8"</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; t = find(m - <span class="number">2</span>, n), res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m != n) res.push_back(<span class="string">"0"</span> + a + <span class="string">"0"</span>); <span class="comment">//0 and 0 can not be in the front and end</span></span><br><span class="line">            res.push_back(<span class="string">"1"</span> + a + <span class="string">"1"</span>);</span><br><span class="line">            res.push_back(<span class="string">"6"</span> + a + <span class="string">"9"</span>);</span><br><span class="line">            res.push_back(<span class="string">"8"</span> + a + <span class="string">"8"</span>);</span><br><span class="line">            res.push_back(<span class="string">"9"</span> + a + <span class="string">"6"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(5^n))$, for every recursive call, there will be 5 different result for every string.<br>space complexity: $O(n/2))$, stack space</p><p>reference:<br><a href="https://goo.gl/oiRqCY" target="_blank" rel="noopener">https://goo.gl/oiRqCY</a><br><a href="https://goo.gl/mr3grV" target="_blank" rel="noopener">https://goo.gl/mr3grV</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>426. Convert Binary Search Tree to Sorted Doubly Linked List</title>
      <link href="/2018/08/22/426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/"/>
      <url>/2018/08/22/426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list.</p><p>Let’s take the following BST as an example, it may help you understand the problem better:</p><p><img src="1.png" width="60%"></p><p>We want to transform this BST into a circular doubly linked list. Each node in a doubly linked list has a predecessor and successor. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.</p><p>The figure below shows the circular doubly linked list for the BST above. The “head” symbol means the node it points to is the smallest element of the linked list.</p><p><img src="2.png" alt=""></p><p>Specifically, we want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. We should return the pointer to the first element of the linked list.</p><p>The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.</p><p><img src="3.png" width="70%"></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a stack to help us traverse the tree. When we reach to left most node, which is the head node, we need to store it for the last element point to its successor. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        Node* cur= root;</span><br><span class="line">        Node* head= <span class="literal">NULL</span>;</span><br><span class="line">        Node* prev= <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; stk;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur || !stk.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">                stk.push(cur);</span><br><span class="line">                cur= cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur= stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">if</span>(!head) head= cur; <span class="comment">//find the left most, it is the head</span></span><br><span class="line">                <span class="keyword">if</span>(prev)&#123;</span><br><span class="line">                    prev-&gt;right= cur; </span><br><span class="line">                    cur-&gt;left= prev;</span><br><span class="line">                &#125;</span><br><span class="line">                prev= cur;</span><br><span class="line">                cur= cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;left= prev;</span><br><span class="line">        prev-&gt;right= head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/5WuMah" target="_blank" rel="noopener">https://goo.gl/5WuMah</a><br><a href="https://goo.gl/AMsfU3" target="_blank" rel="noopener">https://goo.gl/AMsfU3</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>124. Binary Tree Maximum Path Sum</title>
      <link href="/2018/08/22/124-Binary-Tree-Maximum-Path-Sum/"/>
      <url>/2018/08/22/124-Binary-Tree-Maximum-Path-Sum/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-empty binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br></pre></td></tr></table></figure></p><p>Output: 6<br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure></p><p>Output: 42</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea of this question is to do dfs with a global variable. We design a dfs function that help to </p><ol><li>computes the maximum path sum with highest node is the input node, update maximum if necessary.</li><li>returns the maximum sum of the path that can be extended to input node’s parent.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result= INT_MIN;</span><br><span class="line">        dfs(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left= max(<span class="number">0</span>, dfs(root-&gt;left, result));</span><br><span class="line">        <span class="keyword">int</span> right= max(<span class="number">0</span>, dfs(root-&gt;right, result));</span><br><span class="line">        </span><br><span class="line">        result= max(result, left+right+root-&gt;val); <span class="comment">//use root as the lowest common ancestor, which is the highest node to compare with current maximum result</span></span><br><span class="line">        <span class="keyword">return</span> max(left, right)+root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/NGnBtX" target="_blank" rel="noopener">https://goo.gl/NGnBtX</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>560. Subarray Sum Equals K</title>
      <link href="/2018/08/21/560-Subarray-Sum-Equals-K/"/>
      <url>/2018/08/21/560-Subarray-Sum-Equals-K/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p><p>Example 1:<br>Input:nums = [1,1,1], k = 2<br>Output: 2<br>Note:<br>The length of the array is in range [1, 20,000].<br>The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The key of solving this problem is to find <code>SUM[i, j]</code>. So if we know <code>SUM[0, i - 1]</code> and <code>SUM[0, j]</code>, then we can easily get <code>SUM[i, j]</code>. To achieve this, we just need to go through the array, calculate the current sum and save number of all seen PreSum to a HashMap. </p><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[2,3,2,5,8]</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">init state:</span><br><span class="line">0, 1</span><br><span class="line"></span><br><span class="line">round 1:</span><br><span class="line">cur_sum: 2, ans: 0, cur-k: -3, count: 0 after_count: 0</span><br><span class="line"> 2, 1</span><br><span class="line"> -3, 0</span><br><span class="line"> 0, 1</span><br><span class="line"></span><br><span class="line">round 2:</span><br><span class="line">cur_sum: 5, ans: 1, cur-k: 0, count: 1 after_count: 1</span><br><span class="line"> 2, 1</span><br><span class="line"> -3, 0</span><br><span class="line"> 5, 1</span><br><span class="line"> 0, 1</span><br><span class="line"></span><br><span class="line">round 3:</span><br><span class="line">cur_sum: 7, ans: 2, cur-k: 2, count: 1 after_count: 1</span><br><span class="line"> 7, 1</span><br><span class="line"> 0, 1</span><br><span class="line"> 5, 1</span><br><span class="line"> -3, 0</span><br><span class="line"> 2, 1</span><br><span class="line"></span><br><span class="line">round 4:</span><br><span class="line">cur_sum: 12, ans: 3, cur-k: 7, count: 1 after_count: 1</span><br><span class="line"> 12, 1</span><br><span class="line"> 7, 1</span><br><span class="line"> 0, 1</span><br><span class="line"> 5, 1</span><br><span class="line"> -3, 0</span><br><span class="line"> 2, 1</span><br><span class="line"></span><br><span class="line">round 5:</span><br><span class="line">cur_sum: 20, ans: 3, cur-k: 15, count: 0 after_count: 0</span><br><span class="line"> 20, 1</span><br><span class="line"> 15, 0</span><br><span class="line"> 12, 1</span><br><span class="line"> 7, 1</span><br><span class="line"> 0, 1</span><br><span class="line"> 5, 1</span><br><span class="line"> -3, 0</span><br><span class="line"> 2, 1</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counts&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            cur_sum += num;</span><br><span class="line">            ans += counts[cur_sum - k];</span><br><span class="line">            ++counts[cur_sum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/3nxf3P" target="_blank" rel="noopener">https://goo.gl/3nxf3P</a><br><a href="https://goo.gl/T4kEoE" target="_blank" rel="noopener">https://goo.gl/T4kEoE</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>543. Diameter of Binary Tree</title>
      <link href="/2018/08/21/543-Diameter-of-Binary-Tree/"/>
      <url>/2018/08/21/543-Diameter-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree </span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5</span><br></pre></td></tr></table></figure></p><p>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>If the longest path will include the root node, then the longest path must be the depth(root-&gt;right) + depth (root-&gt;left)<br>If the longest path does not include the root node, this problem is divided into 2 sub-problem: set left child and right child as the new root separately, and repeat step1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> max_d= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        design a maxDepth function to calculate depth for left and right subtree</span></span><br><span class="line"><span class="comment">        a global variable for maximum diameter</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> max_d;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) left= maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) right= maxDepth(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        max_d= max(max_d, left+right);</span><br><span class="line">        <span class="keyword">return</span> max(left, right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$<br>reference:<br><a href="https://goo.gl/PFpQAY" target="_blank" rel="noopener">https://goo.gl/PFpQAY</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>349. Intersection of Two Arrays</title>
      <link href="/2018/08/21/349-Intersection-of-Two-Arrays/"/>
      <url>/2018/08/21/349-Intersection-of-Two-Arrays/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two arrays, write a function to compute their intersection.</p><p>Example 1:</p><p>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2]<br>Example 2:</p><p>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [9,4]<br>Note:</p><p>Each element in the result must be unique.<br>The result can be in any order.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="comment">//chekc how many distinct element are the same</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; check(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check.count(n))&#123;</span><br><span class="line">                res.push_back(n);</span><br><span class="line">                check.erase(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/ov6Mgb" target="_blank" rel="noopener">https://goo.gl/ov6Mgb</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> easy </tag>
            
            <tag> hash table </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>215. Kth Largest Element in an Array</title>
      <link href="/2018/08/21/215-Kth-Largest-Element-in-an-Array/"/>
      <url>/2018/08/21/215-Kth-Largest-Element-in-an-Array/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5<br>Example 2:</p><p>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This problem can easily be solved by using STL container, priority queue.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq(nums.begin(), nums.end()); <span class="comment">//put all elements in priority queue</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) </span><br><span class="line">            pq.pop(); <span class="comment">//remove the elements that is greater than Kth element</span></span><br><span class="line">        <span class="keyword">return</span> pq.top(); <span class="comment">//Now the largest one is Kth </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>However, this is not what this question is asking.<br>We can use <code>quick sort</code> to solve this question. The essential part of quick sort is sort the array by a <code>pivot</code>. The pivot will divide the array into two half, one half greater than pivot and the other smaller than pivot.</p><ol><li>Initialize left to be 0 and right to be nums.size() - 1;</li><li>Partition the array, if the pivot is at the k-1-th position, return it (we are done);</li><li>If the pivot is right to the k-1-th position, update right to be the left neighbor of the pivot;</li><li>Else update left to be the right neighbor of the pivot.</li><li>Repeat 2.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//quick sort: find a pivot and partition the list into two half. greater than pivot and smaller than pivot</span></span><br><span class="line">        <span class="comment">//if pivot is k-1th, then return</span></span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> p= sort(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span>(p == k<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums[p];</span><br><span class="line">            <span class="keyword">if</span>(p &lt; k<span class="number">-1</span>)</span><br><span class="line">                left= p+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right= p<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//use left most element as pivot, greater than pivot put left side.</span></span><br><span class="line">        <span class="keyword">int</span> pivot= nums[left]; </span><br><span class="line">        <span class="keyword">int</span> l= left+<span class="number">1</span>, r= right;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt; pivot &amp;&amp; nums[r] &gt; pivot)</span><br><span class="line">                swap(nums[l++], nums[r--]);</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&gt;= pivot)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">if</span>(nums[r]&lt;= pivot)</span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//the nums[r] is greater than nums[left], so need to swap </span></span><br><span class="line">        swap(nums[left], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>space complexity: $O(1)$</p><p>reference:<br><a href="https://goo.gl/R5oX7C" target="_blank" rel="noopener">https://goo.gl/R5oX7C</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> sort </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>143. Reorder List</title>
      <link href="/2018/08/21/143-Reorder-List/"/>
      <url>/2018/08/21/143-Reorder-List/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p><p>Example 1:</p><p>Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.<br>Example 2:</p><p>Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to divide the list into two half. Reverse the second half, then reassemble the list.</p><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cut the list into half</span><br><span class="line">1-2-3-4-5-6</span><br><span class="line">    |     |</span><br><span class="line">   slow  fast</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reverse the second part of the list</span><br><span class="line">1-2-3-4-5-6</span><br><span class="line">    | |    </span><br><span class="line">   mid|  </span><br><span class="line">     pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1-2-3-4-5-6   original</span><br><span class="line"></span><br><span class="line">      4</span><br><span class="line">1-2-3/  &gt; 6   make 4 point to tmp-&gt;next, which is 6</span><br><span class="line">      5</span><br><span class="line"></span><br><span class="line">1-2-3 5-4-6   make 5-&gt;next point to 4</span><br><span class="line">1-2-3-5-4-6   make mid-&gt;next point to 5</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *slow= head, *fast= head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; </span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* middle = slow;</span><br><span class="line">        ListNode* preCurrent = slow-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(preCurrent-&gt;next != <span class="literal">NULL</span>)&#123; <span class="comment">//use preCurrent-&gt;next to determine whether if there's more element need to reverse</span></span><br><span class="line">            </span><br><span class="line">            ListNode *tmp = preCurrent-&gt;next; </span><br><span class="line">            preCurrent-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = middle-&gt;next;</span><br><span class="line">            middle-&gt;next= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        slow = head; <span class="comment">//first part of the list</span></span><br><span class="line">        fast = middle-&gt;next; <span class="comment">//second part of the list</span></span><br><span class="line">        <span class="keyword">while</span>(slow != middle)&#123;</span><br><span class="line">            middle-&gt;next = fast-&gt;next;</span><br><span class="line">            fast-&gt;next= slow-&gt;next;</span><br><span class="line">            slow-&gt;next= fast;</span><br><span class="line">            slow= fast-&gt;next;</span><br><span class="line">            fast= middle-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(1)$</p><p>reference:<br><a href="https://goo.gl/5MyHcY" target="_blank" rel="noopener">https://goo.gl/5MyHcY</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>438. Find All Anagrams in a String</title>
      <link href="/2018/08/21/438-Find-All-Anagrams-in-a-String/"/>
      <url>/2018/08/21/438-Find-All-Anagrams-in-a-String/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.</p><p>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</p><p>The order of output does not matter.</p><p>Example 1:</p><p>Input:<br>s: “cbaebabacd” p: “abc”</p><p>Output:<br>[0, 6]</p><p>Explanation:<br>The substring with start index = 0 is “cba”, which is an anagram of “abc”.<br>The substring with start index = 6 is “bac”, which is an anagram of “abc”.<br>Example 2:</p><p>Input:<br>s: “abab” p: “ab”</p><p>Output:<br>[0, 1, 2]</p><p>Explanation:<br>The substring with start index = 0 is “ab”, which is an anagram of “ab”.<br>The substring with start index = 1 is “ba”, which is an anagram of “ab”.<br>The substring with start index = 2 is “ab”, which is an anagram of “ab”.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findAnagrams(<span class="built_in">string</span> s, <span class="built_in">string</span> p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, m(<span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: p)</span><br><span class="line">            m[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>, count= p.length();</span><br><span class="line">        <span class="keyword">while</span>(right&lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//find a character in s that also appeared in p, then move right pointer and decrease the count</span></span><br><span class="line">            <span class="comment">//if a character is not in p, then the value will be negative</span></span><br><span class="line">            <span class="keyword">if</span>(m[s[right++]]-- &gt;= <span class="number">1</span>) --count; </span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) res.push_back(left); <span class="comment">//the starting index of the anagram</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            an anagram's size would be the same as p.length()</span></span><br><span class="line"><span class="comment">            therefore, if length is equal, then we should move left pointer toward right 1 step</span></span><br><span class="line"><span class="comment">            if the value of character key in map is greater or equal then 0, it means it's a character in p</span></span><br><span class="line"><span class="comment">            because in previous step we minus 1 for all characters, so if a character in s is exists in p, then the value in map is at least 0</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(right-left == p.length() &amp;&amp; m[s[left++]]++ &gt;= <span class="number">0</span>) ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/5yadmE" target="_blank" rel="noopener">https://goo.gl/5yadmE</a><br><a href="https://goo.gl/8XAyZH" target="_blank" rel="noopener">https://goo.gl/8XAyZH</a><br><a href="https://goo.gl/gT32uu" target="_blank" rel="noopener">https://goo.gl/gT32uu</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> easy </tag>
            
            <tag> two pointers </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>76. Minimum Window Substring</title>
      <link href="/2018/08/21/76-Minimum-Window-Substring/"/>
      <url>/2018/08/21/76-Minimum-Window-Substring/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>Example:</p><p>Input: S = “ADOBECODEBANC”, T = “ABC”<br>Output: “BANC”<br>Note:</p><p>If there is no such window in S that covers all characters in T, return the empty string “”.<br>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Since we need to solve this problem in $O(n)$, so we can not use brute force or sorting. We can use a hash table with characters that appeared in T as key, and number of appearance as value.</p><ul><li>walk through T, store in map</li><li>walk through S. If meet a character <code>c</code> appeared in T, map[c]–. Keep going until we have a window that contains every character in T.</li><li>Move the left boundary of the window, skip characters that do not exist in T. Skip a character if it appears in S more that appears in T.<br>example:<br>S: aaaabb<br>T: ab</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T.size() &gt; S.size()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, count = <span class="number">0</span>, minLen = S.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.find(T[i]) != m.end()) ++m[T[i]];</span><br><span class="line">            <span class="keyword">else</span> m[T[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; S.size(); ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.find(S[right]) != m.end()) &#123; <span class="comment">//found a character appeared in both S and T</span></span><br><span class="line">                --m[S[right]];</span><br><span class="line">                <span class="keyword">if</span> (m[S[right]] &gt;= <span class="number">0</span>) ++count;</span><br><span class="line">                <span class="keyword">while</span> (count == T.size()) &#123; <span class="comment">//find a valid window that contains every characters in T</span></span><br><span class="line">                    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                        minLen = right - left + <span class="number">1</span>;</span><br><span class="line">                        res = S.substr(left, minLen);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (m.find(S[left]) != m.end()) &#123;</span><br><span class="line">                        ++m[S[left]]; <span class="comment">//s[left] is a char in T</span></span><br><span class="line">                        <span class="keyword">if</span> (m[S[left]] &gt; <span class="number">0</span>) --count;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/1JwyJD" target="_blank" rel="noopener">https://goo.gl/1JwyJD</a><br><a href="https://goo.gl/pAMsMh" target="_blank" rel="noopener">https://goo.gl/pAMsMh</a><br><a href="https://goo.gl/B6FoMj" target="_blank" rel="noopener">https://goo.gl/B6FoMj</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
            <tag> hash table </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>297. Serialize and Deserialize Binary Tree</title>
      <link href="/2018/08/21/297-Serialize-and-Deserialize-Binary-Tree/"/>
      <url>/2018/08/21/297-Serialize-and-Deserialize-Binary-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p>Example: </p><p>You may serialize the following tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure></p><p>as “[1,2,3,null,null,4,5]”<br>Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use preorder traversal to generate the string and create the tree.</p><ol><li><p>searialize<br>Use stringstream to build the string.<br>Traverse the Tree with preorder traversal<br>Insert empty node as ‘#’, separate the nodes between ‘ ‘.</p></li><li><p>desearialize<br>Since we use preorder to store the tree, use preorder to desearialize it.<br>idea is to use a queue to store all the nodes in data. The istringstream is already a queue and can help to separate string</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//searialize</span></span><br><span class="line">    <span class="comment">//Use stringstream to build the string. Traverse the Tree with preorder traversal. insert empty node as '#', separate the nodes between ' '</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//deserialize</span></span><br><span class="line">    <span class="comment">//idea is to use a queue to store all the nodes in data. The istringstream is already a queue and can help to separate string</span></span><br><span class="line">    <span class="comment">//still use preorder traversal</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        serialize(root, out);</span><br><span class="line">        <span class="keyword">return</span> out.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">ostringstream</span>&amp; out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            out &lt;&lt; root-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            serialize(root-&gt;left, out);</span><br><span class="line">            serialize(root-&gt;right, out);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">        root-&gt;left = deserialize(in);</span><br><span class="line">        root-&gt;right = deserialize(in);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure><p>time complexity: O(n)</p><p>reference:<br><a href="https://goo.gl/xoE4oD" target="_blank" rel="noopener">https://goo.gl/xoE4oD</a><br><a href="https://goo.gl/Gn3Uc2" target="_blank" rel="noopener">https://goo.gl/Gn3Uc2</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> tree </tag>
            
            <tag> amazon </tag>
            
            <tag> linkedin </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>309. Best Time to Buy and Sell Stock with Cooldown</title>
      <link href="/2018/08/20/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/"/>
      <url>/2018/08/20/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><p>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<br>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)<br>Example:</p><p>Input: [1,2,3,0,2]<br>Output: 3<br>Explanation: transactions = [buy, sell, cooldown, buy, sell]</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The key of solving this question is to find out the dp equation.<br>(1) We have to <code>rest</code> before we <code>buy</code> and<br>(2) we have to <code>buy</code> before we <code>sell</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//use two sets of buy&amp; sell to check if there's cooldown</span></span><br><span class="line">        int buy(INT_MIN), sell(0), prev_sell(0), prev_buy(0);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price: prices)&#123;</span><br><span class="line">            prev_buy = buy; </span><br><span class="line">            buy = max(buy, prev_sell-price); <span class="comment">//</span></span><br><span class="line">            prev_sell = sell;</span><br><span class="line">            sell = max(sell, prev_buy+price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link href="/2018/08/20/121-Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/2018/08/20/121-Best-Time-to-Buy-and-Sell-Stock/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Example 1:<br>Input: [7, 1, 5, 3, 6, 4]<br>Output: 5</p><p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)<br>Example 2:<br>Input: [7, 6, 4, 3, 1]<br>Output: 0</p><p>In this case, no transaction is done, i.e. max profit = 0.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minp= prices[<span class="number">0</span>], res= INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; prices.size(); i++)&#123;</span><br><span class="line">            res= max(res, prices[i]- minp);</span><br><span class="line">            minp= min(minp, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res&gt;<span class="number">0</span>? res: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> easy </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>67. Add Binary</title>
      <link href="/2018/08/20/67-Add-Binary/"/>
      <url>/2018/08/20/67-Add-Binary/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two binary strings, return their sum (also a binary string).</p><p>The input strings are both non-empty and contains only characters 1 or 0.</p><p>Example 1:</p><p>Input: a = “11”, b = “1”<br>Output: “100”<br>Example 2:</p><p>Input: a = “1010”, b = “1011”<br>Output: “10101”</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to start from the end of string and add every bit.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i= a.length()<span class="number">-1</span>, j= b.length()<span class="number">-1</span>, carry= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res= <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x= i&gt;= <span class="number">0</span> &amp;&amp; a[i--]== <span class="string">'1'</span>;</span><br><span class="line">            <span class="keyword">int</span> y= j&gt;= <span class="number">0</span> &amp;&amp; b[j--]== <span class="string">'1'</span>;</span><br><span class="line">            res= to_string((x+y+carry)%<span class="number">2</span>)+ res;</span><br><span class="line">            carry= (x+y+carry)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(carry)</span><br><span class="line">            res= to_string(carry)+res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(max(m, n))$<br>space complexity: $O(1)$</p><p>reference:<br><a href="https://goo.gl/93GtDQ" target="_blank" rel="noopener">https://goo.gl/93GtDQ</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> easy </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>283. Move Zeroes</title>
      <link href="/2018/08/20/283-Move-Zeroes/"/>
      <url>/2018/08/20/283-Move-Zeroes/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>Example:</p><p>Input: [0,1,0,3,12]<br>Output: [1,3,12,0,0]<br>Note:</p><p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use a pointer to store the position of zeros, another point to walk through the array.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p_zero= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</span><br><span class="line">                swap(nums[p_zero++], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> easy </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>29. Divide Two Integers</title>
      <link href="/2018/08/20/29-Divide-Two-Integers/"/>
      <url>/2018/08/20/29-Divide-Two-Integers/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.</p><p>Return the quotient after dividing dividend by divisor.</p><p>The integer division should truncate toward zero.</p><p>Example 1:</p><p>Input: dividend = 10, divisor = 3<br>Output: 3<br>Example 2:</p><p>Input: dividend = 7, divisor = -3<br>Output: -2<br>Note:</p><p>Both dividend and divisor will be 32-bit signed integers.<br>The divisor will never be 0.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use bit manipulation to solve this problem. </p><p>Left shift the divisor and get the multiply of it. Also need to check the sign of two numbers<br>example: dividend=15, divisor=3<br>15= 3<em>4+3<br>3= 3</em>1+0</p><p>result= 4+1= 5</p><p>edge cases:</p><ul><li>divisor = 0;</li><li>dividend = INT_MIN and divisor = -1 (because abs(INT_MIN) = INT_MAX + 1).</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        use deduction to get the quotient. </span></span><br><span class="line"><span class="comment">        but deduct one by one is too slow, so we can use shifting to speed up the process</span></span><br><span class="line"><span class="comment">        ex:</span></span><br><span class="line"><span class="comment">        d1: 15, d2: 3</span></span><br><span class="line"><span class="comment">        shift d2 left to get multiply</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!divisor || (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = (dividend&gt; <span class="number">0</span> ^ divisor&gt;<span class="number">0</span>)? <span class="number">-1</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> d1= <span class="built_in">labs</span>(dividend), d2= <span class="built_in">labs</span>(divisor);</span><br><span class="line">        <span class="keyword">while</span>(d1&gt;= d2)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp= d2;</span><br><span class="line">            <span class="keyword">int</span> multiply= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(d1&gt;= tmp&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">                tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                multiply&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            d1-= tmp;</span><br><span class="line">            res+= multiply;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res*sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(logn)$</p><p>reference:<br><a href="https://goo.gl/a5wA7D" target="_blank" rel="noopener">https://goo.gl/a5wA7D</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>621. Task Scheduler</title>
      <link href="/2018/08/19/621-Task-Scheduler/"/>
      <url>/2018/08/19/621-Task-Scheduler/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p><p>However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.</p><p>You need to return the least number of intervals the CPU will take to finish all the given tasks.</p><p>Example 1:<br>Input: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2<br>Output: 8<br>Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.<br>Note:<br>The number of tasks is in the range [1, 10000].<br>The integer n is in the range [0, 100].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to count whether if we need extra idle slots.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">26</span>, <span class="number">0</span>); <span class="comment">//only 26 character</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: tasks) </span><br><span class="line">            <span class="built_in">map</span>[c - <span class="string">'A'</span>]++; <span class="comment">//count which task has the largest frequency</span></span><br><span class="line">        </span><br><span class="line">        sort(<span class="built_in">map</span>.begin(), <span class="built_in">map</span>.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max_val = <span class="built_in">map</span>[<span class="number">25</span>] - <span class="number">1</span>; <span class="comment">//last element do not need cool down</span></span><br><span class="line">        <span class="keyword">int</span> idle_slots = max_val * n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">24</span>; i &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[i] &gt; <span class="number">0</span>; i--) &#123; </span><br><span class="line">            <span class="comment">//already set up the largest one, so start at i=24</span></span><br><span class="line">            idle_slots -= min(<span class="built_in">map</span>[i], max_val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if idle slot &gt; 0, some of the task need extra. </span></span><br><span class="line">        <span class="comment">//idle slot &lt; 0, don't need idle slots</span></span><br><span class="line">        <span class="keyword">return</span> idle_slots &gt; <span class="number">0</span> ? idle_slots + tasks.size() : tasks.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time"></a>Second time</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123;</span><br><span class="line">        /*</span><br><span class="line">        idea: count how many extra idle slot needed.</span><br><span class="line">        1. count which task will be the most.</span><br><span class="line">        2. the last task do not need idle slot, so remember to deduct 1</span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        map&lt;int, int&gt; map;</span><br><span class="line">        </span><br><span class="line">        for(auto c: tasks)&#123;</span><br><span class="line">            map[c-&apos;A&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; after;</span><br><span class="line">        for(auto m: map)&#123;</span><br><span class="line">            after.push_back(m.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sort(after.begin(), after.end());</span><br><span class="line">        int max_val= after[after.size()-1]-1;</span><br><span class="line">        int idle_slot= n* max_val;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        for(int i= after.size()-2; i&gt;= 0; i--)&#123;</span><br><span class="line">            idle_slot-= min(after[i], max_val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return idle_slot &lt; 0? tasks.size(): idle_slot+tasks.size();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/DaFYrA" target="_blank" rel="noopener">https://goo.gl/DaFYrA</a><br><a href="https://goo.gl/unPm4P" target="_blank" rel="noopener">https://goo.gl/unPm4P</a><br><a href="https://goo.gl/JhFQuh" target="_blank" rel="noopener">https://goo.gl/JhFQuh</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> uber </tag>
            
            <tag> queue </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>253. Meeting Rooms II</title>
      <link href="/2018/08/19/253-Meeting-Rooms-II/"/>
      <url>/2018/08/19/253-Meeting-Rooms-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0, 30],[5, 10],[15, 20]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[7,10],[2,4]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea of solving this question is: whenever there is a start meeting, we need to add one room.</p><p>for example, we have meetings that span along time as follows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|_____|</span><br><span class="line">      |______|</span><br><span class="line">|________|</span><br><span class="line">        |_______|</span><br></pre></td></tr></table></figure></p><p>Then, the start time array and end time array after sorting appear like follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">||    ||</span><br><span class="line">     |   |   |  |</span><br></pre></td></tr></table></figure><p>We can use a map to store all the position that have <code>start</code> or <code>end</code>. If there’s a <code>start</code>, we increase <code>1</code> on that position, means that we need a conference room. On the other hand, we decrease <code>1</code> on <code>end</code>, denotes that we finish using a meeting room.</p><p>Then we can use a variable to store <code>current</code> using meeting room, and another variable to store the <code>peak</code> of using meeting rooms.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxroom= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">//to count</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> interval: intervals)&#123;</span><br><span class="line">            <span class="built_in">map</span>[interval.start]++;</span><br><span class="line">            <span class="built_in">map</span>[interval.end]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m: <span class="built_in">map</span>)&#123;</span><br><span class="line">            cur+= m.second;</span><br><span class="line">            maxroom= max(maxroom, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxroom;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$, map use $O(logn)$ for insertion, and n elements.<br>space complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/TQuqvR" target="_blank" rel="noopener">https://goo.gl/TQuqvR</a><br><a href="https://goo.gl/H2uUhe" target="_blank" rel="noopener">https://goo.gl/H2uUhe</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>91. Decode Ways</title>
      <link href="/2018/08/19/91-Decode-Ways/"/>
      <url>/2018/08/19/91-Decode-Ways/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure></p><p>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Explanation: It could be decoded as “AB” (1 2) or “L” (12).<br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p><p>Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a dp array of size n + 1 to store the subproblem solutions.<br>dp[0] means an empty string will have one way to decode.<br>dp[1] means the way to decode a string of size 1. </p><p>For other cases, check one digit(<code>dp[i-1]</code>) and two digit(<code>dp[i-2]</code>) combination and save the results along the way. In the end, dp[n] will be the end result.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        use 1d dp array to sum up how many ways from beginning</span></span><br><span class="line"><span class="comment">        dp[i-1]: 1 digit: can not be zero </span></span><br><span class="line"><span class="comment">        dp[i-2]: 2 digits: can not exceed 26, digit of ten can not be zero</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> n= s.length();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">1</span>; <span class="comment">//empty string only one way to decode</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//since the dp equation needs dp[i-1] and dp[i-2] to calculate</span></span><br><span class="line">        <span class="comment">//we also need to init dp[1]</span></span><br><span class="line">        dp[<span class="number">1</span>]= s[<span class="number">0</span>] == <span class="string">'0'</span>? <span class="number">0</span>:<span class="number">1</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">2</span>; i&lt; dp.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1= stoi(s.substr(i<span class="number">-1</span>, <span class="number">1</span>));</span><br><span class="line">            <span class="comment">//cout&lt;&lt;n1&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">int</span> n2= stoi(s.substr(i<span class="number">-2</span>, <span class="number">2</span>));</span><br><span class="line">            <span class="comment">//cout&lt;&lt;n2&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(n1&gt;= <span class="number">1</span> &amp;&amp; n1 &lt;= <span class="number">9</span>) dp[i]+= dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(n2&gt;= <span class="number">10</span> &amp;&amp; n2 &lt;= <span class="number">26</span>) dp[i]+= dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>65. Valid Number</title>
      <link href="/2018/08/18/65-Valid-Number/"/>
      <url>/2018/08/18/65-Valid-Number/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Validate if a given string is numeric.</p><p>Some examples:<br>“0” =&gt; true<br>“ 0.1 “ =&gt; true<br>“abc” =&gt; false<br>“1 a” =&gt; false<br>“2e10” =&gt; true</p><p>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p><p>Update (2015-02-10):<br>The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This is a problem to let you discuss with interviewer and implement the detail. </p><ol><li>skip the leading whitespaces</li><li>check the positive or negative sign is valid. if there’re two ‘+’ or ‘-‘, it should be invalid.</li><li>To do so, simply skip the leading sign and count the number of digits and the number of points. A valid significand has no more than one point and at least one digit.</li><li>check if the exponent part is valid. We do this if the significand is followed by ‘e’. Simply skip the leading sign and count the number of digits. A valid exponent contain at least one digit.</li><li>skip the trailing whitespaces. We must reach the ending ‘\0’ if the string is a valid number.</li></ol><ul><li>White spaces: may have three cases</li></ul><ol><li>leading white spaces, skip it</li><li>trailing white space, skip it</li><li>white spaces in the middle of string, invalid number</li></ol><ul><li>Decimal point</li></ul><ol><li>can only appear once, but can show in any position. “.3”, “1.e2”, “1.”</li><li>can not showed after <code>e</code>. “1e.1”</li></ol><p>example that can use<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;0&quot;; // True</span><br><span class="line">string s2 = &quot; 0.1 &quot;; // True</span><br><span class="line">string s3 = &quot;abc&quot;; // False, not digit</span><br><span class="line">string s4 = &quot;1 a&quot;; // False, because white space in the middle</span><br><span class="line">string s5 = &quot;2e10&quot;; // True</span><br><span class="line"></span><br><span class="line">string s6 = &quot;-e10&quot;; // False</span><br><span class="line">string s7 = &quot; 2e-9 &quot;; // True</span><br><span class="line">string s8 = &quot;+e1&quot;; // False</span><br><span class="line">string s9 = &quot;1+e&quot;; // False</span><br><span class="line">string s10 = &quot; &quot;; // False</span><br><span class="line"></span><br><span class="line">string s11 = &quot;e9&quot;; // False</span><br><span class="line">string s12 = &quot;4e+&quot;; // False</span><br><span class="line">string s13 = &quot; -.&quot;; // False</span><br><span class="line">string s14 = &quot;+.8&quot;; // True</span><br><span class="line">string s15 = &quot; 005047e+6&quot;; // True</span><br><span class="line"></span><br><span class="line">string s16 = &quot;.e1&quot;; // False</span><br><span class="line">string s17 = &quot;3.e&quot;; // False</span><br><span class="line">string s18 = &quot;3.e1&quot;; // True</span><br><span class="line">string s19 = &quot;+1.e+5&quot;; // True</span><br><span class="line">string s20 = &quot; -54.53061&quot;; // True</span><br><span class="line"></span><br><span class="line">string s21 = &quot;. 1&quot;; // False</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//"1 1"is not valid, "0x11" is not valid, "." is not valid, "2e3.1" is not valid, "2e" is not valid,"1a" is not valid,"++1" is not valid</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// skip the whilespaces</span></span><br><span class="line">        <span class="keyword">while</span>(s[i] == <span class="string">' '</span>) i++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check the significand</span></span><br><span class="line">        <span class="comment">// skip the sign if exist</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) i++; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n_nm= <span class="number">0</span>; <span class="comment">//how many digits</span></span><br><span class="line">        <span class="keyword">int</span> n_pt= <span class="number">0</span>; <span class="comment">//how many decimal points</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[i]) || s[i] == <span class="string">'.'</span>)</span><br><span class="line">            s[i++] == <span class="string">'.'</span> ? n_pt++:n_nm++;       </span><br><span class="line">        <span class="keyword">if</span>(n_pt&gt;<span class="number">1</span> || n_nm&lt;<span class="number">1</span>) <span class="comment">// no more than one point, at least one digit</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check the exponent if exist</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'e'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// skip the sign, " 005047e+6", it should also be true</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) i++; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> n_nm = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                n_nm++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n_nm&lt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip the trailing whitespaces</span></span><br><span class="line">        <span class="keyword">while</span>(s[i] == <span class="string">' '</span>)</span><br><span class="line">            i++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// must reach the ending 0 of the string</span></span><br><span class="line">        <span class="keyword">return</span> s[i]== <span class="string">'\0'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/qsSdzM" target="_blank" rel="noopener">https://goo.gl/qsSdzM</a><br><a href="https://goo.gl/s91yxH" target="_blank" rel="noopener">https://goo.gl/s91yxH</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>10. Regular Expression Matching</title>
      <link href="/2018/08/18/10-Regular-Expression-Matching/"/>
      <url>/2018/08/18/10-Regular-Expression-Matching/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</p><p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p><p>Note:</p><p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.<br>Example 1:</p><p>Input:<br>s = <code>&quot;aa&quot;</code><br>p = <code>&quot;a&quot;</code><br>Output: false<br>Explanation: “a” does not match the entire string <code>&quot;aa&quot;</code>.<br>Example 2:</p><p>Input:<br>s = <code>&quot;aa&quot;</code><br>p = <code>&quot;a*&quot;</code><br>Output: true<br>Explanation: ‘*’ means zero or more of the preceding element, <code>&#39;a&#39;</code>. Therefore, by repeating <code>&#39;a&#39;</code> once, it becomes <code>&quot;aa&quot;</code>.<br>Example 3:</p><p>Input:<br>s = <code>&quot;ab&quot;</code><br>p = <code>&quot;.*&quot;</code><br>Output: true<br>Explanation: “.<em>“ means “zero or more (</em>) of any character (.)”.<br>Example 4:</p><p>Input:<br>s = <code>&quot;aab&quot;</code><br>p = <code>&quot;c*a*b&quot;</code><br>Output: true<br>Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches <code>&quot;aab&quot;</code>.<br>Example 5:</p><p>Input:<br>s = <code>&quot;mississippi&quot;</code><br>p = <code>&quot;mis*is*p*.&quot;</code><br>Output: false</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>create dp array. dp[i][j] to be true if s[0..i) matches p[0..j)</p><ol><li><p>If p[j] == s[i] :  dp[i][j] = dp[i-1][j-1];<br>If the character on position j in string p is equal to the character on position i in string s.</p></li><li><p>If p[j] == ‘.’ : dp[i][j] = dp[i-1][j-1];<br>If the character on position j in string p is a ‘.’, it can match any character, so dp[i][j] follow dp[i-1][j-1].</p></li><li><p>If p[j] == ‘*’:<br>there are two sub conditions:</p><ol><li>if p[j-1] != s[i] : dp[i][j] = dp[i][j-2]  //in this case, $a*$ only counts as empty</li><li>if p[i-1] == s[i] or p[i-1] == ‘.’:<br>dp[i][j] = dp[i-1][j]    //in this case, $a*$ counts as multiple a<br>or dp[i][j] = dp[i][j-1] // in this case, $a*$ counts as single a<br>or dp[i][j] = dp[i][j-2] // in this case, $a*$ counts as empty</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        create dp array. dp[i][j] to be true if s[0..i) matches p[0..j)</span></span><br><span class="line"><span class="comment">        1. edge case</span></span><br><span class="line"><span class="comment">        2. dp array init</span></span><br><span class="line"><span class="comment">        3. </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//edge case, both NULL</span></span><br><span class="line">        <span class="keyword">if</span>(s.empty() &amp;&amp; p.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> r= s.length(), c= p.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(r+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(c+<span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]= <span class="literal">true</span>; <span class="comment">//both empty is true</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; c; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j] == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j<span class="number">-1</span>]) <span class="comment">//previous is the same, current is '*'</span></span><br><span class="line">                dp[<span class="number">0</span>][j+<span class="number">1</span>]= <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; c; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]== p[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>]= dp[i][j];</span><br><span class="line">                <span class="keyword">if</span>(p[j]== <span class="string">'.'</span>) dp[i+<span class="number">1</span>][j+<span class="number">1</span>]= dp[i][j]; <span class="comment">//ex: abc, ab.</span></span><br><span class="line">                <span class="keyword">if</span>(p[j]== <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p[j<span class="number">-1</span>] != <span class="string">'.'</span> &amp;&amp; p[j<span class="number">-1</span>] != s[i]) <span class="comment">//can not use special character to represent any word</span></span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>]= dp[i+<span class="number">1</span>][j<span class="number">-1</span>]; <span class="comment">//the same as </span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>]= (dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(mn)$<br>space complexity: $O(mn)$<br>reference:<br><a href="https://goo.gl/1yJRGK" target="_blank" rel="noopener">https://goo.gl/1yJRGK</a><br><a href="https://goo.gl/sFR26t" target="_blank" rel="noopener">https://goo.gl/sFR26t</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> apple </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>680. Valid Palindrome II</title>
      <link href="/2018/08/18/680-Valid-Palindrome-II/"/>
      <url>/2018/08/18/680-Valid-Palindrome-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.</p><p>Example 1:<br>Input: “aba”<br>Output: True<br>Example 2:<br>Input: “abca”<br>Output: True<br>Explanation: You could delete the character ‘c’.<br>Note:<br>The string will only contain lowercase characters a-z. The maximum length of the string is 50000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Can delete at most one character, implies that the string will not be valid if we delete one character and it does not make a valid palindrome.</p><ol><li>Design a subfunction to check the string is valid or not. </li><li>When we encounter two different characters, we can choose to delete one of them, and check if it’s valid or not.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l= <span class="number">0</span>, r= s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l] != s[r])</span><br><span class="line">                <span class="keyword">return</span> isValid(s, l+<span class="number">1</span>, r) || isValid(s, l, r<span class="number">-1</span>);</span><br><span class="line">            l++; r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            left++; right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>314. Binary Tree Vertical Order Traversal</title>
      <link href="/2018/08/17/314-Binary-Tree-Vertical-Order-Traversal/"/>
      <url>/2018/08/17/314-Binary-Tree-Vertical-Order-Traversal/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a binary tree, return the vertical order traversal of its nodes’ values. (ie, from top to bottom, column by column).</p><p>If two nodes are in the same row and column, the order should be from left to right.</p><p>Examples 1:</p><p>Input: [3,9,20,null,null,15,7]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> /\</span><br><span class="line">/  \</span><br><span class="line">9  20</span><br><span class="line">   /\</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [9],</span><br><span class="line">  [3,15],</span><br><span class="line">  [20],</span><br><span class="line">  [7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Examples 2:</p><p>Input: [3,9,8,4,0,1,7]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   /\</span><br><span class="line">  /  \</span><br><span class="line">  9   8</span><br><span class="line"> /\  /\</span><br><span class="line">/  \/  \</span><br><span class="line">4  01   7</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [4],</span><br><span class="line">  [9],</span><br><span class="line">  [3,0,1],</span><br><span class="line">  [8],</span><br><span class="line">  [7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Examples 3:</p><p>Input: [3,9,8,4,0,1,7,null,null,null,2,5] (0’s right child is 2 and 1’s left child is 5)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   /\</span><br><span class="line">  /  \</span><br><span class="line">  9   8</span><br><span class="line"> /\  /\</span><br><span class="line">/  \/  \</span><br><span class="line">4  01   7</span><br><span class="line">   /\</span><br><span class="line">  /  \</span><br><span class="line">  5   2</span><br></pre></td></tr></table></figure></p><p>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [4],</span><br><span class="line">  [9,5],</span><br><span class="line">  [3,0,1],</span><br><span class="line">  [8,2],</span><br><span class="line">  [7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to construct a map with the vertical index and every value of that level. By using map, we can get ascending index by default.</p><p>Then we use BFS to walk though the tree. If it’s a left node, then the index should be smaller. If it’s a right node, the index should be greater.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode*&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, root&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp= q.front(); q.pop();</span><br><span class="line">            <span class="built_in">map</span>[tmp.first].push_back(tmp.second-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(tmp.second-&gt;left) q.push(&#123;tmp.first<span class="number">-1</span>, tmp.second-&gt;left&#125;);</span><br><span class="line">            <span class="keyword">if</span>(tmp.second-&gt;right) q.push(&#123;tmp.first+<span class="number">1</span>, tmp.second-&gt;right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m: <span class="built_in">map</span>)</span><br><span class="line">            res.push_back(m.second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity:<br>map use $O(log n)$ for insertion, total is n node, so $O(nlogn)$</p><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/5278930.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5278930.html</a><br><a href="https://goo.gl/yfKXEE" target="_blank" rel="noopener">https://goo.gl/yfKXEE</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> bfs </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>301. Remove Invalid Parentheses</title>
      <link href="/2018/08/17/301-Remove-Invalid-Parentheses/"/>
      <url>/2018/08/17/301-Remove-Invalid-Parentheses/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p><p>Note: The input string may contain letters other than the parentheses ( and ).</p><p>Example 1:</p><p>Input: “()())()”<br>Output: [“()()()”, “(())()”]<br>Example 2:</p><p>Input: “(a)())()”<br>Output: [“(a)()()”, “(a())()”]<br>Example 3:</p><p>Input: “)(“<br>Output: [“”]</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question can ask in interview:</p><ol><li>what is invalid, if contains other characters or digits, will it be valid?</li><li>Input type, string</li><li>Output type, should be vector<string></string></li><li>time/space complexity restriction</li></ol><p>Solution:<br>We’re trying to make it valid, we need to remove a ‘)’. And should remove the extra parentheses by <code>counting redundant</code> left or right parentheses. Then use dfs to check if the string is valid or not.</p><ol><li><p>Check input is valid or not by using variable to count left parentheses and right parentheses.<br><code>count(&#39;(&#39;) &gt;= count(&#39;)&#39;)</code>, i&lt; n-1. Before reach to end of string, count of left parentheses should always be greater or equal than right parentheses. Because if right has more then left, it would be invalid.<br><code>count(&#39;(&#39;) == count(&#39;)&#39;)</code>, i == n-1. When reach to the end, if it’s a valid string, number of left == number of right.</p></li><li><p>Use dfs to check “if we remove extra parentheses, the string is valid or not”. </p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; removeInvalidParentheses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        1. count redundant left or right parentheses</span></span><br><span class="line"><span class="comment">        2. dfs to find after remove parentheses, the string would be valid or not. One thing to notice is to skip duplicate character</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i= <span class="number">0</span>, l= <span class="number">0</span>, r= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l == <span class="number">0</span>) r++;</span><br><span class="line">                <span class="keyword">else</span> l--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        helper(s, <span class="number">0</span>, l, r, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> cnt1, <span class="keyword">int</span> cnt2, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s)) res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//check duplicate</span></span><br><span class="line">            <span class="keyword">if</span>(i != start &amp;&amp; s[i] == s[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt1 &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">'('</span>) </span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i)+ s.substr(i+<span class="number">1</span>), i, cnt1<span class="number">-1</span>, cnt2, res);</span><br><span class="line">            <span class="keyword">if</span>(cnt2 &gt; <span class="number">0</span> &amp;&amp; s[i] == <span class="string">')'</span>)</span><br><span class="line">                helper(s.substr(<span class="number">0</span>, i)+ s.substr(i+<span class="number">1</span>), i, cnt1, cnt2<span class="number">-1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">')'</span>)</span><br><span class="line">                right++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(right&gt; left) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(2 ^ {l+r})$<br>space complexity: $O((l+r)^2)$ ~ $O(n^2)$</p><p>reference:<br><a href="https://goo.gl/KgYdwq" target="_blank" rel="noopener">https://goo.gl/KgYdwq</a><br><a href="https://goo.gl/p61yqa" target="_blank" rel="noopener">https://goo.gl/p61yqa</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>273. Integer to English Words</title>
      <link href="/2018/08/16/273-Integer-to-English-Words/"/>
      <url>/2018/08/16/273-Integer-to-English-Words/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.</p><p>Example 1:</p><p>Input: 123<br>Output: “One Hundred Twenty Three”<br>Example 2:</p><p>Input: 12345<br>Output: “Twelve Thousand Three Hundred Forty Five”<br>Example 3:</p><p>Input: 1234567<br>Output: “One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven”<br>Example 4:</p><p>Input: 1234567891<br>Output: “One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One”</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question can ask in interview:</p><ol><li>What format is the integer? contain dots? floating number?</li><li>Input type, integer/string</li><li>Output type, should be string</li><li>time/space complexity restriction</li></ol><p>The hint from this question, <code>Group the number by thousands (3 digits). Write a helper function that takes a number less than 1000 and convert just that chunk to words.</code></p><ol><li><p>use some example to demonstrate how to set up the array.<br>1~19, all different words<br>20~99, different words too<br>100~999, can be constructed by previous two with <code>&quot;Hundred&quot;</code>.<br>greater than 1000, can use previous three with <code>&quot;Thousand&quot;, &quot;Million&quot;, &quot;Billion&quot;</code>.</p></li><li><p>After creating the dictionary, we can try to divide the question into smaller pieces. Since the result with <code>num</code> greater than 1000 are similar, we can use a helper function to construct strings less than 1000.</p></li><li><p>Dealing with <code>num</code> greater than thousands. The pattern is to divide <code>num</code> with 1000 multiple times and counting how many 1000 we have divided.</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; less_than_20= &#123;<span class="string">""</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>, <span class="string">"Four"</span>, <span class="string">"Five"</span>, <span class="string">"Six"</span>, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>, <span class="string">"Ten"</span>, <span class="string">"Eleven"</span>, <span class="string">"Twelve"</span>, <span class="string">"Thirteen"</span>, <span class="string">"Fourteen"</span>, <span class="string">"Fifteen"</span>, <span class="string">"Sixteen"</span>, <span class="string">"Seventeen"</span>, <span class="string">"Eighteen"</span>, <span class="string">"Nineteen"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tens= &#123;<span class="string">""</span>, <span class="string">"Ten"</span>, <span class="string">"Twenty"</span>, <span class="string">"Thirty"</span>, <span class="string">"Forty"</span>, <span class="string">"Fifty"</span>, <span class="string">"Sixty"</span>, <span class="string">"Seventy"</span>, <span class="string">"Eighty"</span>, <span class="string">"Ninety"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; thousands= &#123;<span class="string">""</span>, <span class="string">"Thousand"</span>, <span class="string">"Million"</span>, <span class="string">"Billion"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Zero"</span>;</span><br><span class="line">        <span class="keyword">int</span> i= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res= <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(num&gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">1000</span> != <span class="number">0</span>)</span><br><span class="line">                res= helper(num%<span class="number">1000</span>)+ thousands[i]+ <span class="string">" "</span>+ res;</span><br><span class="line">            num /= <span class="number">1000</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.substr(<span class="number">0</span>, res.find_last_not_of(<span class="string">' '</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">20</span>)</span><br><span class="line">            <span class="keyword">return</span> less_than_20[num]+ <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">return</span> tens[num/<span class="number">10</span>]+ <span class="string">" "</span>+ helper(num%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> less_than_20[num/<span class="number">100</span>]+ <span class="string">" Hundred "</span>+ helper(num%<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(1)$, because the length of <code>num</code> is limited and the loop will be called constant number of times.</p><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/4772780.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4772780.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> amazon </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>17. Letter Combinations of a Phone Number</title>
      <link href="/2018/08/16/17-Letter-Combinations-of-a-Phone-Number/"/>
      <url>/2018/08/16/17-Letter-Combinations-of-a-Phone-Number/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a digit string, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p><p>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This question is a relatively easy backtracking problem. The idea of backtracking is to find the end result of a branch, then move back one step and search for other results. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dict&#123;<span class="string">" "</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> tmp= <span class="string">""</span>;</span><br><span class="line">        helper(res, tmp, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span> tmp, <span class="built_in">string</span>&amp; digits, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; digits.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num= digits[index]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: dict[num])&#123;</span><br><span class="line">            helper(res, tmp+c, digits, index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/o1acNw" target="_blank" rel="noopener">https://goo.gl/o1acNw</a><br><a href="https://goo.gl/HBP2MX" target="_blank" rel="noopener">https://goo.gl/HBP2MX</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>152. Maximum Product Subarray</title>
      <link href="/2018/08/15/152-Maximum-Product-Subarray/"/>
      <url>/2018/08/15/152-Maximum-Product-Subarray/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a <code>res</code> variable to denote the maximum result to return. In addition, two variables <code>imin</code> and <code>imax</code> for to store current maximum value and current minimum value. Why do we need to store the minimum value? The smallest product, which is the largest in the negative sense could become the maximum when being multiplied by a negative number.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// store the result that is the max we have found so far</span></span><br><span class="line">        <span class="keyword">int</span> r = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// imax/imin stores the max/min product of</span></span><br><span class="line">        <span class="comment">// subarray that ends with the current number A[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, imax = r, imin = r; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// multiplied by a negative makes big number smaller, small number bigger</span></span><br><span class="line">            <span class="comment">// so we redefine the extremums by swapping them</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>)</span><br><span class="line">                swap(imax, imin);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// max/min product for the current number is either the current number itself</span></span><br><span class="line">            <span class="comment">// or the max/min by the previous number times the current one</span></span><br><span class="line">            imax = max(nums[i], imax * nums[i]);</span><br><span class="line">            imin = min(nums[i], imin * nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// the newly computed max value is a candidate for our global result</span></span><br><span class="line">            r = max(r, imax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/Eu7Vb4" target="_blank" rel="noopener">https://goo.gl/Eu7Vb4</a><br><a href="https://goo.gl/fDPzc1" target="_blank" rel="noopener">https://goo.gl/fDPzc1</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>516. Longest Palindromic Subsequence</title>
      <link href="/2018/08/13/516-Longest-Palindromic-Subsequence/"/>
      <url>/2018/08/13/516-Longest-Palindromic-Subsequence/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p><p>Example 1:<br>Input: “bbbab”<br>Output: 4<br>One possible longest palindromic subsequence is “bbbb”.</p><p>Example 2:<br>Input: “cbbd”<br>Output: 2<br>One possible longest palindromic subsequence is “bb”.</p><h3 id="Solution1-DFS"><a href="#Solution1-DFS" class="headerlink" title="Solution1 DFS:"></a>Solution1 DFS:</h3><p>Use a 2D array and two pointers to check longest palindromic subsequence. memo[i][j] means the longest palindromic subsequence on between <code>i</code> and <code>j</code>.</p><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b b b a b</span><br><span class="line">  i     j</span><br></pre></td></tr></table></figure></p><p>if s[i] == s[j], the length would increase 2.<br><code>memo[start][end]= helper(s, start+1, end-1, memo)+2;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b b b a b</span><br><span class="line">  i   j</span><br></pre></td></tr></table></figure><p>if s[i]!= s[j], the length should be <code>max(memo[i+1][j], memo[i][j-1])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n= s.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> helper(s, <span class="number">0</span>, n<span class="number">-1</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo[start][end] != <span class="number">-1</span>) <span class="keyword">return</span> memo[start][end];</span><br><span class="line">        <span class="keyword">if</span>(start&gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s[start] == s[end])</span><br><span class="line">            memo[start][end]= helper(s, start+<span class="number">1</span>, end<span class="number">-1</span>, memo)+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            memo[start][end]= max(helper(s, start+<span class="number">1</span>, end, memo), helper(s, start, end<span class="number">-1</span>, memo));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> memo[start][end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2-DP"><a href="#Solution2-DP" class="headerlink" title="Solution2 DP:"></a>Solution2 DP:</h3><p>Similar to previous idea. Use a pointer <code>i</code> to denote the length that we traverse right now. Another pointer <code>j</code> to denote check the palindromic substring.</p><p>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b b b a b</span><br><span class="line">  j i</span><br></pre></td></tr></table></figure></p><p><code>dp[i][j]= dp[i-1][j+1]+2</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b b b a b</span><br><span class="line">  j   i</span><br></pre></td></tr></table></figure><p><code>dp[i][j]= max(dp[i-1][j], dp[i][j+1])</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.length(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            dp[i][i]= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= i<span class="number">-1</span>; j&gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">                    dp[i][j]= dp[i<span class="number">-1</span>][j+<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]= max(dp[i<span class="number">-1</span>][j], dp[i][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>647. Palindromic Substrings</title>
      <link href="/2018/08/13/647-Palindromic-Substrings/"/>
      <url>/2018/08/13/647-Palindromic-Substrings/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string, your task is to count how many palindromic substrings in this string.</p><p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p><p>Example 1:<br>Input: “abc”<br>Output: 3<br>Explanation: Three palindromic strings: “a”, “b”, “c”.<br>Example 2:<br>Input: “aaa”<br>Output: 6<br>Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.<br>Note:<br>The input string length won’t exceed 1000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Use a variable <code>count</code> to calculate the total palindrome substring.<br>One thing to notice about palindrome string is that, the center of a palindrome string could be character or middle of two characters. Therefore, we need to check twice.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            expand(s, i, i);</span><br><span class="line">            expand(s, i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s[left]==s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n^2)$<br>space complexity: O(1)<br>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> pure storage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>227. Basic Calculator II</title>
      <link href="/2018/08/11/227-Basic-Calculator-II/"/>
      <url>/2018/08/11/227-Basic-Calculator-II/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.</p><p>Example 1:</p><p>Input: “3+2*2”<br>Output: 7<br>Example 2:</p><p>Input: “ 3/2 “<br>Output: 1<br>Example 3:</p><p>Input: “ 3+5 / 2 “<br>Output: 5<br>Note:</p><p>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The idea is to use <code>stack</code> to store every signed numbers in it. One thing to notice is that we need to use a variable to denote positive of first digit. Whenever we reach to <code>second operator</code>, we can definitely push the previous result into stack. For example:</p><p> -1+2 : the sign was initially <code>-</code>. When we meet second <code>+</code>, we can push <code>-1</code> into the stack. then set sign to <code>+</code></p><p>Therefore, we need a <code>stack</code> to store calculated value. <code>sign</code> to store a sign that waited to be calculated. <code>tmp</code> is current value.</p><p>Example: <code>3+5/2</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       init-&gt; 0 -&gt; 1  -&gt; 2 -&gt; 3   -&gt; 4(reach to end)</span><br><span class="line">stack:  []-&gt;  []-&gt; [3]-&gt;[3]-&gt;[3,5]-&gt;[3,5] become [3,2] after calculation</span><br><span class="line">sign:   + -&gt;  + -&gt; +  -&gt; + -&gt; /   -&gt; 2</span><br><span class="line">tmp:    0 -&gt;  3 -&gt; 0  -&gt; 5 -&gt; 0   -&gt; 0</span><br><span class="line"></span><br><span class="line">Then, just add up value in stack.</span><br><span class="line">3+2 = 5</span><br></pre></td></tr></table></figure></p><p><img src="IMG_5534.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">char</span> sign= <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>, tmp= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">                tmp= <span class="number">10</span>*tmp+s[i]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; !<span class="built_in">isspace</span>(s[i]) || i == s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'-'</span>)</span><br><span class="line">                    stk.push(-tmp);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'+'</span>)</span><br><span class="line">                    stk.push(tmp);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> num;</span><br><span class="line">                    <span class="keyword">if</span>(sign == <span class="string">'*'</span>)</span><br><span class="line">                        num= stk.top()*tmp;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        num= stk.top()/tmp;</span><br><span class="line">                    stk.pop();</span><br><span class="line">                    stk.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign= s[i];</span><br><span class="line">                tmp= <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            res+= stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)<br>space complexity: O(n)</p><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/4601208.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4601208.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> uber </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>332. Reconstruct Itinerary</title>
      <link href="/2018/08/10/332-Reconstruct-Itinerary/"/>
      <url>/2018/08/10/332-Reconstruct-Itinerary/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p><p>Note:</p><p>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.<br>All airports are represented by three capital letters (IATA code).<br>You may assume all tickets form at least one valid itinerary.<br>Example 1:<br>Input: tickets = <code>[[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</code><br>Output: <code>[&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</code></p><p>Example 2:<br>Input: tickets = <code>[[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</code><br>Output: <code>[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code><br>Explanation: Another possible reconstruction is <code>[&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</code>. But it is larger in lexical order.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>We can first show an example with the graph.</p><p><img style="width: 50%; height: 50%" src="1.jpg"></p><p>After we have the graph, we can use DFS to solve the problem. We traverse down a path until it stuck, then we go back to previous node and traverse other paths of previous node.</p><p>We can use <code>unordered_map</code> to store the paths. <code>multiset</code> can use to help sorting the incoming tickets in smaller lexical order.<br><img style="width: 50%; height: 50%" src="2.jpg"></p><p>The step goes like this:</p><ol><li>construct the graph</li><li>start visit “JFK”</li><li>if “JFK” has paths, then start from the first one, and erase it. To erase it is because we visit the path, if we come back later, we’ll then traverse the second path from “JFK”.</li><li>The result is in reverse order. </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findItinerary(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; tickets) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: tickets)&#123;</span><br><span class="line">            <span class="built_in">map</span>[n.first].insert(n.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="built_in">map</span>, <span class="string">"JFK"</span>, res);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; <span class="built_in">map</span>, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">map</span>[s].size())&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp= *<span class="built_in">map</span>[s].begin();</span><br><span class="line">            <span class="built_in">map</span>[s].erase(<span class="built_in">map</span>[s].begin());</span><br><span class="line">            dfs(<span class="built_in">map</span>, tmp, res);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/xDedxi" target="_blank" rel="noopener">https://goo.gl/xDedxi</a><br><a href="http://www.cnblogs.com/grandyang/p/5183210.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5183210.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> graph </tag>
            
            <tag> yelp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>207. Course Schedule</title>
      <link href="/2018/08/08/207-Course-Schedule/"/>
      <url>/2018/08/08/207-Course-Schedule/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p><p>Example 1:</p><p>Input: 2, [[1,0]]<br>Output: true<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0. So it is possible.<br>Example 2:</p><p>Input: 2, [[1,0],[0,1]]<br>Output: false<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0, and to take course 0 you should<br>             also have finished course 1. So it is impossible.<br>Note:</p><p>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p><h3 id="Solution1-DFS"><a href="#Solution1-DFS" class="headerlink" title="Solution1 DFS:"></a>Solution1 DFS:</h3><p>We can use DFS to solve this question. From above example, <code>Input: 2, [[1,0],[0,1]]</code>, we can see that if the graph contains a <code>cycle</code>, we can not finish all the courses. </p><p>First of all, let’s see how we generate a graph. we can use a <code>vector&lt;unordered_set&gt;</code> to do so. Every index stores the courses that can be taken after finish the <code>index</code> course. </p><p>Second, we need to traverse the graph and find if there’s any cycle. The idea of finding a cycle is to record the nodes that we’ve already traversed on current path. If we encounter a node that we’ve already traversed, then it must contains a cycle in the graph. After current path is checked, reset it to <code>false</code>.</p><p>Third, another visited array to store which node is already traversed. help to save time.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. create a graph for dfs</span></span><br><span class="line"><span class="comment">        2. if we can find a cycle, then we can not finish all courses. </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: prerequisites)&#123;</span><br><span class="line">            graph[n.second].insert(n.first); </span><br><span class="line">            <span class="comment">// [1, 0]: To take course 1 you should have finished course 0</span></span><br><span class="line">            <span class="comment">// So we need an edge from 0-&gt;1, because we need to get to 0 then 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(numCourses, <span class="literal">false</span>), onpath(numCourses, <span class="literal">false</span>); <span class="comment">//the second one is to check cycle</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; dfscycle(graph, visited, onpath, i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfscycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; onpath, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[index]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//already traversed this node in big picture</span></span><br><span class="line">        </span><br><span class="line">        onpath[index]= visited[index]= <span class="literal">true</span>; <span class="comment">//set to true denoted that we traverse this node</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor: graph[index])&#123; <span class="comment">//check all next level as node index is the prerequist</span></span><br><span class="line">            <span class="keyword">if</span>(onpath[neighbor] || dfscycle(graph, visited, onpath, neighbor)) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//1. onpath[neighbor] is true, means that this neighbor is already in this subpath, so we have a cycle</span></span><br><span class="line">            <span class="comment">//2. dfscycle, go further and find a cycle in subpath</span></span><br><span class="line">        &#125;</span><br><span class="line">        onpath[index]= <span class="literal">false</span>; <span class="comment">//reset to false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Solution2-BFS"><a href="#Solution2-BFS" class="headerlink" title="Solution2 BFS:"></a>Solution2 BFS:</h3><p>The BFS solution is to apply topological sort. The idea is to check if every node does not have any indegree after we traverse the graph. </p><p>First, we need to generate a graph. Pretty similar to DFS solution above.<br>Second, we need a indegree array, size is numCourses. Add one if a course have prerequisite.<br>  After calculated the indegree, some of the node might not have any indegree, so we start to traverse from them.</p><p>Third, BFS. If a node’s indegree becomes <code>zero</code>, then we need to push it into the queue.<br>Finally, check indegree array to see if all zero.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//BFS</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. calculate indegree for every node</span></span><br><span class="line"><span class="comment">        2. BFS, push every node with indegree 0 into queue</span></span><br><span class="line"><span class="comment">        3. check if every node has indegree 0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(numCourses);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: prerequisites)&#123;</span><br><span class="line">            indegree[n.first]++;</span><br><span class="line">            graph[n.second].push_back(n.first);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp= q.front(); q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; !graph[tmp].empty() &amp;&amp; i&lt; graph[tmp].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--indegree[graph[tmp][i]] == <span class="number">0</span>) q.push(graph[tmp][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://www.youtube.com/watch?v=zkTOIVUdW-I" target="_blank" rel="noopener">https://www.youtube.com/watch?v=zkTOIVUdW-I</a><br><a href="https://goo.gl/iN1qG3" target="_blank" rel="noopener">https://goo.gl/iN1qG3</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
            <tag> amazon </tag>
            
            <tag> graph </tag>
            
            <tag> topological sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>402. Remove K Digits</title>
      <link href="/2018/08/02/402-Remove-K-Digits/"/>
      <url>/2018/08/02/402-Remove-K-Digits/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.</p><p>Note:<br>The length of num is less than 10002 and will be ≥ k.<br>The given num does not contain any leading zero.<br>Example 1:</p><p>Input: num = “1432219”, k = 3<br>Output: “1219”<br>Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.<br>Example 2:</p><p>Input: num = “10200”, k = 1<br>Output: “200”<br>Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.<br>Example 3:</p><p>Input: num = “10”, k = 2<br>Output: “0”<br>Explanation: Remove all the digits from the number and it is left with nothing which is 0.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Question to ask:</p><ol><li>what to output if there’s no digits left?</li><li>Are there any character other than digits?</li><li>Output type</li><li></li></ol><p>Use a string as a stack, push_back every digit that is smaller than <code>res.back()</code>. </p><p>example:<br>num: “12311421”<br>k: 3</p><p>1<br>12<br>123<br>11<br>111<br>1114<br>1112<br>11121</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res= <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n= num.length(), keep= n-k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: num)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k &amp;&amp; res.size() &amp;&amp; res.back()&gt; c)&#123;</span><br><span class="line">                <span class="comment">//if 1st digit is greater than second digit, it will get remove too</span></span><br><span class="line">                res.pop_back();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">        res.resize(keep); <span class="comment">//if only 1 digit and remove 1 digit, then resize res to 0</span></span><br><span class="line">        <span class="keyword">while</span>(!res.empty() &amp;&amp; res[<span class="number">0</span>] == <span class="string">'0'</span>) res.erase(res.begin());</span><br><span class="line">        <span class="keyword">return</span> res.empty()? <span class="string">"0"</span>: res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$<br>reference:<br><a href="https://goo.gl/8fQRQR" target="_blank" rel="noopener">https://goo.gl/8fQRQR</a><br><a href="http://www.cnblogs.com/grandyang/p/5883736.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5883736.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>767. Reorganize String</title>
      <link href="/2018/08/02/767-Reorganize-String/"/>
      <url>/2018/08/02/767-Reorganize-String/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.</p><p>If possible, output any possible result.  If not possible, return the empty string.</p><p>Example 1:</p><p>Input: S = “aab”<br>Output: “aba”<br>Example 2:</p><p>Input: S = “aaab”<br>Output: “”<br>Note:</p><p>S will consist of lowercase letters and have length in range [1, 500].</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>When we first see this problem, we should use an example to walk through it, and we can see that we need to know what character has the greatest occurrence in the string.</p><ol><li>Use an unordered_map to count occurrence</li><li>Use priority queue to store the occurrence, it will automatically sort it. </li><li>Put the character into the result string, take <code>2 different character</code> at a time, this can ensure the outcome will not have same adjacent character.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reorganizeString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. count the frequency of each char</span></span><br><span class="line"><span class="comment">        2. put into priority queue</span></span><br><span class="line"><span class="comment">        3. the top 2 elements in queue must be the most frequently element, put them into result string first</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: S)</span><br><span class="line">            <span class="built_in">map</span>[c]++;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: <span class="built_in">map</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n.second&gt; (S.length()+<span class="number">1</span>)/<span class="number">2</span>) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">//Pigeonhole principal </span></span><br><span class="line">            q.push(&#123;n.second, n.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(q.size()&gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp1= q.top(); q.pop();</span><br><span class="line">            <span class="keyword">auto</span> tmp2= q.top(); q.pop();</span><br><span class="line">            res.push_back(tmp1.second);</span><br><span class="line">            res.push_back(tmp2.second);</span><br><span class="line">            <span class="keyword">if</span>(--tmp1.first &gt; <span class="number">0</span>) q.push(tmp1);</span><br><span class="line">            <span class="keyword">if</span>(--tmp2.first &gt; <span class="number">0</span>) q.push(tmp2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!q.empty())</span><br><span class="line">            res.push_back(q.top().second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> uber </tag>
            
            <tag> heap </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>452. Minimum Number of Arrows to Burst Balloons</title>
      <link href="/2018/08/02/452-Minimum-Number-of-Arrows-to-Burst-Balloons/"/>
      <url>/2018/08/02/452-Minimum-Number-of-Arrows-to-Burst-Balloons/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p><p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p><p>Example:</p><p>Input:<br><code>[[10,16], [2,8], [1,6], [7,12]]</code></p><p>Output:<br>2</p><p>Explanation:<br>One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>The question is saying that we have many balloons, which might overlap, and how many arrows make them burst.<br>Take the example from question, the graph would look like this.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    ---(2,8)---            ---(10,16)---</span><br><span class="line">  ---(1,6)---       ---(7,12)---</span><br><span class="line">|-------------------------------------------|</span><br></pre></td></tr></table></figure><p>From the graph, it’s easy to come out with the answer that we need two arrows. So let’s transfer it to code.</p><ol><li>We need to sort the input <code>points</code>, and we can use STL sorting directly. Since the STL sorting pairs will sort the first element in advance, if the first element are equal, then it’ll sort based on second element.</li><li>We can see that if the <code>end</code> value overlaps other’s <code>start</code> value, we can use one arrow to burst them.</li><li>If a balloon’s <code>start</code> is greater than current <code>end</code> value, then we need a new arrow.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(points.begin(), points.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">1</span>, end= points[<span class="number">0</span>].second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; points.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i].first&lt;= end)</span><br><span class="line">                <span class="comment">//can cover ith balloon</span></span><br><span class="line">                end= min(end, points[i].second);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//can not use previous arrow to shot current balloon, need new arrow</span></span><br><span class="line">                res++;</span><br><span class="line">                end= points[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(nlogn)$<br>reference:<br><a href="http://www.cnblogs.com/grandyang/p/6050562.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/6050562.html</a><br><a href="https://goo.gl/oBHFYw" target="_blank" rel="noopener">https://goo.gl/oBHFYw</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>763. Partition Labels</title>
      <link href="/2018/08/01/763-Partition-Labels/"/>
      <url>/2018/08/01/763-Partition-Labels/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p><p>Example 1:<br>Input: S = “ababcbacadefegdehijhklij”<br>Output: [9,7,8]<br>Explanation:<br>The partition is “ababcbaca”, “defegde”, “hijhklij”.<br>This is a partition so that each letter appears in at most one part.<br>A partition like “ababcbacadefegde”, “hijhklij” is incorrect, because it splits S into less parts.<br>Note:</p><p>S will have length in range [1, 500].<br>S will consist of lowercase letters (‘a’ to ‘z’) only.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>Use an unordered_map to store the last position of occurred character.</li><li>Traverse the array, remember the maximum of last position for every showing character.</li><li>If current position is the last position of a character, then make a cut.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; partitionLabels(<span class="built_in">string</span> S) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; S.length(); i++)</span><br><span class="line">            <span class="built_in">map</span>[S[i]]= i;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> last= <span class="number">0</span>, start= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; S.length(); i++)&#123;</span><br><span class="line">            last= max(last, <span class="built_in">map</span>[S[i]]);</span><br><span class="line">            <span class="keyword">if</span>(i == last)&#123;</span><br><span class="line">                <span class="comment">//find a cutting point where this character will not appear in the folowing string anymore</span></span><br><span class="line">                res.push_back(i- start+<span class="number">1</span>);</span><br><span class="line">                start= i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/8654822.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/8654822.html</a><br><a href="https://goo.gl/HRrkCn" target="_blank" rel="noopener">https://goo.gl/HRrkCn</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>232. Implement Queue using Stacks</title>
      <link href="/2018/08/01/232-Implement-Queue-using-Stacks/"/>
      <url>/2018/08/01/232-Implement-Queue-using-Stacks/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Implement the following operations of a queue using stacks.</p><p>push(x) – Push element x to the back of queue.<br>pop() – Removes the element from in front of queue.<br>peek() – Get the front element.<br>empty() – Return whether the queue is empty.<br>Example:</p><p>MyQueue queue = new MyQueue();</p><p>queue.push(1);<br>queue.push(2);<br>queue.peek();  // returns 1<br>queue.pop();   // returns 1<br>queue.empty(); // returns false<br>Notes:</p><p>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.<br>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.<br>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This question is basically showing the understanding of data structure. We can use two stacks to help while we <code>push</code> into the stack. If you face this question in a interview, start with the difference with <code>queue(FIFO)</code> and <code>stack(FILO)</code>. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            tmp.push(stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.push(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!tmp.empty())&#123;</span><br><span class="line">            stk.push(tmp.top());</span><br><span class="line">            tmp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp= stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>Time complexity:<br>push: $O(n)$, pop: $O(1)$, peek: $O(1)$, isEmpty: $O(1)$<br>Space Complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/4fv6iQ" target="_blank" rel="noopener">https://goo.gl/4fv6iQ</a><br><a href="https://goo.gl/KqsRJT" target="_blank" rel="noopener">https://goo.gl/KqsRJT</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> microsoft </tag>
            
            <tag> apple </tag>
            
            <tag> easy </tag>
            
            <tag> amazon </tag>
            
            <tag> stack </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>439. Ternary Expression Parser</title>
      <link href="/2018/08/01/439-Ternary-Expression-Parser/"/>
      <url>/2018/08/01/439-Ternary-Expression-Parser/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively).</p><p>Note:</p><p>The length of the given string is ≤ 10000.<br>Each number will contain only one digit.<br>The conditional expressions group right-to-left (as usual in most languages).<br>The condition will always be either T or F. That is, the condition will never be a digit.<br>The result of the expression will always evaluate to either a digit 0-9, T or F.<br>Example 1:</p><p>Input: <code>&quot;T?2:3&quot;</code></p><p>Output: <code>&quot;2&quot;</code></p><p>Explanation: If true, then result is 2; otherwise result is 3.<br>Example 2:</p><p>Input: <code>&quot;F?1:T?4:5&quot;</code></p><p>Output: <code>&quot;4&quot;</code></p><p>Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   &quot;(F ? 1 : (T ? 4 : 5))&quot;                   &quot;(F ? 1 : (T ? 4 : 5))&quot;</span><br><span class="line">-&gt; &quot;(F ? 1 : 4)&quot;                 or       -&gt; &quot;(T ? 4 : 5)&quot;</span><br><span class="line">-&gt; &quot;4&quot;                                    -&gt; &quot;4&quot;</span><br></pre></td></tr></table></figure></p><p>Example 3:<br>Input: <code>&quot;T?T?F:5:3&quot;</code><br>Output: <code>&quot;F&quot;</code></p><p>Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   &quot;(T ? (T ? F : 5) : 3)&quot;                   &quot;(T ? (T ? F : 5) : 3)&quot;</span><br><span class="line">-&gt; &quot;(T ? F : 3)&quot;                 or       -&gt; &quot;(T ? F : 5)&quot;</span><br><span class="line">-&gt; &quot;F&quot;                                    -&gt; &quot;F&quot;</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">parseTernary</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= expression.length()<span class="number">-1</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">char</span> c= expression[i]; <span class="comment">//current condition</span></span><br><span class="line">            <span class="keyword">if</span>(!stk.empty() &amp;&amp; stk.top() == <span class="string">'?'</span>)&#123;</span><br><span class="line">                stk.pop(); <span class="comment">//pop out the '?'</span></span><br><span class="line">                <span class="keyword">char</span> first= stk.top();</span><br><span class="line">                stk.pop(); <span class="comment">//pop out first digit</span></span><br><span class="line">                stk.pop(); <span class="comment">//pop out ':'</span></span><br><span class="line">                <span class="keyword">char</span> second= stk.top();</span><br><span class="line">                stk.top()= (c== <span class="string">'T'</span>)? first: second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stk.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="number">1</span>, stk.top());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/jKfet6" target="_blank" rel="noopener">https://goo.gl/jKfet6</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>255. Verify Preorder Sequence in Binary Search Tree</title>
      <link href="/2018/08/01/255-Verify-Preorder-Sequence-in-Binary-Search-Tree/"/>
      <url>/2018/08/01/255-Verify-Preorder-Sequence-in-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.</p><p>You may assume each number in the sequence is unique.</p><p>Consider the following binary search tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure></p><p>Example 1:</p><p>Input: <code>[5,2,6,1,3]</code><br>Output: false<br>Example 2:</p><p>Input: <code>[5,2,1,3,6]</code><br>Output: true<br>Follow up:<br>Could you do it using only constant space complexity?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>Walk through the preorder traversal, <code>left subtree value &lt; root&#39;s value &lt; right subtree&#39;s value</code></li><li>We can see that, <code>root value&lt; upcoming right value in the array</code></li><li>If we know the root value, we can use it to determine whether if upcoming value is valid. So we use a <code>lower</code> to denote the lower_bound, which is also the root value, of the tree.</li><li>Use a stack to store the array from <code>root</code> to <code>left subtree</code>, whenever reach a node has greater value, pop value out of stack. Then store the last pop out value as lower bound.</li></ol><p><img src="255.png" width="50%" height="50%"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Push 50</span><br><span class="line">Push 17 </span><br><span class="line">Push 9</span><br><span class="line">(read 14, 14 &gt; 9)</span><br><span class="line">Pop 9 (lower bound = 9)</span><br><span class="line">Push 14</span><br><span class="line">Push 12</span><br><span class="line">(read 23, 23 &gt; 12)</span><br><span class="line">Pop 12</span><br><span class="line">Pop 14</span><br><span class="line">Pop 17 (lower bound = 17)</span><br><span class="line">Push 23</span><br><span class="line">(read 76, 76 &gt; 23)</span><br><span class="line">Pop 23</span><br><span class="line">Pop 50 (lowerbound = 50)</span><br><span class="line">Push 76</span><br><span class="line">Push 54</span><br><span class="line">(read 72, 72 &gt; 54)</span><br><span class="line">Pop 54 (lower bound = 54)</span><br><span class="line">Push 72</span><br><span class="line">Push 67</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> lower_bound= INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: preorder)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&lt; lower_bound)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; n&gt; stk.top())&#123;</span><br><span class="line">                lower_bound= stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>131. Palindrome Partitioning</title>
      <link href="/2018/07/30/131-Palindrome-Partitioning/"/>
      <url>/2018/07/30/131-Palindrome-Partitioning/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of s.</p><p>Example:</p><p>Input: “aab”<br>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This is a similar backtracking problem. For this kind of question, we’ll use a <code>helper</code> function to help us check every possible sequence meet the requirement or not. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. a sub function to check is palindrome or not</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        helper(res, tmp, s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp, <span class="built_in">string</span> s, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start== s.length())&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ispalin(s, start, i))&#123;</span><br><span class="line">                tmp.push_back(s.substr(start, i-start+<span class="number">1</span>));</span><br><span class="line">                helper(res, tmp, s, i+<span class="number">1</span>);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ispalin</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(start&lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start++] != s[end--])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n*n!)</p><p>reference:<br><a href="https://goo.gl/bBS1Eh" target="_blank" rel="noopener">https://goo.gl/bBS1Eh</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> uber </tag>
            
            <tag> pure storage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>77. Combinations</title>
      <link href="/2018/07/30/77-Combinations/"/>
      <url>/2018/07/30/77-Combinations/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p>Example:</p><p>Input: n = 4, k = 2<br>Output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This is a very basic backtracking problem. We can use a helper function to do the work. The only input is <code>start</code>, which denotes where is current position in the <code>1...n</code> sequence.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        use backtracking, when a temp vector&lt;int&gt; have size k, store then backtracking</span></span><br><span class="line"><span class="comment">        another input is start pos.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        helper(res, tmp, n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k== <span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt;= n; i++)&#123;</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">            helper(res, tmp, n, k<span class="number">-1</span>, i+<span class="number">1</span>);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>306. Additive Number</title>
      <link href="/2018/07/30/306-Additive-Number/"/>
      <url>/2018/07/30/306-Additive-Number/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Additive number is a string whose digits can form additive sequence.</p><p>A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p><p>Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number.</p><p>Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p><p>Example 1:</p><p>Input: “112358”<br>Output: true<br>Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.<br>             1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8<br>Example 2:</p><p>Input: “199100199”<br>Output: true<br>Explanation: The additive sequence is: 1, 99, 100, 199.<br>             1 + 99 = 100, 99 + 100 = 199<br>Follow up:<br>How would you handle overflow for very large input integers?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>think about how to devide the string. it should be three part.</li><li>need a sub function for add string.</li><li>a sub function to check if three strings can form additive sequence.</li></ol><p>draw a graph to help understand and test.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAdditiveNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. think about how to devide the string. it should be three part.</span></span><br><span class="line"><span class="comment">        2. need a sub function for add string.</span></span><br><span class="line"><span class="comment">        3. a sub function to check if three strings can form additive sequence.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= num.length()/<span class="number">2</span>; i++)&#123; <span class="comment">//start from 1 is because substr is [0, i)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;= (num.length()-i)/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(check(num.substr(<span class="number">0</span>, i), num.substr(i, j), num.substr(i+j))) <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2, <span class="built_in">string</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.length()&gt; <span class="number">1</span> &amp;&amp; num1[<span class="number">0</span>] == <span class="string">'0'</span> || num2.length()&gt; <span class="number">1</span> &amp;&amp; num2[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">string</span> sum = add(num1, num2);</span><br><span class="line">        <span class="keyword">if</span>(sum == num3) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//can not divide num3 to sum because length of sum is larger, return false</span></span><br><span class="line">        <span class="comment">//num3 does not contain equal string of sum in itself, return false</span></span><br><span class="line">        <span class="keyword">if</span>(sum.length() &gt;= num3.length() || num3.substr(<span class="number">0</span>, sum.length()) != sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//recursively find following string</span></span><br><span class="line">            <span class="keyword">return</span> check(num2, sum, num3.substr(sum.length()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. start from right to left, then reverse the string</span></span><br><span class="line"><span class="comment">        2. make sure the carry is added</span></span><br><span class="line"><span class="comment">        3. use (char - '0') to calculate digits</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> sum= <span class="number">0</span>, carry= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n= num1.length()<span class="number">-1</span>, m= num2.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;= <span class="number">0</span> ||m &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            sum= carry+ (n&gt;= <span class="number">0</span> ? num1[n--]-<span class="string">'0'</span>: <span class="number">0</span>)+ (m&gt;= <span class="number">0</span>? num2[m--]-<span class="string">'0'</span>: <span class="number">0</span>);</span><br><span class="line">            res.push_back(sum%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">            carry= sum/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry) res.push_back(carry+ <span class="string">'0'</span>);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/eQGcxW" target="_blank" rel="noopener">https://goo.gl/eQGcxW</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> epic system </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note-Docker</title>
      <link href="/2018/07/29/note-Docker/"/>
      <url>/2018/07/29/note-Docker/</url>
      <content type="html"><![CDATA[<p>Docker presents in the entire software development workflow, but mainly use in deployment.<br><img src="img1.png" alt=""></p><p>Dockerfile: describe the dependency<br>create docker image<br>run-time instance of docker image<br>docker hub: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a><br>reference:<br><a href="https://www.youtube.com/user/dockerrun" target="_blank" rel="noopener">https://www.youtube.com/user/dockerrun</a><br><a href="https://www.udemy.com/understanding-docker-performing-selenium-automation/" target="_blank" rel="noopener">https://www.udemy.com/understanding-docker-performing-selenium-automation/</a></p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>89. Gray Code</title>
      <link href="/2018/07/29/89-Gray-Code/"/>
      <url>/2018/07/29/89-Gray-Code/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p><p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p><p>Example 1:</p><p>Input: 2<br>Output: [0,1,3,2]<br>Explanation:<br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2</p><p>For a given n, a gray code sequence may not be uniquely defined.<br>For example, [0,2,3,1] is also a valid gray code sequence.</p><p>00 - 0<br>10 - 2<br>11 - 3<br>01 - 1<br>Example 2:</p><p>Input: 0<br>Output: [0]<br>Explanation: We define the gray code sequence to begin with 0.<br>             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.<br>             Therefore, for n = 0 the gray code sequence is [0].</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>So we start with the <code>k-1</code>th bit from the right. We first do not do anything to it. See we have already initialized a 32-bit bitset (which is essentially a boolean array) with all <code>0</code>s. Without doing anything to this bit, we call the <code>helper</code> function to do the next task with <code>k+1</code> that is to do the next bit after it. It goes on till we reach the <code>zero</code>th bit. We now have bitset containing the bits we selected at those positions. NOW, we backtrack. Next up after calling helper is, you see, we do a flip. So we flip the 0 and make it a 1 or vice versa and we do the same operation again. We choose. We explore. We unchoose.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;32&gt; bits;</span><br><span class="line">        helper(res, bits, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;&amp; bits, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k== <span class="number">0</span>) res.push_back(bits.to_ulong());</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            helper(res, bits, k<span class="number">-1</span>); <span class="comment">//get 0000 0000 first</span></span><br><span class="line">            bits.flip(k<span class="number">-1</span>);   <span class="comment">//change to 0000 0001</span></span><br><span class="line">            helper(res, bits, k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/VBu5Bc" target="_blank" rel="noopener">https://goo.gl/VBu5Bc</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>784. Letter Case Permutation</title>
      <link href="/2018/07/29/784-Letter-Case-Permutation/"/>
      <url>/2018/07/29/784-Letter-Case-Permutation/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.</p><p>Examples:<br>Input: S = “a1b2”<br>Output: <code>[&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</code></p><p>Input: S = “3z4”<br>Output: <code>[&quot;3z4&quot;, &quot;3Z4&quot;]</code></p><p>Input: S = “12345”<br>Output: <code>[&quot;12345&quot;]</code><br>Note:</p><p>S will be a string with length at most 12.<br>S will consist only of letters or digits.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>use toupper and tolower function in c++</li><li>backtracking function(int start, res, string)</li><li>for every character in S, determine if it’s number or letter</li><li>backtrack the string</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCasePermutation(<span class="built_in">string</span> S) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(res, S, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == s.length())&#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c= s[pos]; <span class="comment">//initial character</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">            helper(res, s, pos+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            helper(res, s, pos+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isupper</span>(c))&#123; <span class="comment">//1A</span></span><br><span class="line">                s[pos]= <span class="built_in">tolower</span>(s[pos]); <span class="comment">//change to 1a</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//1a</span></span><br><span class="line">                s[pos]= <span class="built_in">toupper</span>(s[pos]); <span class="comment">//change to 1A</span></span><br><span class="line">            &#125;</span><br><span class="line">            helper(res, s, pos+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="http://www.cplusplus.com/reference/cctype/isdigit/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/cctype/isdigit/</a><br><a href="https://goo.gl/NCcQDz" target="_blank" rel="noopener">https://goo.gl/NCcQDz</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> yelp </tag>
            
            <tag> east </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>401. Binary Watch</title>
      <link href="/2018/07/29/401-Binary-Watch/"/>
      <url>/2018/07/29/401-Binary-Watch/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p><p>Each LED represents a zero or one, with the least significant bit on the right.</p><p><img src="401.jpg" alt=""></p><p>For example, the above binary watch reads “3:25”.</p><p>Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p><p>Example:</p><p>Input: n = 1<br>Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]<br>Note:<br>The order of output does not matter.<br>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.<br>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>We can use backtracking to solve this problem. </p><ol><li>Think <code>hours</code> and <code>minutes</code> as a combined array.</li><li>Like a combination problem. If we want to pick <code>n</code> elements from <code>hours</code> and <code>minutes</code>, we will pick <code>n-i</code> elements from <code>minutes</code> while we pick <code>i</code> elements from <code>hours</code>.</li></ol><ul><li>example: if n= 2:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&quot;3:00&quot;,&quot;5:00&quot;,&quot;9:00&quot;,&quot;1:01&quot;,&quot;1:02&quot;, ...]`</span><br><span class="line"> 1+2:00 ,1+4:00,1+8:00, 1:01</span><br><span class="line">                        i=4(equal to hour.size())</span><br><span class="line">                        generate minute then call helper again</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hour = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>&#125;, minute = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; readBinaryWatch(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        helper(res, make_pair(<span class="number">0</span>, <span class="number">0</span>), num, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; time, <span class="keyword">int</span> num, <span class="keyword">int</span> start_point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(to_string(time.first) +  (time.second &lt; <span class="number">10</span> ?  <span class="string">":0"</span> : <span class="string">":"</span>) + to_string(time.second));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start_point; i &lt; hour.size() + minute.size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (i &lt; hour.size()) &#123;    </span><br><span class="line">                time.first += hour[i];</span><br><span class="line">                <span class="keyword">if</span> (time.first &lt; <span class="number">12</span>)     helper(res, time, num - <span class="number">1</span>, i + <span class="number">1</span>);     <span class="comment">// "hour" should be less than 12.</span></span><br><span class="line">                time.first -= hour[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;     </span><br><span class="line">                time.second += minute[i - hour.size()];</span><br><span class="line">                <span class="keyword">if</span> (time.second &lt; <span class="number">60</span>)    helper(res, time, num - <span class="number">1</span>, i + <span class="number">1</span>);     <span class="comment">// "minute" should be less than 60.</span></span><br><span class="line">                time.second -= minute[i - hour.size()];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> easy </tag>
            
            <tag> bit manipulation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>186. Reverse Words in a String II</title>
      <link href="/2018/07/27/186-Reverse-Words-in-a-String-II/"/>
      <url>/2018/07/27/186-Reverse-Words-in-a-String-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an input string , reverse the string word by word. </p><p>Example:</p><p>Input:  <code>[&quot;t&quot;,&quot;h&quot;,&quot;e&quot;,&quot; &quot;,&quot;s&quot;,&quot;k&quot;,&quot;y&quot;,&quot; &quot;,&quot;i&quot;,&quot;s&quot;,&quot; &quot;,&quot;b&quot;,&quot;l&quot;,&quot;u&quot;,&quot;e&quot;]</code><br>Output: <code>[&quot;b&quot;,&quot;l&quot;,&quot;u&quot;,&quot;e&quot;,&quot; &quot;,&quot;i&quot;,&quot;s&quot;,&quot; &quot;,&quot;s&quot;,&quot;k&quot;,&quot;y&quot;,&quot; &quot;,&quot;t&quot;,&quot;h&quot;,&quot;e&quot;]</code><br>Note: </p><p>A word is defined as a sequence of non-space characters.<br>The input string does not contain leading or trailing spaces.<br>The words are always separated by a single space.<br>Follow up: Could you do it in-place without allocating extra space?</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>We can reverse the string first, then use two pointers to find space <code>&#39; &#39;</code>. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; str)</span> </span>&#123;</span><br><span class="line">        reverse(str.begin(), str.end());</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= <span class="number">0</span>, n= str.size();</span><br><span class="line">        <span class="keyword">while</span>(right&lt; n)&#123;</span><br><span class="line">            <span class="keyword">while</span>(right&lt; n &amp;&amp; str[right]!= <span class="string">' '</span>) right++;</span><br><span class="line">            reverse(str.begin()+left, str.begin()+right);</span><br><span class="line">            left= ++right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$</p><p>reference:<br><a href="https://goo.gl/mLq9PF" target="_blank" rel="noopener">https://goo.gl/mLq9PF</a><br><a href="https://goo.gl/PztRhh" target="_blank" rel="noopener">https://goo.gl/PztRhh</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>350. Intersection of Two Arrays II</title>
      <link href="/2018/07/26/350-Intersection-of-Two-Arrays-II/"/>
      <url>/2018/07/26/350-Intersection-of-Two-Arrays-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given two arrays, write a function to compute their intersection.</p><p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p><p>Note:<br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.<br>Follow up:</p><ul><li>What if the given array is already sorted? How would you optimize your algorithm?</li><li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li><li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li></ul><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>For this question, we can easily use an unordered_map to count the number that appear in nums1. Then walk through the nums2, and store the same number to the result.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dict;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)nums1.size(); i++) </span><br><span class="line">            dict[nums1[i]]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)nums2.size(); i++)</span><br><span class="line">            <span class="keyword">if</span>(dict.find(nums2[i]) != dict.end() &amp;&amp; --dict[nums2[i]] &gt;= <span class="number">0</span>) </span><br><span class="line">        </span><br><span class="line">        res.push_back(nums2[i]);            </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Follow up:</p><ul><li><p>What if the given array is already sorted? How would you optimize your algorithm?<br>If the array is already sorted, we can use binary search to speed up the process. </p></li><li><p>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?<br>It’s better to use the smaller array to construct the counter hash.</p></li><li><p>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?<br>Divide and conquer. Repeat the process frequently: Slice nums2 to fit into memory, process (calculate intersections), and write partial results to memory.</p></li></ul><p>reference:<br><a href="https://goo.gl/CqspgR" target="_blank" rel="noopener">https://goo.gl/CqspgR</a><br><a href="https://goo.gl/rewNgE" target="_blank" rel="noopener">https://goo.gl/rewNgE</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> google </tag>
            
            <tag> easy </tag>
            
            <tag> hash table </tag>
            
            <tag> binary search </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>60. Permutation Sequence</title>
      <link href="/2018/07/26/60-Permutation-Sequence/"/>
      <url>/2018/07/26/60-Permutation-Sequence/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p><p>By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>Given n and k, return the kth permutation sequence.</p><p>Note:</p><p>Given n will be between 1 and 9 inclusive.<br>Given k will be between 1 and n! inclusive.<br>Example 1:</p><p>Input: n = 3, k = 3<br>Output: “213”<br>Example 2:</p><p>Input: n = 4, k = 9<br>Output: “2314”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># Solution:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factorial(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">string</span> res;</span><br><span class="line">            <span class="keyword">int</span> sum= <span class="number">1</span>;</span><br><span class="line">            factorial[<span class="number">0</span>]= <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line">                sum*= i;</span><br><span class="line">                factorial[i]= sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// factorial[] = &#123;1, 1, 2, 6, 24, ... n!&#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line">                numbers.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// numbers = &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">            </span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> index= k/factorial[n-i];</span><br><span class="line">                res+= to_string(numbers[index]);</span><br><span class="line">                numbers.erase(numbers.begin()+ index);</span><br><span class="line">                k-= index*factorial[n-i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/guWjyp" target="_blank" rel="noopener">https://goo.gl/guWjyp</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>37. Sudoku Solver</title>
      <link href="/2018/07/26/37-Sudoku-Solver/"/>
      <url>/2018/07/26/37-Sudoku-Solver/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy all of the following rules:</p><p>Each of the digits 1-9 must occur exactly once in each row.<br>Each of the digits 1-9 must occur exactly once in each column.<br>Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.<br>Empty cells are indicated by the character ‘.’.</p><p><img src="1.png" alt=""><br>A sudoku puzzle…</p><p><img src="2.png" alt=""><br>…and its solution numbers marked in red.</p><p>Note:</p><p>The given board contain only digits 1-9 and the character ‘.’.<br>You may assume that the given Sudoku puzzle will have a single unique solution.<br>The given board size is always 9x9.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>For this question, we can use recursive/backtracking to solve it. </p><ol><li>Find a <code>&#39;.&#39;</code> location that need to fill in a number</li><li>Check if this position can be filled in with some number. The checking can be done by scanning the same row, the same column, the same 3*3 box.</li><li>If we can fill the position with a number, then we use recursive to find next <code>&#39;.&#39;</code> position to be filled. One thing to notice is that, when we do the recursive, we might found out that this current result is false. At this time, we can use backtracking to previous level, and try to put other number in the previous position.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. find location, '.', to check </span></span><br><span class="line"><span class="comment">        2. determine what number can this position use. </span></span><br><span class="line"><span class="comment">            By checking whether if same row || same column || same box, have this number.</span></span><br><span class="line"><span class="comment">        3. after filling this position, we can pass this board to the recursive and check next '.' to be filled.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(board.empty() || board[<span class="number">0</span>].size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; board.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; board[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]== <span class="string">'.'</span>)&#123; <span class="comment">//a location needs to be filled</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c= <span class="string">'1'</span>; c&lt;= <span class="string">'9'</span>; c++)&#123; <span class="comment">//try from 1 through 9</span></span><br><span class="line">                        <span class="keyword">if</span>(isValid(board, i, j, c))&#123; <span class="comment">//check if this 'c' can put in the position</span></span><br><span class="line">                            board[i][j]= c; <span class="comment">//put c into the location</span></span><br><span class="line">                          <span class="keyword">if</span>(solve(board)) <span class="comment">//if this is the solution</span></span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                board[i][j]= <span class="string">'.'</span>; <span class="comment">//go back and try another char</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] != <span class="string">'.'</span> &amp;&amp; board[i][col]== c) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//check row by row, found c is already used</span></span><br><span class="line">            <span class="keyword">if</span>(board[row][i] != <span class="string">'.'</span> &amp;&amp; board[row][i]== c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> boxR= <span class="number">3</span>*(row/<span class="number">3</span>)+ i/<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> boxC= <span class="number">3</span>*(col/<span class="number">3</span>)+ i%<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[boxR][boxC] != <span class="string">'.'</span> &amp;&amp; board[boxR][boxC]== c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://www.youtube.com/watch?v=b6CxF17Y_k4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=b6CxF17Y_k4</a><br><a href="https://goo.gl/PaqSwh" target="_blank" rel="noopener">https://goo.gl/PaqSwh</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>249. Group Shifted Strings</title>
      <link href="/2018/07/25/249-Group-Shifted-Strings/"/>
      <url>/2018/07/25/249-Group-Shifted-Strings/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence:</p><p>“abc” -&gt; “bcd” -&gt; … -&gt; “xyz”<br>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p><p>Example:</p><p>Input: [“abc”, “bcd”, “acef”, “xyz”, “az”, “ba”, “a”, “z”],<br>Output:<br>[<br>  [“abc”,”bcd”,”xyz”],<br>  [“az”,”ba”],<br>  [“acef”],<br>  [“a”,”z”]<br>]</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>Find a way to determine whether if two word are the same pattern. We can do it by checking the difference for each character in the word. This result can use as a key to store every word who has same pattern.</li><li>Then we can use an unordered_map to store the <code>key</code> and value <code>vector&lt;string&gt;</code>, which is the words that have equal pattern.</li></ol><p>For example:<br>for a string s of length n, we encode its shifting feature as “s[1] - s[0], s[2] - s[1], …, s[n - 1] - s[n - 2],”.<br>if we have <code>abc</code> and <code>efg</code>. We can find out that,<br>distance of <code>a</code> and <code>b</code> is 1, distance of <code>b</code> and <code>c</code> is 1.<br>distance of <code>e</code> and <code>f</code> is 1, distance of <code>f</code> and <code>g</code> is 1.<br>Therefore, these two words are the same pattern.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupStrings(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. find out how to find the pattern for each words, we can calculate the diff between every word</span></span><br><span class="line"><span class="comment">        2. use the diff as key, the same words as value</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s: strings)</span><br><span class="line">            <span class="built_in">map</span>[shift(s)].push_back(s);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s: <span class="built_in">map</span>)&#123;</span><br><span class="line">            res.push_back(s.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">shift</span><span class="params">(<span class="built_in">string</span> input)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; input.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> diff= input[i]-input[i<span class="number">-1</span>];</span><br><span class="line">            res+= diff&lt; <span class="number">0</span> ? diff+<span class="number">26</span>: diff;</span><br><span class="line">            res+= <span class="string">','</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h1><p>more concise code. add 26 to the diff and mod it afterward.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupStrings(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strings) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; res;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : strings) &#123;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : a) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if((c-a[0]) &lt; 0)</span></span><br><span class="line"><span class="comment">                t+= ((c-a[0]+26) + ',');</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                t+= ((c-a[0]) + ',');</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            </span><br><span class="line">            t += (((c+ <span class="number">26</span> - a[<span class="number">0</span>]) % <span class="number">26</span>) + <span class="string">','</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>[t].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> m: <span class="built_in">map</span>)</span><br><span class="line">        res.push_back(m.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> google </tag>
            
            <tag> apple </tag>
            
            <tag> medium </tag>
            
            <tag> uber </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>244. Shortest Word Distance II</title>
      <link href="/2018/07/25/244-Shortest-Word-Distance-II/"/>
      <url>/2018/07/25/244-Shortest-Word-Distance-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. Your method will be called repeatedly many times with different parameters. </p><p>Example:<br>Assume that words = <code>[&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]</code>.</p><p>Input: word1 = “coding”, word2 = “practice”<br>Output: 3<br>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The problem is relatively simple, but this is a design question, so you have to collect as much information as you need from the interviewer. For example, does the input contains any duplicate elements? if it does, we need to use a <code>vector&lt;int&gt;</code> to store the index of same word.</p><h1 id="basic-solution"><a href="#basic-solution" class="headerlink" title="basic solution:"></a>basic solution:</h1><p>in the search part, the time complexity is <code>O(MN)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WordDistance(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i) &#123;</span><br><span class="line">        m[words[i]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortest</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m[word1].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m[word2].size(); ++j) &#123;</span><br><span class="line">            res = min(res, <span class="built_in">abs</span>(m[word1][i] - m[word2][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time complexity: O(MN)</p><h1 id="improved-solution"><a href="#improved-solution" class="headerlink" title="improved solution:"></a>improved solution:</h1><p>We can improve the above solution by using two pointers to find the smallest result.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">    WordDistance(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; words.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[words[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortest</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> vec1= <span class="built_in">map</span>[word1];</span><br><span class="line">        <span class="keyword">auto</span> vec2= <span class="built_in">map</span>[word2];</span><br><span class="line">        <span class="keyword">int</span> res= INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>, j= <span class="number">0</span>; i&lt; vec1.size()&amp;&amp; j&lt; vec2.size();)&#123;</span><br><span class="line">            <span class="keyword">int</span> idx1= vec1[i];</span><br><span class="line">            <span class="keyword">int</span> idx2= vec2[j];</span><br><span class="line">            <span class="keyword">if</span>(idx1&lt; idx2)&#123;</span><br><span class="line">                res= min(res, idx2-idx1);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res= min(res, idx1-idx2);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: O(m+n)</p><h1 id="more-concise-solution"><a href="#more-concise-solution" class="headerlink" title="more concise solution:"></a>more concise solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WordDistance(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            m[words[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortest</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, res = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m[word1].size() &amp;&amp; j &lt; m[word2].size()) &#123;</span><br><span class="line">            res = min(res, <span class="built_in">abs</span>(m[word1][i] - m[word2][j]));</span><br><span class="line">            m[word1][i] &lt; m[word2][j] ? ++i : ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(m+n)<br>reference:<br><a href="https://goo.gl/BkmZXc" target="_blank" rel="noopener">https://goo.gl/BkmZXc</a><br><a href="http://www.cnblogs.com/grandyang/p/5187640.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5187640.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> medium </tag>
            
            <tag> uber </tag>
            
            <tag> hash table </tag>
            
            <tag> linkedin </tag>
            
            <tag> design </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>739. Daily Temperatures</title>
      <link href="/2018/07/25/739-Daily-Temperatures/"/>
      <url>/2018/07/25/739-Daily-Temperatures/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.</p><p>For example, given the list temperatures = <code>[73, 74, 75, 71, 69, 72, 76, 73]</code>, your output should be <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.</p><p>Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range <code>[30, 100]</code>.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The start of this idea is to walk through every element in the array. We put every element in the stack, and if we get to a new temperature that is higher than stack.top(), then we can start to pop out the elements in the stack, until stack.top() is greater than new temperature.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dailyTemperatures(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(temperatures.size(), <span class="number">0</span>);</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> index= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty() &amp;&amp; index&lt; temperatures.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; temperatures[index] &gt; temperatures[stk.top()])&#123;</span><br><span class="line">                res[stk.top()]= index-stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: O(n)<br>space complexity: O(n)</p><p>reference:<br><a href="https://goo.gl/cYiBN3" target="_blank" rel="noopener">https://goo.gl/cYiBN3</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>149. Max Points on a Line</title>
      <link href="/2018/07/25/149-Max-Points-on-a-Line/"/>
      <url>/2018/07/25/149-Max-Points-on-a-Line/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p><p>Example 1:</p><p>Input: <code>[[1,1],[2,2],[3,3]]</code><br>Output: 3<br>Explanation:</p><pre><code>^||        o|     o|  o  +-------------&gt;0  1  2  3  4</code></pre><p>Example 2:</p><p>Input: <code>[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</code><br>Output: 4<br>Explanation:</p><pre><code>^||  o|     o        o|        o|  o        o+-------------------&gt;0  1  2  3  4  5  6</code></pre><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>basic solution:<br>Calculate slope for two points to find whether if they are on the same line, the solution is <code>O(n^2)</code>. First of all, we can divide the points into three groups, exact same point, one the same vertical, or general slope. However, this can not pass one test case, so need to improve based on it.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Failed on case: [[0,0],[94911151,94911150],[94911152,94911151]]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; &amp;points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> samePoint = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y)&#123;</span><br><span class="line">                samePoint++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(points[i].x == points[j].x)&#123;</span><br><span class="line">                <span class="built_in">map</span>[INT_MAX]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">double</span> slope = <span class="keyword">double</span>(points[i].y - points[j].y) / <span class="keyword">double</span>(points[i].x - points[j].x);</span><br><span class="line">                <span class="built_in">map</span>[slope]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> localMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = <span class="built_in">map</span>.begin(); it != <span class="built_in">map</span>.end(); it++)&#123;</span><br><span class="line">            localMax = max(localMax, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        localMax += samePoint;</span><br><span class="line">        result = max(result, localMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Previous solution have a major problem. First, the slope is not concise because if may exceed the number that <code>double</code> can express. Therefore, we can find the greatest common divisor(GCD) to avoid the issue. We calculate every GCD and use it to divide the <code>dx</code> and <code>dy</code>.<br>For example: if we have <code>[8,4]</code>, <code>[4,2]</code>, <code>[2,1]</code> to be our slope, these three slopes will be counted into one map value.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a point.</span></span><br><span class="line"><span class="comment">* struct Point &#123;</span></span><br><span class="line"><span class="comment">*     int x;</span></span><br><span class="line"><span class="comment">*     int y;</span></span><br><span class="line"><span class="comment">*     Point() : x(0), y(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">*     Point(int a, int b) : x(a), y(b) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. devide the points into three groups:</span></span><br><span class="line"><span class="comment">            a. same point</span></span><br><span class="line"><span class="comment">            b. general slope</span></span><br><span class="line"><span class="comment">        2. count every slope for two points, O(n^2)</span></span><br><span class="line"><span class="comment">        3. the slope may have divided by zero problem, so use pair&lt;int, int&gt; to avoid that. In addition, find greatest common divisor to get accurate slope.</span></span><br><span class="line"><span class="comment">        4. add the same points to the localResult</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">int</span> duplicate = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y) &#123;</span><br><span class="line">                    ++duplicate; <span class="keyword">continue</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">int</span> dx = points[j].x - points[i].x;</span><br><span class="line">                <span class="keyword">int</span> dy = points[j].y - points[i].y;</span><br><span class="line">                <span class="keyword">int</span> d = gcd(dx, dy);</span><br><span class="line">                ++m[&#123;dx / d, dy / d&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, duplicate);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = m.begin(); it != m.end(); ++it) &#123;</span><br><span class="line">                res = max(res, it-&gt;second + duplicate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b == <span class="number">0</span>) ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://goo.gl/YRuLmT" target="_blank" rel="noopener">https://goo.gl/YRuLmT</a><br><a href="http://www.cnblogs.com/grandyang/p/4579693.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4579693.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>57. Insert Interval</title>
      <link href="/2018/07/25/57-Insert-Interval/"/>
      <url>/2018/07/25/57-Insert-Interval/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p><p>You may assume that the intervals were initially sorted according to their start times.</p><p>Example 1:</p><p>Input: intervals = <code>[[1,3],[6,9]]</code>, newInterval = <code>[2,5]</code><br>Output: <code>[[1,5],[6,9]]</code><br>Example 2:</p><p>Input: intervals = <code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval = <code>[4,8]</code><br>Output: <code>[[1,2],[3,10],[12,16]]</code><br>Explanation: Because the new interval <code>[4,8]</code> overlaps with <code>[3,5]</code>,<code>[6,7]</code>,<code>[8,10]</code>.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This is a follow up for . </p><ol><li>Create a vector for storing result.</li><li>If an end of an interval does not greater than newInterval’s start, then we know they are not intersecting. Since the input is sorted, we can put these into the result first.</li><li>If an interval’s start is smaller than newInterval’s end, then they must intersect.</li></ol><p><img style="width: 100%; height: 100%" src="57.png"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for an interval.</span></span><br><span class="line"><span class="comment">* struct Interval &#123;</span></span><br><span class="line"><span class="comment">*     int start;</span></span><br><span class="line"><span class="comment">*     int end;</span></span><br><span class="line"><span class="comment">*     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">*     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; insert(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> index= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(index&lt; intervals.size() &amp;&amp; intervals[index].end &lt; newInterval.start)&#123;</span><br><span class="line">            res.push_back(intervals[index++]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index&lt; intervals.size() &amp;&amp; newInterval.end&gt;= intervals[index].start)&#123;</span><br><span class="line">            newInterval.start= min(intervals[index].start, newInterval.start);</span><br><span class="line">            newInterval.end= max(intervals[index].end, newInterval.end);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(newInterval);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index&lt; intervals.size())</span><br><span class="line">            res.push_back(intervals[index++]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: O(n)</p><p>reference:<br><a href="https://goo.gl/5stsBW" target="_blank" rel="noopener">https://goo.gl/5stsBW</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
            <tag> uber </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>126. Word Ladder II</title>
      <link href="/2018/07/24/126-Word-Ladder-II/"/>
      <url>/2018/07/24/126-Word-Ladder-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:</p><p>Only one letter can be changed at a time<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>Note:</p><p>Return an empty list if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.<br>Example 1:</p><p>Input:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</p><p>Output:<br>[<br>  [“hit”,”hot”,”dot”,”dog”,”cog”],<br>  [“hit”,”hot”,”lot”,”log”,”cog”]<br>]<br>Example 2:</p><p>Input:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]</p><p>Output: []</p><p>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This is a follow up for <a href="/2018/06/14/127-Word-Ladder/" title="127. Word Ladder">127. Word Ladder</a>. If you have this question on interview, maybe go with a naive BFS solution, then improve it with bi-direction BFS. </p><p>The solution came with one direction BFS, the step is as follows.</p><ol><li>Use BFS to solve question, so we need a queue. <code>queue&lt;vector&lt;string&gt;&gt; paths</code>, to store the paths in current level.</li><li>A dictionary that help to search if a mutate string is in wordlist. The mutate string is created by the same method in <a href="/2018/06/14/127-Word-Ladder/" title="127. Word Ladder">127. Word Ladder</a>. For each character in a word, try to change it to another character, and check whether if it’s in the dictionary.</li><li>Once we know the words in previous level(can think of as the BFS level), we can not use those words again, so we need a set(<code>unordered_set&lt;string&gt; words</code>) to record the used string on this level.</li><li>Maintain a <code>minlevel</code> to speed up the process. Because if we can find a path to find <code>endWord</code> in 5 hops, then we don’t need to find any path that is greater than 5.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res; </span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(wordList.begin(), wordList.end()); <span class="comment">//for lookup if the changed word in dictionary or not</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; p&#123;beginWord&#125;; </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; paths;</span><br><span class="line">        </span><br><span class="line">        paths.push(p);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>, minLevel = INT_MAX;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!paths.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = paths.front(); <span class="comment">//start with beginWord</span></span><br><span class="line">            paths.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t.size() &gt; level) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">string</span> w : words) dict.erase(w); <span class="comment">//to remove the word that already used on level 1</span></span><br><span class="line">                words.clear();</span><br><span class="line">                level = t.size();</span><br><span class="line">                <span class="keyword">if</span> (level &gt; minLevel) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> last = t.back(); <span class="comment">//last element of curent path, try to find next word to link</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last.size(); ++i) &#123;</span><br><span class="line">                <span class="built_in">string</span> newLast = last;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ++ch) &#123;</span><br><span class="line">                    newLast[i] = ch;</span><br><span class="line">                    <span class="keyword">if</span> (!dict.count(newLast)) <span class="keyword">continue</span>; </span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//can find another word after changing one character in dictionary</span></span><br><span class="line">                    words.insert(newLast); <span class="comment">//put it into set, so we won't use it again</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    example: </span></span><br><span class="line"><span class="comment">                    t: abc-&gt;abd-&gt;acd</span></span><br><span class="line"><span class="comment">                    newPath= abc-&gt;abd-&gt;acd + acc</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; nextPath = t; </span><br><span class="line">                    nextPath.push_back(newLast);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (newLast == endWord) &#123;</span><br><span class="line">                        res.push_back(nextPath);</span><br><span class="line">                        minLevel = level;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">else</span> paths.push(nextPath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://www.youtube.com/watch?v=lmypbtgdpuQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=lmypbtgdpuQ</a><br><a href="http://www.cnblogs.com/grandyang/p/4548184.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4548184.html</a><br><a href="https://goo.gl/4rcWS6" target="_blank" rel="noopener">https://goo.gl/4rcWS6</a><br><a href="https://goo.gl/t1vxXg" target="_blank" rel="noopener">https://goo.gl/t1vxXg</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> backtracking </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> array </tag>
            
            <tag> bfs </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>154. Find Minimum in Rotated Sorted Array II</title>
      <link href="/2018/07/24/154-Find-Minimum-in-Rotated-Sorted-Array-II/"/>
      <url>/2018/07/24/154-Find-Minimum-in-Rotated-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p><p>Find the minimum element.</p><p>The array may contain duplicates.</p><p>Example 1:</p><p>Input: <code>[1,3,5]</code><br>Output: 1<br>Example 2:</p><p>Input: <code>[2,2,2,0,1]</code><br>Output: 0</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This question is a follow up for  <a href="/2018/05/25/153-Find-Minimum-in-Rotated-Sorted-Array/" title="153. Find Minimum in Rotated Sorted Array">153. Find Minimum in Rotated Sorted Array</a>. We can still use binary search to solve this question. </p><ol><li>two pointers, <code>left</code> and <code>right</code>. In the end, we return the <code>nums[left]</code></li><li>calculate <code>mid</code> to find middle element.</li><li>Since the array is sorted, if <code>nums[mid] &gt; nums[right]</code> then we set <code>left</code> to <code>mid+1</code> because we know the smallest element is on the right side and it’s started position would at least be mid+1.</li><li>One thing to notice is that the array contains duplicate elements, if <code>nums[mid] == nums[right]</code> we reduce the right pointer.</li></ol><p>For the duplicate elements, it might drag the time complexity to <code>O(n)</code> if it looks like the following array.<br><code>&quot;1 1 1 1 1 0 1 1 1 1 1 1 1 1&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>, right= nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            mid= left+ (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt; nums[right])</span><br><span class="line">                left= mid+<span class="number">1</span>; <span class="comment">//set to mid+1 is because nums[mid] is definitely not the smallest element</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt; nums[right])</span><br><span class="line">                right= mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//nums[mid]== nums[right]</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> uber </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++ 11 lambda function</title>
      <link href="/2018/07/23/C-11-lambda-function/"/>
      <url>/2018/07/23/C-11-lambda-function/</url>
      <content type="html"><![CDATA[<p>In C++ 11, a lambda expression is a convenient way of defining an anonymous function object right at the location where it is invoked or passed as an argument to a function.</p><p>basic usage:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[=] (<span class="keyword">int</span> x) <span class="keyword">mutable</span> <span class="keyword">throw</span>() -&gt; <span class="keyword">int</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// function</span></span><br><span class="line">  <span class="keyword">int</span> n = x + y;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>[=]：lambda-introducer, or capture clause<br>every lambda function start with lambda-introducer and can not be omitted. Besides of the working as a keyword for lambda expression, it can also denote how to fetch variables into lambda function.<br>You can use the <code>default capture mode</code> (capture-default in the Standard syntax) to indicate how to capture any outside variables that are referenced in the lambda: <code>[&amp;]</code> means all variables that you refer to are <code>captured by reference</code>, and <code>[=]</code> means they are <code>captured by value</code>. You can use a default capture mode, and then specify the opposite mode explicitly for specific variables.<br>For example, if a lambda body accesses the external variable total by reference and the external variable factor by value, then the following capture clauses are equivalent:</p><p><code>[]</code>: default<br><code>[=]</code>: set default capture mode to capture by value.<br><code>[&amp;]</code>: set default capture mode to capture by reference.<br><code>[x, &amp;y]</code>: x is capture by value, y is capture by reference.<br><code>[=, &amp;y]</code>: every variable is captured by value, except y is captured by reference.<br><code>[&amp;, x]</code>: every variable is captured by reference, except x is captured by value.</p></li></ul><p>use lambda with STL function:<br>example(with out lambda):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool condition(int value) &#123;</span><br><span class="line">  return (value &gt; 5);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">  vector&lt;int&gt; numbers &#123; 1, 2, 3, 4, 5, 10, 15, 20, 25, 35, 45, 50 &#125;;</span><br><span class="line">  // check how many elements meet the condition</span><br><span class="line">  auto count = count_if(numbers.begin(), numbers.end(), condition);</span><br><span class="line">  cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; numbers &#123; 1, 2, 3, 4, 5, 10, 15, 20, 25, 35, 45, 50 &#125;;</span><br><span class="line">  // use lambda expression to replace the condition function</span><br><span class="line">  auto count = count_if(numbers.begin(), numbers.end(), [](int x) &#123; return (x &gt; 5); &#125;);</span><br><span class="line">  cout &lt;&lt; &quot;Count: &quot; &lt;&lt; count &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://msdn.microsoft.com/en-us/library/dd293608.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd293608.aspx</a><br><a href="https://blog.gtwang.org/programming/lambda-expression-in-c11/" target="_blank" rel="noopener">https://blog.gtwang.org/programming/lambda-expression-in-c11/</a></p>]]></content>
      
      <categories>
          
          <category> programming language </category>
          
          <category> study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> C++ 11 </tag>
            
            <tag> MSDN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>56. Merge Intervals</title>
      <link href="/2018/07/23/56-Merge-Intervals/"/>
      <url>/2018/07/23/56-Merge-Intervals/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><p>Input: <code>[[1,3],[2,6],[8,10],[15,18]]</code><br>Output: <code>[[1,6],[8,10],[15,18]]</code><br>Explanation: Since intervals <code>[1,3]</code> and <code>[2,6]</code> overlaps, merge them into [1,6].<br>Example 2:</p><p>Input: <code>[[1,4],[4,5]]</code><br>Output: <code>[[1,5]]</code><br>Explanation: Intervals [1,4] and [4,5] are considered overlapping.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>First of all, we can sort the array of intervals by its start value. The sort can use lambda function.</li><li>After we sort the array, we can easily found out that the only condition we need to check is whether if <code>i</code>‘s end value is smaller than <code>i+1</code>‘s start value.</li></ol><p>For example:<br>original: <code>[[4,3],[2,6],[3,5],[7,18]]</code><br>sorted: <code>[[2,6],[3,5],[4,7],[8,18]]</code></p><ul><li>init round: push the <code>[2,6]</code> into result.</li><li>1st round:<br>compare <code>[2,6]</code> and <code>[3,5]</code>. <code>6</code> is greater than <code>3</code>, so we then compare end value from both range.</li><li>2nd round:<br>compare <code>[2,6]</code> and <code>[4,7]</code>. update <code>[2,6]</code> to <code>[2,7]</code></li><li>3rd round:<br>compare <code>[2,7]</code> and <code>[8,18]</code>. Since <code>8</code> is greater than <code>7</code>, it can not merge together, so we push <code>[8,18]</code> into the result.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for an interval.</span></span><br><span class="line"><span class="comment">* struct Interval &#123;</span></span><br><span class="line"><span class="comment">*     int start;</span></span><br><span class="line"><span class="comment">*     int end;</span></span><br><span class="line"><span class="comment">*     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">*     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*static bool comp(Interval a, Interval b)&#123;</span></span><br><span class="line"><span class="comment">        return a.start&lt; b.start;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        <span class="comment">//sort(intervals.begin(), intervals.end(), comp);</span></span><br><span class="line">        sort(ins.begin(), ins.end(), [](Interval a, Interval b)&#123;<span class="keyword">return</span> a.start &lt; b.start;&#125;);</span><br><span class="line">        </span><br><span class="line">        res.push_back(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.back().end &lt; intervals[i].start) res.push_back(intervals[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.back().end = max(res.back().end, intervals[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>238. Product of Array Except Self</title>
      <link href="/2018/07/23/238-Product-of-Array-Except-Self/"/>
      <url>/2018/07/23/238-Product-of-Array-Except-Self/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p><p>Solve it without division and in O(n).</p><p>For example, given <code>[1,2,3,4]</code>, return <code>[24,12,8,6]</code>.</p><p>Follow up:<br>Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Given numbers [2, 3, 4, 5], regarding the third number 4, the product of array except 4 is 2*3*5 which consists of two parts: left 2*3 and right 5. The product is left*right. We can get lefts and rights:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Numbers:     2    3    4     5</span></span><br><span class="line"><span class="comment">Lefts:            2  2*3 2*3*4</span></span><br><span class="line"><span class="comment">Rights:  3*4*5  4*5    5      </span></span><br><span class="line"><span class="comment">Let’s fill the empty with 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Numbers:     2    3    4     5</span></span><br><span class="line"><span class="comment">Lefts:       1    2  2*3 2*3*4</span></span><br><span class="line"><span class="comment">Rights:  3*4*5  4*5    5     1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(length, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; length; i++)&#123;</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            res[i]*= right;</span><br><span class="line">            right*= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="second-time"><a href="#second-time" class="headerlink" title="second time:"></a>second time:</h1><p>based on the previous thought, but modify the code to make it more intuitive.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3   4   5   6</span></span><br><span class="line"><span class="comment">left=1 1*1  </span></span><br><span class="line"><span class="comment">        -&gt; 1*3  </span></span><br><span class="line"><span class="comment">            -&gt;3*4  </span></span><br><span class="line"><span class="comment">                -&gt; 3*4*5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3   4   5   6</span></span><br><span class="line"><span class="comment">                  1*1  right=1</span></span><br><span class="line"><span class="comment">              1*6 &lt;-</span></span><br><span class="line"><span class="comment">          5*6  &lt;-</span></span><br><span class="line"><span class="comment">      4*5*6  &lt;-</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">do same work, can use one for loop</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(length, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">1</span>, right= <span class="number">1</span>;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>, j= length<span class="number">-1</span>; i&lt; length; i++, j--)&#123;</span><br><span class="line">            res[i]*= left;</span><br><span class="line">            left*= nums[i];</span><br><span class="line">            res[j]*= right;</span><br><span class="line">            right*= nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time: O(n)</p><h3 id="Third-time"><a href="#Third-time" class="headerlink" title="Third time"></a>Third time</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; productExceptSelf(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//use two array separately start from 1 and n-2</span></span><br><span class="line">        <span class="keyword">int</span> n= nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; n; i++)</span><br><span class="line">            res[i]= res[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= n<span class="number">-2</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            right*= nums[i+<span class="number">1</span>];</span><br><span class="line">            res[i]*= right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
            <tag> lyft </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>123. Best Time to Buy and Sell Stock III</title>
      <link href="/2018/07/23/123-Best-Time-to-Buy-and-Sell-Stock-III/"/>
      <url>/2018/07/23/123-Best-Time-to-Buy-and-Sell-Stock-III/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p><p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p>Example 1:</p><p>Input: <code>[3,3,5,0,0,3,1,4]</code><br>Output: 6<br>Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.<br>             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.<br>Example 2:</p><p>Input: <code>[1,2,3,4,5]</code><br>Output: 4<br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>             engaging multiple transactions at the same time. You must sell before buying again.<br>Example 3:</p><p>Input: <code>[7,6,4,3,1]</code><br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>this is a relatively easier way to understand this question. </p><ol><li><p>create a 2d array, row is total number of transaction, column is total number of days.<br><img style="width: 100%; height: 100%" src="IMG_5332.jpg"></p></li><li><p>the dp formula is<br><code>T[i][j]= max(T[i][j-1], price[j]-price[m]+ T[i-1][m])</code><br>it means, the maximum profit can get on transaction <code>i</code> in day <code>j</code> should be one of the following one.</p><ol><li><code>T[i][j-1]</code>, the same as previous day, means make no transaction at all.</li><li><code>price[j]-price[m]+ T[i-1][m]</code>, sale the stock bought on day <code>m</code> with the price on day <code>j</code>, and add the previous transaction profit together.</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//transaction: k, days: n</span></span><br><span class="line">    <span class="comment">//O(k*n^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> transactions= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(transactions+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(prices.size(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">1</span>; r&lt; dp.size(); r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">1</span>; c&lt; dp[<span class="number">0</span>].size(); c++)&#123;</span><br><span class="line">                <span class="keyword">int</span> maxval= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m= <span class="number">0</span>; m&lt; c; m++)&#123;</span><br><span class="line">                    maxval= max(maxval, prices[c]-prices[m]+ dp[r<span class="number">-1</span>][m]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[r][c]= max(dp[r][c<span class="number">-1</span>], maxval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[transactions][prices.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>However, the above solution would need many time to calculate. We can use a variable <code>maxdiff</code> to check whether if it’s a good time to sell the stock.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//transaction: k, days: n</span></span><br><span class="line">    <span class="comment">//O(k*n)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> transactions= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(transactions+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(prices.size(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">1</span>; r&lt; dp.size(); r++)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxdiff= -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">1</span>; c&lt; dp[<span class="number">0</span>].size(); c++)&#123;</span><br><span class="line">                dp[r][c]= max(dp[r][c<span class="number">-1</span>], prices[c]+maxdiff);</span><br><span class="line">                maxdiff= max(maxdiff, dp[r<span class="number">-1</span>][c]-prices[c]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[transactions][prices.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://www.youtube.com/watch?v=oDhu5uGq_ic&amp;feature=youtu.be" target="_blank" rel="noopener">https://www.youtube.com/watch?v=oDhu5uGq_ic&amp;feature=youtu.be</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>45. Jump Game II</title>
      <link href="/2018/07/23/45-Jump-Game-II/"/>
      <url>/2018/07/23/45-Jump-Game-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Your goal is to reach the last index in the minimum number of jumps.</p><p>Example:</p><p>Input: <code>[2,3,1,1,4]</code><br>Output: 2<br>Explanation: The minimum number of jumps to reach the last index is 2.<br>    Jump 1 step from index 0 to 1, then 3 steps to the last index.<br>Note:</p><p>You can assume that you can always reach the last index.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>We can use a bfs to solve this question.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level= <span class="number">0</span>, curMax= <span class="number">0</span>, i= <span class="number">0</span>, nextMax= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;= curMax)&#123;  <span class="comment">//nodes count of current level&gt;0</span></span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">for</span>(; i&lt;=curMax; i++)&#123; <span class="comment">//traverse current level, and update the max reach of next level</span></span><br><span class="line">                nextMax= max(nextMax, nums[i]+i);</span><br><span class="line">                <span class="keyword">if</span>(nextMax&gt;= nums.size()<span class="number">-1</span>) <span class="keyword">return</span> level; <span class="comment">// if last element is in level+1, then the min jump=level </span></span><br><span class="line">            &#125;</span><br><span class="line">            curMax= nextMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://goo.gl/fG1EwS" target="_blank" rel="noopener">https://goo.gl/fG1EwS</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>blockchain</title>
      <link href="/2018/07/11/blockchain/"/>
      <url>/2018/07/11/blockchain/</url>
      <content type="html"><![CDATA[<p>transaction:<br>fb: like, post<br>twitter: tweet, retweet<br>bitcoin: send money</p><p>Decentralize topology:<br>every node have whole copy.<br>51% of people have to approve/validate the new transaction.<br>the validation is done by miner, coin will be given to the 1st node that solve math problem.<br>Mining: verifying transactions by solving<br>transaction have queue up and group into block. </p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>199. Binary Tree Right Side View</title>
      <link href="/2018/07/11/199-Binary-Tree-Right-Side-View/"/>
      <url>/2018/07/11/199-Binary-Tree-Right-Side-View/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p>Example:</p><p>Input: <code>[1,2,3,null,5,null,4]</code><br>Output: <code>[1, 3, 4]</code><br>Explanation:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ul><li>DFS solution:</li></ul><ol><li>observe the tree, we can see that if we use a recursive traversal with a depth variable, we can get the rightmost element for each level.</li><li>traverse the right subtree first, then search for left subtree.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//DFS solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        helper(res, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res, TreeNode* cur, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(depth == res.size())&#123;</span><br><span class="line">            res.push_back(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        helper(res, cur-&gt;right, depth+<span class="number">1</span>);</span><br><span class="line">        helper(res, cur-&gt;left, depth+<span class="number">1</span>); <span class="comment">//if a root have right and left node, the right node will add to res already, so left will not be pushed into res.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: <code>O(n)</code><br>space complexity: <code>O(n)</code></p><ul><li>BFS solution:</li></ul><ol><li>for BFS, we traverse each level with a queue.</li><li>push the newest element in queue to <code>res</code>. That is because the way we traverse, will look like this.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">  2    3 </span><br><span class="line">4  5  6  7</span><br></pre></td></tr></table></figure></li></ol><p><code>queue: 7 6 5 4</code>, 4 will be pushed into queue first, 7 will be the last and right most element.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            res.push_back(q.back()-&gt;val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i= q.size(); i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">auto</span> front= q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;left) q.push(front-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(front-&gt;right) q.push(front-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/sWGD8V" target="_blank" rel="noopener">https://goo.gl/sWGD8V</a><br><a href="https://goo.gl/ZefCkV" target="_blank" rel="noopener">https://goo.gl/ZefCkV</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
          <category> amazon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>230. Kth Smallest Element in a BST</title>
      <link href="/2018/07/10/230-Kth-Smallest-Element-in-a-BST/"/>
      <url>/2018/07/10/230-Kth-Smallest-Element-in-a-BST/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p><p>Example 1:</p><p>Input: root = <code>[3,1,4,null,2]</code>, k = 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line"> \</span><br><span class="line">  2</span><br></pre></td></tr></table></figure></p><p>Output: 1<br>Example 2:</p><p>Input: root = <code>[5,3,6,2,4,null,null,1]</code>, k = 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">   / \</span><br><span class="line">  2   4</span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>Output: 3<br>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>use a variable to count ith smallest</li><li>whenever the count is zero, return the res<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        count= k;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//inorder traversal, find the left most first</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) helper(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        count--; </span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            res= root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) helper(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>reference:<br><a href="https://goo.gl/Ed7PGv" target="_blank" rel="noopener">https://goo.gl/Ed7PGv</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
          <category> google </category>
          
          <category> uber </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>173. Binary Search Tree Iterator</title>
      <link href="/2018/07/10/173-Binary-Search-Tree-Iterator/"/>
      <url>/2018/07/10/173-Binary-Search-Tree-Iterator/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p><p>Calling next() will return the next smallest number in the BST.</p><p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>we need to use O(1) time to find the smallest element, so we can use traverse the tree toward left, push the element into a stack, which will have the root in the bottom, smallest element(left most) element on the top.</li><li>One thing to notice is that, when we call hasNext(), we need to check whether if the current pop out root has a right subtree.<br>For example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line"> / \</span><br><span class="line">0   2</span><br></pre></td></tr></table></figure></li></ol><p>In above graph, we can see that <code>2</code> is smaller <code>3</code>. But we need to remember that we only push <code>[3,1,0]</code> into the stack. If we did not check for <code>1&#39;s</code> right subtree, we will get an incorrect next smaller element.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for binary tree</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !s.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode* n = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">int</span> res = n-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;right) &#123; <span class="comment">//Currently, n is the left most node, so we need to check if there's any right subtree of this n</span></span><br><span class="line">            n = n-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (n) &#123;</span><br><span class="line">                s.push(n);</span><br><span class="line">                n = n-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment">* BSTIterator i = BSTIterator(root);</span></span><br><span class="line"><span class="comment">* while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
            <tag> linkedin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>108. Convert Sorted Array to Binary Search Tree</title>
      <link href="/2018/07/10/108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
      <url>/2018/07/10/108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example:</p><p>Given the sorted array: <code>[-10,-3,0,5,9]</code>,</p><p>One possible answer is: <code>[0,-3,9,-10,null,5]</code>, which represents the following height balanced BST:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>find node to create as root, binary search to get mid</li><li>find left and right children, left= [start, mid-1], right= [mid+1, end]</li><li>return root</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.size()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* head= helper(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid= (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//int mid= low +(high-low)/2;</span></span><br><span class="line">        <span class="comment">//this can avoid int overflow</span></span><br><span class="line">        </span><br><span class="line">        TreeNode* node= <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        node-&gt;left= helper(nums, low, mid<span class="number">-1</span>);</span><br><span class="line">        node-&gt;right= helper(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>110. Balanced Binary Tree</title>
      <link href="/2018/07/10/110-Balanced-Binary-Tree/"/>
      <url>/2018/07/10/110-Balanced-Binary-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><p>a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>Example 1:</p><p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>Return true.</p><p>Example 2:</p><p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure></p><p>Return false.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ul><li>top-down solution<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span> <span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max (depth(root -&gt; left), depth (root -&gt; right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span> <span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left= depth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right= depth(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: O(N^2) for worst case</p><ul><li>bottom-up method:<br>Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub tree<br>is balanced, and decides its return value.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfsHeight</span> <span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> leftHeight = dfsHeight (root -&gt; left);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightHeight = dfsHeight (root -&gt; right);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max (leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfsHeight (root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution.</p><p>time complexity: O(n)<br>reference:<br><a href="https://goo.gl/25GVKA" target="_blank" rel="noopener">https://goo.gl/25GVKA</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>100. Same Tree</title>
      <link href="/2018/07/10/100-Same-Tree/"/>
      <url>/2018/07/10/100-Same-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given two binary trees, write a function to check if they are the same or not.</p><p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br></pre></td></tr></table></figure></p><p>Output: true<br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br></pre></td></tr></table></figure></p><p>Output: false<br>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br></pre></td></tr></table></figure></p><p>Output: false</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>if both of the input TreeNode* are NULL, return true</li><li>if one of them is NULL, return false</li><li>check for current values are equivalent to each others</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ((p-&gt;val == q-&gt;val) &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>617. Merge Two Binary Trees</title>
      <link href="/2018/07/10/617-Merge-Two-Binary-Trees/"/>
      <url>/2018/07/10/617-Merge-Two-Binary-Trees/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p><p>Example 1:<br>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">    1                         2                             </span><br><span class="line">   / \                       / \                            </span><br><span class="line">  3   2                     1   3                        </span><br><span class="line">     /                       \   \                      </span><br><span class="line">    5                         4   7</span><br></pre></td></tr></table></figure></p><p>Output:<br>Merged tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">    / \</span><br><span class="line">  4   5</span><br><span class="line">  / \   \ </span><br><span class="line">5   4   7</span><br></pre></td></tr></table></figure></p><p>Note: The merging process must start from the root nodes of both trees.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t1 &amp;&amp; t2)&#123;</span><br><span class="line">            TreeNode* tmp= <span class="keyword">new</span> TreeNode(t1-&gt;val+t2-&gt;val);</span><br><span class="line">            tmp-&gt;left= mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            tmp-&gt;right= mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t1? t1:t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/Nxp7M6" target="_blank" rel="noopener">https://goo.gl/Nxp7M6</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>226. Invert Binary Tree</title>
      <link href="/2018/07/10/226-Invert-Binary-Tree/"/>
      <url>/2018/07/10/226-Invert-Binary-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Invert a binary tree.</p><p>Example:</p><p>Input:</p><pre><code>    4  /   \  2     7/ \   / \1   3 6   9</code></pre><p>Output:</p><pre><code>    4  /   \  7     2/ \   / \9   6 3   1</code></pre><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>The basic idea is to swap the <code>left</code> and <code>right</code> node of the root. We can use recursive or non-recursive method to solve this question.</p><ul><li><p>recursive method</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        <span class="built_in">std</span>::swap(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>non-recursive method</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//use non-recursive method</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="comment">//stack: last in forst out</span></span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            TreeNode* p= stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(p)&#123;</span><br><span class="line">                stk.push(p-&gt;left);</span><br><span class="line">                stk.push(p-&gt;right);</span><br><span class="line">                swap(p-&gt;left, p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>reference:<br><a href="https://goo.gl/9kLdfS" target="_blank" rel="noopener">https://goo.gl/9kLdfS</a><br><a href="https://goo.gl/nQJp7n" target="_blank" rel="noopener">https://goo.gl/nQJp7n</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>111. Minimum Depth of Binary Tree</title>
      <link href="/2018/07/09/111-Minimum-Depth-of-Binary-Tree/"/>
      <url>/2018/07/09/111-Minimum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><pre><code>  3/ \9  20  /  \15   7</code></pre><p>return its minimum depth = 2.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//NULL node no height</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> <span class="number">1</span>+minDepth(root-&gt;right); <span class="comment">//edge case for no left subtree</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> <span class="number">1</span>+minDepth(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+min(minDepth(root-&gt;left), minDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/mNYNmX" target="_blank" rel="noopener">https://goo.gl/mNYNmX</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>437. Path Sum III</title>
      <link href="/2018/07/09/437-Path-Sum-III/"/>
      <url>/2018/07/09/437-Path-Sum-III/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><p>Example:</p><p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p><pre><code>  10 /  \5   -3</code></pre><p>   / \    \<br>  3   2   11<br> / \   \<br>3  -2   1</p><p>Return 3. The paths that sum to 8 are:</p><ol><li>5 -&gt; 3</li><li>5 -&gt; 2 -&gt; 1</li><li>-3 -&gt; 11</li></ol><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This question we can also use preorder traversal to solve it. That is to say, we visit current node, then check left and right subtree.</p><p>We need to maintain a variable <code>pre</code>, to store the sum of previous nodes. If <code>root-&gt;cal+pre</code> equal to target, then at least return 1. After that, we still need to check whether if adding other subtree can achieve target(might have zero or negative numbers).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//can start from root or left subtree or right subtree</span></span><br><span class="line">        <span class="keyword">return</span> helper(root, sum, <span class="number">0</span>)+ pathSum(root-&gt;left, sum)+pathSum(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//use pre to store previous levels sum</span></span><br><span class="line">        <span class="comment">//if root-&gt;cal+pre equal to target, then at least return 1</span></span><br><span class="line">        <span class="comment">//but still need to check whether if adding other subtree can achieve target(might have zero or negative numbers)</span></span><br><span class="line">        <span class="keyword">int</span> cur= pre+ root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> (cur== sum)+ helper(root-&gt;left, sum, cur)+ helper(root-&gt;right, sum, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/6007336.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/6007336.html</a><br><a href="https://goo.gl/bYjbbn" target="_blank" rel="noopener">https://goo.gl/bYjbbn</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>113. Path Sum II</title>
      <link href="/2018/07/09/113-Path-Sum-II/"/>
      <url>/2018/07/09/113-Path-Sum-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Given the below binary tree and sum = 22,</p><pre><code>  5 / \4   8</code></pre><p>   /   / \<br>  11  13  4<br> /  \    / \<br>7    2  5   1<br>Return:</p><p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This is a typical backtracking question. Design a backtrack helper function, use preorder traversal to include the path.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        helper(res, tmp, sum, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> sum, TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">//preorder traversal</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum-root-&gt;val ==<span class="number">0</span>) res.push_back(tmp);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) helper(res, tmp, sum-root-&gt;val, root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) helper(res, tmp, sum-root-&gt;val, root-&gt;right);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://goo.gl/VPHfpv" target="_blank" rel="noopener">https://goo.gl/VPHfpv</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>112. Path Sum</title>
      <link href="/2018/07/09/112-Path-Sum/"/>
      <url>/2018/07/09/112-Path-Sum/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p><p>Note: A leaf is a node with no children.</p><p>Example:</p><p>Given the below binary tree and sum = 22,</p><pre><code>  5 / \4   8</code></pre><p>   /   / \<br>  11  13  4<br> /  \      \<br>7    2      1<br>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The basic idea is to subtract the value of current node from sum until it reaches a leaf node and the subtraction equals 0, then we know that we got a hit. Otherwise the subtraction at the end could not be 0.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum-root-&gt;val==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/MkXt4r" target="_blank" rel="noopener">https://goo.gl/MkXt4r</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>222. Count Complete Tree Nodes</title>
      <link href="/2018/07/09/222-Count-Complete-Tree-Nodes/"/>
      <url>/2018/07/09/222-Count-Complete-Tree-Nodes/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a complete binary tree, count the number of nodes.</p><p>Note:</p><p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p><p>Example:</p><p>Input:<br>    1<br>   / \<br>  2   3<br> / \  /<br>4  5 6</p><p>Output: 6</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>A complete binary tree means every level is filled except for perhaps last level. To the extent that the last level is filled, it is filled left to right.<br>Therefore, we can know the following things.</p><ol><li>from traverse left subtree, we can obtain the maximum height of the tree.</li><li>if the tree is perfect binary tree(complete and full), it will have <code>2^h -1</code> nodes</li></ol><p>We use two pointer to count the height of <code>left</code> and <code>right</code>. If they’re equal, then the subtree of this root have totally <code>2^h -1</code> nodes. If not equal, then we recursively search <code>root-&gt;left</code> and <code>root-&gt;right</code>.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">*     int val;</span></span><br><span class="line"><span class="comment">*     TreeNode *left;</span></span><br><span class="line"><span class="comment">*     TreeNode *right;</span></span><br><span class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> hl= <span class="number">0</span>, hr= <span class="number">0</span>;</span><br><span class="line">        TreeNode* l= root, *r= root;</span><br><span class="line">        <span class="keyword">while</span>(l)&#123; hl++; l= l-&gt;left;&#125;</span><br><span class="line">        <span class="keyword">while</span>(r)&#123; hr++; r= r-&gt;right;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hl== hr) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, hl)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>+countNodes(root-&gt;left)+ countNodes(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: </p><p>reference:<br><a href="https://goo.gl/SAq511" target="_blank" rel="noopener">https://goo.gl/SAq511</a><br><a href="https://goo.gl/o9PEje" target="_blank" rel="noopener">https://goo.gl/o9PEje</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>note-Tree</title>
      <link href="/2018/07/08/note-Tree-Graph/"/>
      <url>/2018/07/08/note-Tree-Graph/</url>
      <content type="html"><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><ul><li>Complete binary tree:<br>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.</li></ul><p><img src="Binary_search_tree_example.gif" alt=""></p><ul><li><p>Specific ordering property:<br>all left descendants &lt;= n &lt; all right descendants. Must be true for all node n.<br>Make sure to check whether if there’s any <code>duplicate</code> value. One definition is <code>no duplication</code>, the other is duplication will be on <code>right</code> or <code>either</code> side.</p></li><li><p>Complete Binary Tree:<br>Every level is filled except for perhaps last level. To the extent that the last level is filled, it is filled left to right.<br><img src="completetree.png" alt=""></p></li><li><p>Full Binary Tree<br>A full binary tree is every node has either zero or two children. That is, no nodes have only one children.</p></li><li><p>Perfect Binary Tree<br>Both full and complete. All leaf nodes are on same level, and this level have maximum nodes. Have exactly <code>2^h -1</code> nodes, h is number of levels(height).</p></li><li><p>Trie(Prefix Trees)<br>Each path down the tree would represent a word. Normally, have a <code>* node</code>(sometimes called <code>null node</code>)</p></li></ul><h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><ul><li>Adjacent list</li></ul>]]></content>
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> binary tree </tag>
            
            <tag> binary search tree </tag>
            
            <tag> complete binary tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>376. Wiggle Subsequence</title>
      <link href="/2018/07/06/376-Wiggle-Subsequence/"/>
      <url>/2018/07/06/376-Wiggle-Subsequence/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> greedy </tag>
            
            <tag> peak </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>698. Partition to K Equal Sum Subsets</title>
      <link href="/2018/07/05/698-Partition-to-K-Equal-Sum-Subsets/"/>
      <url>/2018/07/05/698-Partition-to-K-Equal-Sum-Subsets/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal.</p><p>Example 1:<br>Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4<br>Output: True<br>Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.<br>Note:</p><p>1 &lt;= k &lt;= len(nums) &lt;= 16.<br>0 &lt; nums[i] &lt; 10000.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum= accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//can not form k subsets</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(nums.size(), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(nums, k, sum/k, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> curSum, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//only need to create one subset, current subset can do it</span></span><br><span class="line">        <span class="keyword">if</span>(curSum == target) <span class="keyword">return</span> helper(nums, k<span class="number">-1</span>, target, <span class="number">0</span>, <span class="number">0</span>, visited); <span class="comment">//achieve target, need to create k-1 more subset</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i]= <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(helper(nums, k, target, i+<span class="number">1</span>, curSum+nums[i], visited)) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            visited[i]= <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> partition </tag>
            
            <tag> subset </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>416. Partition Equal Subset Sum</title>
      <link href="/2018/07/05/416-Partition-Equal-Subset-Sum/"/>
      <url>/2018/07/05/416-Partition-Equal-Subset-Sum/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p>Note:<br>Each of the array element will not exceed 100.<br>The array size will not exceed 200.<br>Example 1:</p><p>Input: [1, 5, 11, 5]</p><p>Output: true</p><p>Explanation: The array can be partitioned as [1, 5, 5] and [11].<br>Example 2:</p><p>Input: [1, 2, 3, 5]</p><p>Output: false</p><p>Explanation: The array cannot be partitioned into equal sum subsets.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: nums)</span><br><span class="line">            sum+= n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sum %<span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//can not be partitioned into two subset</span></span><br><span class="line">        <span class="keyword">int</span> target= sum /<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(target+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= target; i&gt;= n; i--)&#123;</span><br><span class="line">                dp[i]= dp[i] || dp[i-n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>300. Longest Increasing Subsequence</title>
      <link href="/2018/07/01/300-Longest-Increasing-Subsequence/"/>
      <url>/2018/07/01/300-Longest-Increasing-Subsequence/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>For example,<br>Given [10, 9, 2, 5, 3, 7, 101, 18],<br>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p><p>Your algorithm should run in O(n2) complexity.</p><p>Follow up: Could you improve it to O(n log n) time complexity?</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//dp[i]: LIS when ends at nums[i]</span></span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt; nums[i])</span><br><span class="line">                    dp[i]= max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res= max(res, dp[i]); <span class="comment">//get the max value of LIS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n^2)<br>space complexity: O(1)</p><h1 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h1><p>The question also ask for O(nlogn) solution. </p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> google </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>343. Integer Break</title>
      <link href="/2018/07/01/343-Integer-Break/"/>
      <url>/2018/07/01/343-Integer-Break/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.</p><p>For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p><p>Note: You may assume that n is not less than 2 and not larger than 58.</p><p>Credits:<br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.<br><a href="https://goo.gl/CizU8W" target="_blank" rel="noopener">https://goo.gl/CizU8W</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>We can try to find the pattern,<br> num  divide into   product<br>  2       1+1          1<br>  3       2+1          2<br>  4       2+2          4<br>  5       2+3          6<br>  6       3+3          9<br>  7       3+2+2        12<br>  8       3+3+2        18</p><p>We can see that, all factors should be 2 or 3 (N &gt; 4). Also, since <code>3 * 3 &gt; 2 * 2 * 2</code>, we should try to have 3 as much as possible(N&gt;4). </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n ==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> product =<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">4</span>)&#123;</span><br><span class="line">            product *=<span class="number">3</span>;</span><br><span class="line">            n-=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        product *=n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>264. Ugly Number II</title>
      <link href="/2018/06/29/264-Ugly-Number-II/"/>
      <url>/2018/06/29/264-Ugly-Number-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Write a program to find the n-th ugly number.</p><p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</p><p>Note that 1 is typically treated as an ugly number, and n does not exceed 1690.</p><p>Credits:<br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>Let’s say we have an result array that contains every ugly number in it.<br><code>result[i]: ith ugly number</code></p><p>Now, how do we get the next ugly number, <code>result[i+1]</code>? The next ugly number must be one of these,<br><code>result[i]*2</code>, <code>result[i]*3</code>, <code>result[i]*5</code>. That is to say, if we know which to multiply, we can get <code>i+1th</code> ugly number. </p><p>We can use three different pointer to indicate three different counter for 2, 3, and 5. Each time we compare the product of these, and the least one is next ugly number.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>; <span class="comment">// for pointing the position of current 2, 3, 5</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n&gt; result.size())&#123;</span><br><span class="line">            result.push_back(min(result[i]*<span class="number">2</span>, min(result[j]*<span class="number">3</span>, result[k]*<span class="number">5</span>))); <span class="comment">//calculate which is the next minimum ugly number</span></span><br><span class="line">            <span class="keyword">if</span>(result.back() == result[i]*<span class="number">2</span>) ++i;</span><br><span class="line">            <span class="keyword">if</span>(result.back() == result[j]*<span class="number">3</span>) ++j;</span><br><span class="line">            <span class="keyword">if</span>(result.back() == result[k]*<span class="number">5</span>) ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> heap </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>307. Range Sum Query - Mutable</title>
      <link href="/2018/06/28/307-Range-Sum-Query-Mutable/"/>
      <url>/2018/06/28/307-Range-Sum-Query-Mutable/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p><p>The update(i, val) function modifies nums by updating the element at index i to val.</p><p>Example:</p><p>Given nums = [1, 3, 5]</p><p>sumRange(0, 2) -&gt; 9<br>update(1, 2)<br>sumRange(0, 2) -&gt; 8<br>Note:</p><p>The array is only modifiable by the update function.<br>You may assume the number of calls to update and sumRange function is distributed evenly.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This question is a follow up for . If we use previous method to design the algorithm, it would be inefficient. The reason is that whenever we want to modify a value in the array, we would need to change the whole array after the modified one. </p><p>The following solution is based on <a href="https://en.wikipedia.org/wiki/Fenwick_tree" target="_blank" rel="noopener">Fenwick Tree</a>, which is an algorithm that can achieve O(logn) time for getting sum and modify value. </p><p><img src="fenwick.jpeg" alt="Fenwick Tree"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        num.resize(nums.size() +<span class="number">1</span>);</span><br><span class="line">        bit.resize(nums.size() +<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            update(i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff= val-num[i+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= i+<span class="number">1</span>; j&lt; num.size(); j += j&amp; -j)&#123; <span class="comment">//only modify logn elements for each iteration</span></span><br><span class="line">            bit[j] += diff;</span><br><span class="line">        &#125;</span><br><span class="line">        num[i+<span class="number">1</span>] = val;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        example:</span></span><br><span class="line"><span class="comment">        i= 4</span></span><br><span class="line"><span class="comment">         4: 0000 0100</span></span><br><span class="line"><span class="comment">        -4: 1111 1100</span></span><br><span class="line"><span class="comment">        only change bit[4] and bit[8]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(j + <span class="number">1</span>) - getSum(i);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j -= (j&amp;-j)) &#123;</span><br><span class="line">            res += bit[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj.update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> binary indexed tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>139. Word Break</title>
      <link href="/2018/06/28/139-Word-Break/"/>
      <url>/2018/06/28/139-Word-Break/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p><p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p><p>Return true because “leetcode” can be segmented as “leet code”.</p><p>UPDATE (2017/1/4):<br>The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The idea for the solution is that a given string <code>s</code> can be divided into two substring <code>s1</code> and <code>s2</code>. If <code>s1</code> and <code>s2</code> both fulfill the requirement, then complete the problem. Let’s create a dp array, which <code>dp[i]= 1</code> means we are able to find match in dictionary. </p><p>As we just said, the original string can treat as substrings. Therefore, we can use a two pointer to check whether if there’s matches in a string.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//https://leetcode.com/problems/word-break/discuss/43814/C++-Dynamic-Programming-simple-and-fast-solution-(4ms)-with-optimization</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(wordDict.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.size()+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(wordDict.begin(), wordDict.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> word = s.substr(j,i-j);</span><br><span class="line">                    <span class="keyword">if</span>(dict.find(word)!= dict.end())</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//next i</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><p>similar idea from previous one.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.length()+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>]= <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: wordDict)</span><br><span class="line">            dict.insert(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= i<span class="number">-1</span>; j&gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dict.find(s.substr(j, i-j)) != dict.end())&#123;</span><br><span class="line">                        dp[i]= <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>337. House Robber III</title>
      <link href="/2018/06/27/337-House-Robber-III/"/>
      <url>/2018/06/27/337-House-Robber-III/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p><p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \   \ </span><br><span class="line">  3   1</span><br></pre></td></tr></table></figure></p><p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \   \ </span><br><span class="line">1   3   1</span><br></pre></td></tr></table></figure></p><p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><a href="/2018/06/27/198-House-Robber/" title="198. House Robber">198. House Robber</a><a href="/2018/06/27/213-House-Robber-II/" title="213. House Robber II">213. House Robber II</a><p>This problem change the array to a tree structure but the idea is similar. We use a recursive function to sum up the value that starts from <code>root</code> or from its child(<code>root-&gt;left</code> and <code>root-&gt;right</code>). </p><ul><li>Solution1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> val= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            val+= rob(root-&gt;right-&gt;right)+ rob(root-&gt;right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            val+= rob(root-&gt;left-&gt;right)+ rob(root-&gt;left-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(root-&gt;val+ val, rob(root-&gt;right)+rob(root-&gt;left));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>However, this solution has a bad time complexity. It is because we need to recalculate many things. For example, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    6</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \   \ </span><br><span class="line">1   3   2</span><br></pre></td></tr></table></figure><p>If we start from <code>6</code>, and we calculate the <code>1, 3, 2</code>(grandchildren) value 1 time.<br>However, after we calculate <code>4, 5</code>, we’ll need to calculate <code>1, 3, 2</code> again.<br>This seems not efficient enough, we can use a map to record the node that we’ve already calculated.</p><ul><li>Solution 2<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">//use map to store every treeNode in the tree, so that we won't have to recalculate</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> robSub(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">robSub</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> val= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>.find(root) != <span class="built_in">map</span>.end()) <span class="keyword">return</span> <span class="built_in">map</span>.at(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            val+= robSub(root-&gt;right-&gt;right)+ robSub(root-&gt;right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            val+= robSub(root-&gt;left-&gt;right)+ robSub(root-&gt;left-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        val = max(root-&gt;val+ val, robSub(root-&gt;right)+robSub(root-&gt;left));</span><br><span class="line">        <span class="built_in">map</span>[root]= val;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>Can we do even better?<br>The major problem is we need to loop up for those already calculated subproblems.<br>Actually, for each root, there are two scenarios: it is robbed or is not. rob(root) does not distinguish between these two cases, so “information is lost as the recursion goes deeper and deeper”, which results in repeated subproblems.<br>If we were able to maintain the information about the two scenarios for each tree root, let’s see how it plays out. Redefine rob(root) as a new function which will return an <code>array of two elements</code>, the first element of which denotes the maximum amount of money that can be robbed if root is <code>not robbed</code>, while the second element signifies the maximum amount of money robbed if it <code>is robbed</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res= robSub(root);</span><br><span class="line">        <span class="keyword">return</span> max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; robSub(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">0</span>); <span class="comment">//0: w/o root. 1: w/ root</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left= robSub(root-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right= robSub(root-&gt;right);</span><br><span class="line">        <span class="comment">// result without root = add left[1](include left-&gt;val) and right[1](include right-&gt;val)</span></span><br><span class="line">        <span class="comment">// but maximum value could be bypass root-&gt;left or root-&gt;right</span></span><br><span class="line">        <span class="comment">// example:</span></span><br><span class="line">        <span class="comment">// 4-1-1-3</span></span><br><span class="line">        res[<span class="number">0</span>]= max(left[<span class="number">0</span>], left[<span class="number">1</span>])+ max(right[<span class="number">0</span>], right[<span class="number">1</span>]); </span><br><span class="line">        </span><br><span class="line">        res[<span class="number">1</span>]= root-&gt;val+left[<span class="number">0</span>]+right[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>213. House Robber II</title>
      <link href="/2018/06/27/213-House-Robber-II/"/>
      <url>/2018/06/27/213-House-Robber-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p><p>Example 1:</p><p>Input: [2,3,2]<br>Output: 3<br>Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),<br>             because they are adjacent houses.<br>Example 2:</p><p>Input: [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>             Total amount you can rob = 1 + 3 = 4.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This problem is pretty similar to <a href="/2018/06/27/198-House-Robber/" title="198. House Robber">198. House Robber</a>. First, let’s look at the example <code>[1,2,3,1]</code>. If you choose to rob <code>nums[0]</code>, then you must not rob <code>nums[size-1]</code>, and your right boundary would be <code>nums[size-2]</code>. On the other hand, if you choose to rob <code>nums[size-1]</code>, then you must not rob <code>nums[0]</code>, that means you could only start robbing from <code>nums[1]</code>.</p><ul><li>rob nums[0]: <code>0...n-2</code></li><li>not rob nums[0]: <code>1...n-1</code></li></ul><p>Therefore, we can either separate the array into two different array or we can do the search twice. </p><p>In previous question, <a href="/2018/06/27/198-House-Robber/" title="198. House Robber">198. House Robber</a>, we use a simple for loop to do the dynamic programming. We can further extract the for loop as a helper function, which takes left and right boundary as input. </p><p>If you don’t want to build another function, you can use for loop twice as well, like solution 2.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n= nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n? nums[<span class="number">0</span>]: <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(help(nums, <span class="number">0</span>, n<span class="number">-2</span>), help(nums, <span class="number">1</span>, n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur= <span class="number">0</span>, pre= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= left; i&lt;= right; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = max(nums[i]+ pre, cur);</span><br><span class="line">            pre= cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">0</span>, cur1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = pre1;</span><br><span class="line">            pre1 = cur1;</span><br><span class="line">            cur1 = max(temp + nums[i], pre1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>, cur2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = pre2;</span><br><span class="line">            pre2 = cur2;</span><br><span class="line">            cur2 = max(temp + nums[i], pre2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(cur1, cur2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/NYAGsU" target="_blank" rel="noopener">https://goo.gl/NYAGsU</a><br><a href="https://goo.gl/RA1cb9" target="_blank" rel="noopener">https://goo.gl/RA1cb9</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>198. House Robber</title>
      <link href="/2018/06/27/198-House-Robber/"/>
      <url>/2018/06/27/198-House-Robber/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p><p>Example 1:</p><p>Input: [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>             Total amount you can rob = 1 + 3 = 4.<br>Example 2:</p><p>Input: [2,7,9,3,1]<br>Output: 12<br>Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br>             Total amount you can rob = 2 + 9 + 1 = 12.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>DP solution:<br>For dp solution, we need to know what is the recursion function in it. As you can see in the example, once you pick <code>ith</code> house to rob, you must not came from <code>i-1th</code> house. Therefore, let’s try to think it in this way:<br>Let us look at the case <code>n = 1</code>, clearly <code>f(1) = A1</code>.<br>Now, let us look at <code>n = 2</code>, which <code>f(2) = max(A1, A2)</code>.<br>For <code>n = 3</code>, you have basically the following two options:<br>Rob the third house, and add its amount to the first house’s amount.<br>Do not rob the third house, and stick with the maximum amount of the first two houses.<br>Clearly, you would want to choose the larger of the two options at each step.<br>Therefore, we could summarize the formula as following:<br><code>f(k) = max(f(k – 2) + Ak, f(k – 1))</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Edge Cases</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> *max_element(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>]; <span class="comment">//Represent starting from the odd house</span></span><br><span class="line">        dp[<span class="number">1</span>]=max(dp[<span class="number">0</span>], nums[<span class="number">1</span>]);<span class="comment">//Represent max loot at the even house</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//odd, even</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Edge Cases</span></span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">2</span>) <span class="keyword">return</span> *max_element(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> odd,even;</span><br><span class="line">        odd=nums[<span class="number">0</span>]; <span class="comment">//Represent starting from the odd house</span></span><br><span class="line">        even=nums[<span class="number">1</span>];<span class="comment">//Represent starting from the even house</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">2</span>==<span class="number">0</span>) <span class="comment">//Even</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(odd&lt;even) odd=even; <span class="comment">//If robbing even path gives more value then put odd as even</span></span><br><span class="line">                even+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//Odd</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(even&lt;odd) even=odd;</span><br><span class="line">                odd+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(even,odd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> easy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>5. Longest Palindromic Substring</title>
      <link href="/2018/06/26/5-Longest-Palindromic-Substring/"/>
      <url>/2018/06/26/5-Longest-Palindromic-Substring/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>Example:<br>Input: “babad”<br>Output: “bab”</p><p>Note: “aba” is also a valid answer.</p><p>Example:<br>Input: “cbbd”<br>Output: “bb”<br><a href="https://goo.gl/5cmsJy" target="_blank" rel="noopener">https://goo.gl/5cmsJy</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The basic idea is to use an iterative function to check whether if the left and right character is the same as each others. One thing to notice is that, the center might be in the middle of two character, for example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aabbc, length 5, mid is index[3]</span><br><span class="line">aabb, length 4, mid is in the middle of index[1] index [2]</span><br></pre></td></tr></table></figure></p><p>Therefore, we need to check whether if the center is a character or not. We can use a subfunction to help us check. By using two pointer, <code>left</code> and <code>right</code>, we can use two different input:</p><ol><li>left == right:<br>expand from 1 character<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a a b c d</span><br><span class="line">    |</span><br><span class="line">   r l</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>left != right:<br>expand from 2 characters<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a b c d</span><br><span class="line">  | | </span><br><span class="line">  l r</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>first time </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> c1, <span class="keyword">int</span> c2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> l = c1, r = c2;</span><br><span class="line">      <span class="keyword">int</span> n = s.length();</span><br><span class="line">      <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= n<span class="number">-1</span> &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> s.substr(l+<span class="number">1</span>, r-l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = s.length();</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">      <span class="built_in">string</span> longest = s.substr(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// a single char itself is a palindrome</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> p1 = expandAroundCenter(s, i, i);</span><br><span class="line">        <span class="keyword">if</span> (p1.length() &gt; longest.length())</span><br><span class="line">          longest = p1;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> p2 = expandAroundCenter(s, i, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p2.length() &gt; longest.length())</span><br><span class="line">          longest = p2;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>second time:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp1= expand(s, i, i);</span><br><span class="line">            <span class="built_in">string</span> tmp2= expand(s, i, i+<span class="number">1</span>);</span><br><span class="line">            res= res.length()&gt; tmp1.length() ? res: tmp1;</span><br><span class="line">            res= res.length()&gt; tmp2.length() ? res: tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">expand</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left= l, right= r;</span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;= s.length() &amp;&amp; s[left]==s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(left+<span class="number">1</span>, right-left<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>339. Nested List Weight Sum</title>
      <link href="/2018/06/26/339-Nested-List-Weight-Sum/"/>
      <url>/2018/06/26/339-Nested-List-Weight-Sum/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p><p>Example 1:<br>Given the list [[1,1],2,[1,1]], return 10. (four 1’s at depth 2, one 2 at depth 1)</p><p>Example 2:<br>Given the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4<em>2 + 6</em>3 = 27)</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(nestedList, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nestedList.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nestedList[i].isInteger())</span><br><span class="line">                res+= (nestedList[i].getInteger()*depth);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res+= dfs(nestedList[i].getList(), depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> easy </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>364. Nested List Weight Sum II</title>
      <link href="/2018/06/26/364-Nested-List-Weight-Sum-II/"/>
      <url>/2018/06/26/364-Nested-List-Weight-Sum-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p><p>Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p><p>Example 1:<br>Given the list [[1,1],2,[1,1]], return 8. (four 1’s at depth 1, one 2 at depth 2)</p><p>Example 2:<br>Given the list [1,[4,[6]]], return 17. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1<em>3 + 4</em>2 + 6*1 = 17)</p><h1 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1:"></a>Solution 1:</h1><p>related question: <a href="/2018/06/26/339-Nested-List-Weight-Sum/" title="339. Nested List Weight Sum">339. Nested List Weight Sum</a></p><p>In the given example, <code>[[1,1],2,[1,1]]</code>, we can treat it like this.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   2    = 2*2</span><br><span class="line">1 1 1 1 = 4*1</span><br></pre></td></tr></table></figure></p><p>Therefore, we can use dfs to traverse the whole nestedList, and use a vector<int> to store each layer’s sum.</int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : nestedList) &#123;</span><br><span class="line">            helper(a, <span class="number">0</span>, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res += v[i] * (v.size() - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(NestedInteger ni, <span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= v.size()) v.resize(depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ni.isInteger()) &#123;</span><br><span class="line">            v[depth] += ni.getInteger();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : ni.getList()) &#123;</span><br><span class="line">                helper(a, depth + <span class="number">1</span>, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)<br>space complexity: O(n)</p><p>reference:<br><a href="http://www.cnblogs.com/grandyang/p/5615583.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5615583.html</a><br><a href="https://goo.gl/MTbKTN" target="_blank" rel="noopener">https://goo.gl/MTbKTN</a><br><a href="https://goo.gl/FtsdeX" target="_blank" rel="noopener">https://goo.gl/FtsdeX</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>106. Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link href="/2018/06/21/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/"/>
      <url>/2018/06/21/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</url>
      <content type="html"><![CDATA[<p>#Problem description:</p><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given</p><p>inorder = [9,3,15,20,7]<br>postorder = [9,15,7,20,3]<br>Return the following binary tree:</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7</p><p>#Solution:<br>This problem is pretty similar to <a href="/2018/06/05/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/" title="105. Construct Binary Tree from Preorder and Inorder Traversal">105. Construct Binary Tree from Preorder and Inorder Traversal</a>.</p><p>We can see the inorder and postorder array like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           in order</span><br><span class="line">+------------+------+-------------+</span><br><span class="line">| left child | root | right child |</span><br><span class="line">+------------+------+-------------+  </span><br><span class="line"></span><br><span class="line">            post order</span><br><span class="line">+------------+-------------+------+</span><br><span class="line">| left child | right child | root |</span><br><span class="line">+------------+-------------+------+</span><br></pre></td></tr></table></figure></p><p>As you can see, <code>root</code> is in the last position in <code>postorder</code> array. After we find the root, we can get the length of each subarray as follows:</p><ul><li>left tree:<br>inOrder[1 .. p - 1]<br>postOrder[1 .. p - 1]</li><li>right tree:<br>inOrder[p + 1 .. n]<br>postOrder[p .. n - 1]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deal(<span class="number">0</span>, inorder.size() - <span class="number">1</span>, <span class="number">0</span>, postorder.size() - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deal</span><span class="params">(<span class="keyword">int</span> leftInorder, <span class="keyword">int</span> rightInorder, <span class="keyword">int</span> leftPostorder, <span class="keyword">int</span> rightPostorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rightInorder &lt; leftInorder || rightPostorder &lt; leftPostorder) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* rt = <span class="keyword">new</span> TreeNode(postorder[ rightPostorder ]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rightInorder - leftInorder; ++i)</span><br><span class="line">            <span class="keyword">if</span> (inorder[leftInorder + i] == rt -&gt; val) &#123;</span><br><span class="line">                p = i; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        rt -&gt; left  = deal(leftInorder, leftInorder + p - <span class="number">1</span>, leftPostorder, leftPostorder + p - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">        rt -&gt; right = deal(leftInorder + p + <span class="number">1</span>, rightInorder, leftPostorder + p, rightPostorder - <span class="number">1</span>, inorder, postorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>523. Continuous Subarray Sum</title>
      <link href="/2018/06/20/523-Continuous-Subarray-Sum/"/>
      <url>/2018/06/20/523-Continuous-Subarray-Sum/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>/<em><br>Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n</em>k where n is also an integer.</p><p>Example 1:<br><code>Input: [23, 2, 4, 6, 7],  k=6</code><br>Output: True<br>Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</p><p>Example 2:<br><code>Input: [23, 2, 6, 4, 7],  k=6</code><br>Output: True<br>Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</p><p>Note:<br>The length of the array won’t exceed 10,000.<br>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The main idea is to find whether if there’s two subarray that contains equal remainder.<br>Let’s say we have a sum of subarray from <code>i...j</code> look like this:<br>  <code>a[i]+a[i+1]+...+a[j]=n1k+q;</code></p><p>If we can find a <code>n</code>, which is greater than j , that qualified for the following equation,<br>  <code>n&gt;j</code> and <code>a[i]+a[i+1]+...+a[j]+...+a[n]=n2k+q;</code></p><p>We can derive a result that the sum of subarray from <code>j...n</code> should be:<br>  <code>a[j+1]+...+a[n]=(n2−n1)k</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>= &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            sum+= nums[i];</span><br><span class="line">            <span class="keyword">if</span>(k != <span class="number">0</span>)</span><br><span class="line">                sum = sum%k;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.count(sum))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i- <span class="built_in">map</span>[sum] &gt;<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">map</span>[sum]= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)<br>space complexity: O(n)</p><p>reference:<br><a href="https://goo.gl/sieyWJ" target="_blank" rel="noopener">https://goo.gl/sieyWJ</a><br><a href="https://goo.gl/fb8NoY" target="_blank" rel="noopener">https://goo.gl/fb8NoY</a><br><a href="https://goo.gl/fK1cNG" target="_blank" rel="noopener">https://goo.gl/fK1cNG</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>75. Sort Colors</title>
      <link href="/2018/06/20/75-Sort-Colors/"/>
      <url>/2018/06/20/75-Sort-Colors/</url>
      <content type="html"><![CDATA[<p>#Problem description:</p><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p>Note: You are not suppose to use the library’s sort function for this problem.</p><p>Example:</p><p>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]<br>Follow up:</p><p>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.<br>Could you come up with a one-pass algorithm using only constant space?</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>We can use three pointers to solve this question.<br>low: point to <code>0</code><br>mid: point to <code>1</code><br>high: point to <code>2</code></p><p>If we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array.</p><p>To achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends.</p><p>Take this example:</p><p>Assume our input is: 1 0 2 2 1 0 (short for simplicity).</p><p>Running the algorithm by hand would look something like:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1 0 2 2 1 0</span><br><span class="line">    ^         ^</span><br><span class="line">    L         H</span><br><span class="line">    M</span><br><span class="line"></span><br><span class="line">    Mid != 0 || 2</span><br><span class="line">    Mid++</span><br><span class="line"></span><br><span class="line">    1 0 2 2 1 0</span><br><span class="line">    ^ ^       ^</span><br><span class="line">    L M       H</span><br><span class="line"></span><br><span class="line">    Mid == 0</span><br><span class="line">    Swap Low and Mid</span><br><span class="line">    Mid++</span><br><span class="line">    Low++</span><br><span class="line"></span><br><span class="line">    0 1 2 2 1 0</span><br><span class="line">      ^ ^     ^</span><br><span class="line">      L M     H</span><br><span class="line"></span><br><span class="line">    Mid == 2</span><br><span class="line">    Swap High and Mid</span><br><span class="line">    High--</span><br><span class="line"></span><br><span class="line">    0 1 0 2 1 2</span><br><span class="line">      ^ ^   ^</span><br><span class="line">      L M   H</span><br><span class="line"></span><br><span class="line">    Mid == 0</span><br><span class="line">    Swap Low and Mid</span><br><span class="line">    Mid++</span><br><span class="line">    Low++</span><br><span class="line"></span><br><span class="line">    0 0 1 2 1 2</span><br><span class="line">        ^ ^ ^</span><br><span class="line">        L M H</span><br><span class="line"></span><br><span class="line">    Mid == 2</span><br><span class="line">    Swap High and Mid</span><br><span class="line">    High--</span><br><span class="line"></span><br><span class="line">    0 0 1 1 2 2</span><br><span class="line">        ^ ^</span><br><span class="line">        L M</span><br><span class="line">          H</span><br><span class="line"></span><br><span class="line">    Mid &lt;= High is our exit case</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low= <span class="number">0</span>, mid= <span class="number">0</span>, high= nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(mid &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums[mid], nums[low]); <span class="comment">//change the value in position 'mid', 'low'</span></span><br><span class="line">                low++;</span><br><span class="line">                mid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == <span class="number">1</span>)&#123; </span><br><span class="line">                mid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                swap(nums[mid], nums[high]);</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/iKdeLx" target="_blank" rel="noopener">https://goo.gl/iKdeLx</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> sort </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>119. Pascal&#39;s Triangle II</title>
      <link href="/2018/06/19/119-Pascal-s-Triangle-II/"/>
      <url>/2018/06/19/119-Pascal-s-Triangle-II/</url>
      <content type="html"><![CDATA[<p>#Problem description:</p><p>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal’s triangle.</p><p>Note that the row index starts from 0.</p><p>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</p><p>Example:</p><p>Input: 3<br>Output: [1,3,3,1]</p><p>Could you optimize your algorithm to use only O(k) extra space?</p><p>#Solution:</p><ol><li>Init an array with size of rowIndex+1.</li><li>Increment the value from the end to beginning.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Init:</span><br><span class="line">  ---------------------</span><br><span class="line">  1 0....             0</span><br><span class="line"></span><br><span class="line">i=1:</span><br><span class="line">  ---------------------</span><br><span class="line">  1 1 0....           0 </span><br><span class="line"></span><br><span class="line">i=2:</span><br><span class="line">  ---------------------</span><br><span class="line">  1 2 1 0....         0</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A(rowIndex+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        A[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;rowIndex+<span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">1</span>; j--)</span><br><span class="line">                A[j] += A[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/4Nkj1c" target="_blank" rel="noopener">https://goo.gl/4Nkj1c</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> easy </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>717. 1-bit and 2-bit Characters</title>
      <link href="/2018/06/19/717-1-bit-and-2-bit-Characters/"/>
      <url>/2018/06/19/717-1-bit-and-2-bit-Characters/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).</p><p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p><p>Example 1:<br>Input:<br>bits = [1, 0, 0]<br>Output: True<br>Explanation:<br>The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.<br>Example 2:<br>Input:<br>bits = [1, 1, 1, 0]<br>Output: False<br>Explanation:<br>The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.<br>Note:</p><p>1 &lt;= len(bits) &lt;= 1000.<br>bits[i] is always 0 or 1.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The idea is to determine whether if the last <code>0</code> is a <code>0</code> itself or belong to a <code>10</code>. We can use a pointer to walk through the array. If the <code>bits[i] == 1</code> then we know we will have a two-bit character. On the other hand, if it’s a <code>0</code>, then we just increment 1.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; bits.size()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (bits[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == bits.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> easy </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="/2018/06/16/236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
      <url>/2018/06/16/236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p>Given the following binary search tree:  root = <code>[3,5,1,6,2,0,8,null,null,7,4]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line">6      _2       0       8</span><br><span class="line">      /  \</span><br><span class="line">      7   4</span><br></pre></td></tr></table></figure></p><p>Example 1:</p><p>Input: root = <code>[3,5,1,6,2,0,8,null,null,7,4]</code>, p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of of nodes 5 and 1 is 3.<br>Example 2:</p><p>Input: root = <code>[3,5,1,6,2,0,8,null,null,7,4]</code>, p = 5, q = 4<br>Output: 5<br>Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself<br>             according to the LCA definition.<br>Note:</p><p>All of the nodes’ values will be unique.<br>p and q are different and both values will exist in the binary tree.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>Recursively search left and right subtree.<br>If can find a <code>root-&gt;val == p or q</code>, then this root is at least contains one of the node’s ancestor.</p><p>So we find in left subtree and right subtree, if both left and right can find a value, then current root is the ancestor.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == p-&gt;val ||root-&gt;val == q-&gt;val) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(!left) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(!right) <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(logn)$</p><p>reference:<br><a href="https://goo.gl/NJbDFm" target="_blank" rel="noopener">https://goo.gl/NJbDFm</a><br><a href="https://goo.gl/7BNspr" target="_blank" rel="noopener">https://goo.gl/7BNspr</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> apple </tag>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> amazon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>654. Maximum Binary Tree</title>
      <link href="/2018/06/16/654-Maximum-Binary-Tree/"/>
      <url>/2018/06/16/654-Maximum-Binary-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:</p><p>The root is the maximum number in the array.<br>The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.<br>The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.<br>Construct the maximum tree by the given array and output the root node of this tree.</p><p>Example 1:<br>Input: [3,2,1,6,0,5]<br>Output: return the tree root node representing the following tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   6</span><br><span class="line"> /   \</span><br><span class="line">3     5</span><br><span class="line"> \    / </span><br><span class="line">  2  0   </span><br><span class="line">    \</span><br><span class="line">     1</span><br></pre></td></tr></table></figure></p><p>Note:<br>The size of the given array will be in the range [1,1000].</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mx= INT_MIN, mx_idx= <span class="number">0</span>; <span class="comment">//find the max num and it's index</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; mx)&#123;</span><br><span class="line">                mx= nums[i];</span><br><span class="line">                mx_idx= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//spilt the nums into half</span></span><br><span class="line">        TreeNode* root= <span class="keyword">new</span> TreeNode(mx);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.begin(), nums.begin()+ mx_idx);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right= <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.begin()+mx_idx+<span class="number">1</span>, nums.end());</span><br><span class="line">        root-&gt;left = constructMaximumBinaryTree(left);</span><br><span class="line">        root-&gt;right= constructMaximumBinaryTree(right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/Nqk7oZ" target="_blank" rel="noopener">https://goo.gl/Nqk7oZ</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>127. Word Ladder</title>
      <link href="/2018/06/14/127-Word-Ladder/"/>
      <url>/2018/06/14/127-Word-Ladder/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p><p>Only one letter can be changed at a time.<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>Note:</p><p>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.<br>Example 1:</p><p>Input:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code></p><p>Output: 5</p><p>Explanation: As one shortest transformation is <code>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</code>,<br>return its length 5.<br>Example 2:</p><p>Input:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = <code>[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code></p><p>Output: 0</p><p>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The key idea is to substitute every single character in the <code>beginWord</code> and check whether if there’s any match in the <code>wordList</code>. One thing you need to notice is that you can not use a word twice; therefore, once a word in <code>wordList</code> is used(used means we can find a match after replacing the character), you need to remove it from the list.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(wordList.begin(), wordList.end()); <span class="comment">//put into unordered_set for efficient search</span></span><br><span class="line">        <span class="keyword">if</span> (!dict.count(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        q.push(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = beginWord.length();</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> size = q.size(); size &gt; <span class="number">0</span>; size--) &#123; </span><br><span class="line">                <span class="built_in">string</span> w = q.front(); <span class="comment">//pick a word in queue to do the search</span></span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123; <span class="comment">//the description stated that the length of each word would be the same</span></span><br><span class="line">                    <span class="keyword">char</span> ch = w[i]; <span class="comment">//change each character to find if there's a match</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++) &#123;</span><br><span class="line">                        w[i] = j;</span><br><span class="line">                        <span class="comment">// Found the solution</span></span><br><span class="line">                        <span class="keyword">if</span> (w == endWord) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Not in dict, skip it</span></span><br><span class="line">                        <span class="keyword">if</span> (!dict.count(w)) <span class="keyword">continue</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Remove new word from dict, because we can only use each word in dictionary once</span></span><br><span class="line">                        dict.erase(w);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// Add new word into queue</span></span><br><span class="line">                        q.push(w);                    </span><br><span class="line">                    &#125;</span><br><span class="line">                    w[i] = ch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://goo.gl/yJo3ou" target="_blank" rel="noopener">https://goo.gl/yJo3ou</a><br><a href="https://goo.gl/JNAsQE" target="_blank" rel="noopener">https://goo.gl/JNAsQE</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>200. Number of Islands</title>
      <link href="/2018/06/14/200-Number-of-Islands/"/>
      <url>/2018/06/14/200-Number-of-Islands/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p>Example 1:</p><p>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br></pre></td></tr></table></figure></p><p>Output: 1</p><p>Example 2:</p><p>Input:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br></pre></td></tr></table></figure></p><p>Output: 3</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The idea is to treat the 2d grid map as an undirected graph and there is an edge between two horizontally or vertically adjacent nodes of value <code>1</code>.</p><p>Linear scan the 2d grid map, if a node contains a <code>1</code>, then it is a root node that triggers a Depth First Search. During DFS, every visited node should be set as <code>0</code> to mark as visited node. Count the number of root nodes that trigger DFS, this number would be the number of islands since each DFS starting at some root identifies an island.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr= grid.size();</span><br><span class="line">        <span class="keyword">int</span> nc= grid[<span class="number">0</span>].size();</span><br><span class="line">      </span><br><span class="line">          grid[r][c] = <span class="string">'0'</span>; <span class="comment">//we already check this island on outer loop, so mark it out</span></span><br><span class="line">          <span class="keyword">if</span>(r<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c]== <span class="string">'1'</span>) dfs(grid, r<span class="number">-1</span>, c); <span class="comment">//check if there's any connected '1', mark it out too</span></span><br><span class="line">          <span class="keyword">if</span>(r+<span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c]== <span class="string">'1'</span>) dfs(grid, r+<span class="number">1</span>, c); <span class="comment">//mark them out is because we already count on outer loop</span></span><br><span class="line">          <span class="keyword">if</span>(c<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>]== <span class="string">'1'</span>) dfs(grid, r, c<span class="number">-1</span>);</span><br><span class="line">          <span class="keyword">if</span>(c+<span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>]== <span class="string">'1'</span>) dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> nr= grid.size();</span><br><span class="line">          <span class="keyword">if</span>(!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> nc= grid[<span class="number">0</span>].size();</span><br><span class="line">          <span class="keyword">int</span> num_island= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> r= <span class="number">0</span>; r&lt; nr; r++)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> c= <span class="number">0</span>; c&lt; nc; c++)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(grid[r][c] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                      ++num_island; <span class="comment">//count this first appear island</span></span><br><span class="line">                      dfs(grid, r, c);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> num_island;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(mn)<br>space complexity: O(mn), in worst case the grid is filled with island, DFS goes m*n deep</p><p>reference:<br><a href="https://goo.gl/S4Hig9" target="_blank" rel="noopener">https://goo.gl/S4Hig9</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
            <tag> union find </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>102. Binary Tree Level Order Traversal</title>
      <link href="/2018/06/14/102-Binary-Tree-Level-Order-Traversal/"/>
      <url>/2018/06/14/102-Binary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>return its level order traversal as:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This is a very basic problem, we can use dfs to solve this problem. One thing to notice is that we need to use a <code>depth</code> variable to store the level where we are.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; levelOrder(TreeNode *root) &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == depth) <span class="comment">//need to insert a new layer</span></span><br><span class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        res[depth].push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        dfs(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: O(n)</p><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><p>Use BFS to do traversal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;);</span><br><span class="line">            <span class="keyword">int</span> size= q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; size; i++)&#123;</span><br><span class="line">                TreeNode* tmp= q.front(); q.pop();</span><br><span class="line">                res[res.size()<span class="number">-1</span>].push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left) q.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right) q.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>179. Largest Number</title>
      <link href="/2018/06/14/179-Largest-Number/"/>
      <url>/2018/06/14/179-Largest-Number/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,2]</span><br><span class="line">Output: &quot;210&quot;</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,30,34,5,9]</span><br><span class="line">Output: &quot;9534330&quot;</span><br></pre></td></tr></table></figure></p><p>Note: The result may be very large, so you need to return a string instead of an integer.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>First, sort the array based on the combination of two integer.<br>After sorting, we can use the array to create result string.<br>For example:<br>Input: [10,2]<br>  “2”+”10”-&gt; 210<br>  “10”+”2”-&gt; 102</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> to_string(a)+to_string(b)&gt; to_string(b)+to_string(a);&#125;);</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            res = res + to_string(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>406. Queue Reconstruction by Height</title>
      <link href="/2018/06/13/406-Queue-Reconstruction-by-Height/"/>
      <url>/2018/06/13/406-Queue-Reconstruction-by-Height/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.</p><p>Note:<br>The number of people is less than 1,100.</p><p>Example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; reconstructQueue(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="comment">//example:</span></span><br><span class="line">        <span class="comment">//before sorting: [7,1], [7,0], [5,2], [4,3]</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        sort(people.begin(), people.end(),[](pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p1, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p2)&#123; <span class="comment">//lamda function</span></span><br><span class="line">            <span class="keyword">return</span> p1.first &gt; p2.first || (p1.first == p2.first &amp;&amp; p1.second &lt; p2.second);</span><br><span class="line">            <span class="comment">//true: [6,0], [4,0] or [6,2], [6,4]</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//after sorting: [7,0], [7,1], [5,2], [4,3]</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; sol;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> person : people)&#123; </span><br><span class="line">            sol.insert(sol.begin() + person.second, person); </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/XfqSmq" target="_blank" rel="noopener">https://goo.gl/XfqSmq</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> greddy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>341. Flatten Nested List Iterator</title>
      <link href="/2018/06/13/341-Flatten-Nested-List-Iterator/"/>
      <url>/2018/06/13/341-Flatten-Nested-List-Iterator/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a nested list of integers, implement an iterator to flatten it.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Given the list [[1,1],2,[1,1]],</span><br><span class="line"></span><br><span class="line">By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Given the list [1,[4,[6]]],</span><br><span class="line"></span><br><span class="line">By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>first, we can store all the elements in reverse order with a stack. The reason that we need to use reverse order is because <code>Stack is Last in First out</code>. We can use the following example to explain.</p><p>index:  0 1 2 3 4 5<br>data:   a b e d c q</p><pre><code>___________</code></pre><h2 id="stack-a-b-e-d-c-q"><a href="#stack-a-b-e-d-c-q" class="headerlink" title="stack   a b e d c q|"></a>stack   a b e d c q|</h2><pre><code>  |         |  last push   |        first push</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="comment">//because the stack is LIFO, so if we want to do A item in stack first, then we need to push item A in the last</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nestedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; </span><br><span class="line">            s.push(nestedList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NestedInteger t = s.top(); </span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">return</span> t.getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            NestedInteger t = s.top(); </span><br><span class="line">            <span class="keyword">if</span> (t.isInteger()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//if this element is a number, return true and let next() do the job</span></span><br><span class="line">            s.pop(); <span class="comment">//this element is a list</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t.getList().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                s.push(t.getList()[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;NestedInteger&gt; s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p> reference:<br> <a href="https://goo.gl/Ut4Pns" target="_blank" rel="noopener">https://goo.gl/Ut4Pns</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>98. Validate Binary Search Tree</title>
      <link href="/2018/06/13/98-Validate-Binary-Search-Tree/"/>
      <url>/2018/06/13/98-Validate-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Explanation: The input is: [5,1,4,null,null,3,6]. The root node’s value<br>             is 5 but its right child’s value is 4.</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1:"></a>Solution1:</h3><p>Binary search tree:<br>left node value &lt; root value &lt; right value</p><p>We can use a variable to store left node and compare with current one.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> validate(root, prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validate</span><span class="params">(TreeNode* root, TreeNode* &amp;prev)</span> </span>&#123;<span class="comment">//do Inorder traversal</span></span><br><span class="line">        <span class="comment">//1. find toward left until the end</span></span><br><span class="line">        <span class="comment">//2. set this leftest node as prev</span></span><br><span class="line">        <span class="comment">//3. check if prev(left) node is smaller than root</span></span><br><span class="line">        <span class="comment">//4. check right subtree</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">if</span> (!validate(root-&gt;left, prev)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">NULL</span> &amp;&amp; root-&gt;val &lt;= prev-&gt;val ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//previous node is from left side, so it should be smaller      than right side node</span></span><br><span class="line">        prev = root; </span><br><span class="line">        <span class="keyword">return</span> validate(root-&gt;right, prev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(logn)$</p><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2:"></a>Solution2:</h3><p>Another solution is to use BFS, with a stack.<br>Find the left most node, and then start to validate.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p = root, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (p || !s.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *t = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span> (pre &amp;&amp; t-&gt;val &lt;= pre-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pre = t;</span><br><span class="line">            p = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: $O(n)$<br>space complexity: $O(n)$</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link href="/2018/06/12/150-Evaluate-Reverse-Polish-Notation/"/>
      <url>/2018/06/12/150-Evaluate-Reverse-Polish-Notation/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p><p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p><p>Note:</p><p>Division between two integers should truncate toward zero.<br>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.<br>Example 1:</p><p>Input: [“2”, “1”, “+”, “3”, “<em>“]<br>Output: 9<br>Explanation: ((2 + 1) </em> 3) = 9<br>Example 2:</p><p>Input: [“4”, “13”, “5”, “/“, “+”]<br>Output: 6<br>Explanation: (4 + (13 / 5)) = 6<br>Example 3:</p><p>Input: [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”]<br>Output: 22<br>Explanation:<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = tokens.back(); <span class="comment">//start from back, check if it's operand or operator</span></span><br><span class="line">        tokens.pop_back();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s != <span class="string">"+"</span> &amp;&amp; s != <span class="string">"-"</span> &amp;&amp; s != <span class="string">"*"</span> &amp;&amp; s != <span class="string">"/"</span>) </span><br><span class="line">            <span class="keyword">return</span> stoi(s); <span class="comment">//it's a number</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> r2 = evalRPN(tokens), r1 = evalRPN(tokens); <span class="comment">//s is a operator, so we go deeper to find the operand of it.</span></span><br><span class="line">        <span class="comment">//notice that r2 is close to back, so need to call it first.</span></span><br><span class="line">        <span class="comment">//1, 2, /</span></span><br><span class="line">        <span class="comment">//(1/2)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"+"</span>) <span class="keyword">return</span> r1 + r2;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"-"</span>) <span class="keyword">return</span> r1 - r2;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"*"</span>) <span class="keyword">return</span> r1 * r2;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"/"</span>) <span class="keyword">return</span> r1 / r2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>STL container-Stack</title>
      <link href="/2018/06/12/STL-container-Stack/"/>
      <url>/2018/06/12/STL-container-Stack/</url>
      <content type="html"><![CDATA[<p>Definition:<br><code>LIFO</code> stack<br>Stacks are a type of container adaptor, specifically designed to operate in a LIFO context (last-in first-out), where elements are inserted and extracted only from one end of the container.</p><p>One thing to be notice is that there’re several different container that would be used to </p>]]></content>
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>241. Different Ways to Add Parentheses</title>
      <link href="/2018/06/10/241-Different-Ways-to-Add-Parentheses/"/>
      <url>/2018/06/10/241-Different-Ways-to-Add-Parentheses/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;2-1-1&quot;</span><br><span class="line">Output: [0, 2]</span><br><span class="line">Explanation: </span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;2*3-4*5&quot;</span><br><span class="line">Output: [-34, -14, -10, -10, 10]</span><br><span class="line">Explanation: </span><br><span class="line">(2*(3-(4*5))) = -34 </span><br><span class="line">((2*3)-(4*5)) = -14 </span><br><span class="line">((2*(3-4))*5) = -10 </span><br><span class="line">(2*((3-4)*5)) = -10 </span><br><span class="line">(((2*3)-4)*5) = 10</span><br></pre></td></tr></table></figure><p>#Solution:<br>The key of this problem is that every operators in the string could be the last operator to be operated.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diffWaysToCompute(<span class="built_in">string</span> input) &#123;</span><br><span class="line">        <span class="comment">//output every results of calculation</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; input.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i] == <span class="string">'+'</span> || input[i] == <span class="string">'-'</span> || input[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result1= diffWaysToCompute(input.substr(<span class="number">0</span>, i));</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result2= diffWaysToCompute(input.substr(i+<span class="number">1</span>));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> n1: result1)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> n2: result2)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(input[i] == <span class="string">'+'</span>)</span><br><span class="line">                            res.push_back(n1+n2);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(input[i] == <span class="string">'-'</span>)</span><br><span class="line">                            res.push_back(n1-n2);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            res.push_back(n1*n2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res.empty())</span><br><span class="line">            res.push_back(atoi(input.c_str()));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> divide and conquer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>319. Bulb Switcher</title>
      <link href="/2018/06/09/319-Bulb-Switcher/"/>
      <url>/2018/06/09/319-Bulb-Switcher/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>the initial state all bulbs are off.</p><p>if at last the bulb was toggled odd number of times, it is on.<br>if toggled even number of times, it is off.</p><p>simple enough, and that number is determined by how many factors a number has.<br>note that every number has 1 and itself as a factor. and if it has multiple times of a factor<br>it only counted once.</p><p>1 ——— 1</p><p>2 ——— 1, 2</p><p>3 ——— 1, 3</p><p>4 ——— 1, 2, 4</p><p>5 ——— 1, 5</p><p>6 ——— 1, 2, 3, 6</p><p>7 ——— 1, 7</p><p>8 ——— 1, 2, 4, 8</p><p>9 ——— 1, 3, 9</p><p>see that only square numbers like 1, 4 and 9 has odd number of factors.<br>bulbs at those numbers will left on after all the rounds of toggle.</p><p>so basically, we calculate how many square numbers are there within a given number.<br>and we can get it simply by calculate the square root of that number. of course the decimal part is eliminated.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq(nums.begin(), nums.end()); <span class="comment">//put all elements in priority queue</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) </span><br><span class="line">            pq.pop(); <span class="comment">//remove the elements that is greater than Kth element</span></span><br><span class="line">        <span class="keyword">return</span> pq.top(); <span class="comment">//Now the largest one is Kth </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>reference:<br><a href="https://leetcode.com/problems/bulb-switcher/discuss/77112/Share-my-o(1)-solution-with-explanation" target="_blank" rel="noopener">https://leetcode.com/problems/bulb-switcher/discuss/77112/Share-my-o(1)-solution-with-explanation</a><br><a href="https://goo.gl/xSEhEb" target="_blank" rel="noopener">https://goo.gl/xSEhEb</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> math </tag>
            
            <tag> brainteaser </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>8. String to Integer (atoi)</title>
      <link href="/2018/06/09/8-String-to-Integer-atoi/"/>
      <url>/2018/06/09/8-String-to-Integer-atoi/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.</p><p>Note:</p><p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>discards all leading white spaces</li><li>sign of the number</li><li>check overflow, </li><li>invalid input</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[i] == <span class="string">' '</span>) &#123; <span class="comment">//remove white space</span></span><br><span class="line">            i++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>) &#123; <span class="comment">//check the sign of string</span></span><br><span class="line">            sign = <span class="number">1</span> - <span class="number">2</span> * (str[i] == <span class="string">'-'</span>); <span class="comment">//if it equals to '-', then sign is -1</span></span><br><span class="line">            i++; <span class="comment">//move to next position</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (base &gt;  INT_MAX / <span class="number">10</span> || (base == INT_MAX / <span class="number">10</span> &amp;&amp; str[i] - <span class="string">'0'</span> &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="comment">//INT_MAX = 2147483647, so if the base equals to (INT_MAX/10), which is 214748364</span></span><br><span class="line">                <span class="comment">//we must check whether if adding the new str[i] would cause overflow</span></span><br><span class="line">                <span class="keyword">if</span> (sign == <span class="number">1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            base  = <span class="number">10</span> * base + (str[i++] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> base * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><ol><li>clean every whitespace</li><li>check the sign by <code>-</code> or <code>+</code></li><li>if first character is not number, it will not go into while loop.</li><li>remember to check the INT_MAX, and return INT_MIN if sign is negative.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i= <span class="number">0</span>, sign= <span class="number">1</span>, res= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">            i++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check sign of the number</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">            sign = str[i]== <span class="string">'-'</span>? <span class="number">-1</span>: <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i]&lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; INT_MAX/<span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; str[i] - <span class="string">'0'</span> &gt; <span class="number">7</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> sign== <span class="number">1</span>? INT_MAX: INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            res= res*<span class="number">10</span>+(str[i++]-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sign*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>148. Sort List</title>
      <link href="/2018/06/08/148-Sort-List/"/>
      <url>/2018/06/08/148-Sort-List/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Sort a linked list in O(n log n) time using constant space complexity.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The description is asking for algorithm that runs within O(nlogn). Therefore, only quicksort, merge sort, heap sort can meet the requirement. </p><ol><li>First of all, we cut the list into half, the code is widely use, make sure to memorize it.</li><li>Then we keep cut it into half, until there’s only one node left.</li><li>Start merging the list and sort it.</li></ol><p><img src="sortlist.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *prev= head, *slow= head, *fast= head;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123; </span><br><span class="line">            <span class="comment">//fast runs twice than slow, so when fast reach end, prev would be the half</span></span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="comment">//cut list into half</span></span><br><span class="line">        <span class="comment">//1. head-&gt;...-&gt;prev-&gt;NULL</span></span><br><span class="line">        <span class="comment">//2. slow-&gt;...-&gt;endNode-&gt;NULL</span></span><br><span class="line">        </span><br><span class="line">        ListNode* l1 = sortList(head);</span><br><span class="line">        ListNode* l2 = sortList(slow);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2; </span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = merge(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = merge(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(nlogn)<br>space complexity: O(logn), it’s the tree’s depth</p><p>reference:<br><a href="https://goo.gl/uJF4wn" target="_blank" rel="noopener">https://goo.gl/uJF4wn</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> sort </tag>
            
            <tag> merge sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>347. Top K Frequent Elements</title>
      <link href="/2018/06/07/347-Top-K-Frequent-Elements/"/>
      <url>/2018/06/07/347-Top-K-Frequent-Elements/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a non-empty array of integers, return the k most frequent elements.</p><p>For example,<br>Given [1,1,1,2,2,3] and k = 2, return [1,2].</p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.<br>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>In the problem description, it ask for an algorithm that has time complexity better than O(n log n). We can use bucket sort.</p><ol><li>Create a map to count the element appearance in array, use elements value as key, which takes O(n)</li><li>Then create a 2d array to classify elements with item’s frequency</li><li>Search from the highest to kth frequently item.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n: nums)</span><br><span class="line">            ++<span class="built_in">map</span>[n]; <span class="comment">//put elements in map, increase the frequency</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; buckets(nums.size()+<span class="number">1</span>); <span class="comment">//size()+1 is because the sequence might full with the same element</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p: <span class="built_in">map</span>)</span><br><span class="line">            buckets[p.second].push_back(p.first); <span class="comment">//use frequency as index, put elements with same frequency into the same box</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= buckets.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; ans.size() &lt; k; --i)&#123; <span class="comment">//start from right side, because we want to find top k frequent</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num: buckets[i])&#123;</span><br><span class="line">                ans.push_back(num);</span><br><span class="line">                <span class="keyword">if</span>(ans.size() == k)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)<br>space complexity: O(n)</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
            <tag> heap </tag>
            
            <tag> bucket sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/2018/06/06/49-Group-Anagrams/"/>
      <url>/2018/06/06/49-Group-Anagrams/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given an array of strings, group anagrams together.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Note:</p><p>All inputs will be in lowercase.<br>The order of your output does not matter.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The idea is to use an <code>unordered_map</code> to store those strings that are anagrams. We use the <code>sorted string</code> as the key and the string itself as the value. The strings are stored in a multiset since there may be duplicates. Moreover, multiset will sort them by default as we desire.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s: strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = s; </span><br><span class="line">            sort(tmp.begin(), tmp.end());  <span class="comment">//use the sorted string as key to store every similar strings</span></span><br><span class="line">            <span class="built_in">map</span>[tmp].insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m: <span class="built_in">map</span>)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp(m.second.begin(), m.second.end());</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: O(nlogn)</p><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><p>Did not remember the idea of sorting each string.</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>138. Copy List with Random Pointer</title>
      <link href="/2018/06/06/138-Copy-List-with-Random-Pointer/"/>
      <url>/2018/06/06/138-Copy-List-with-Random-Pointer/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.<br>Return a deep copy of the list.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p><img style="width: 100%; height: 100%" src="138. Copy List with Random Pointer.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        RandomListNode *newHead, *l1, *l2;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (l1 = head; l1 != <span class="literal">NULL</span>; l1 = l1-&gt;next-&gt;next) &#123;</span><br><span class="line">            l2 = <span class="keyword">new</span> RandomListNode(l1-&gt;label);</span><br><span class="line">            l2-&gt;next = l1-&gt;next;</span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        newHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (l1 = head; l1 != <span class="literal">NULL</span>; l1 = l1-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;random != <span class="literal">NULL</span>) l1-&gt;next-&gt;random = l1-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (l1 = head; l1 != <span class="literal">NULL</span>; l1 = l1-&gt;next) &#123;</span><br><span class="line">            l2 = l1-&gt;next;</span><br><span class="line">            l1-&gt;next = l2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2-&gt;next != <span class="literal">NULL</span>) l2-&gt;next = l2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time:"></a>Second time:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        RandomListNode *newhead, *l1, *l2;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        l1= head;</span><br><span class="line">        <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">            l2= <span class="keyword">new</span> RandomListNode(l1-&gt;label);</span><br><span class="line">            l2-&gt;next= l1-&gt;next;</span><br><span class="line">            l1-&gt;next= l2;</span><br><span class="line">            l1= l1-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newhead= head-&gt;next;</span><br><span class="line">        l1= head;</span><br><span class="line">        l2= newhead;</span><br><span class="line">        <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;random)</span><br><span class="line">                l1-&gt;next-&gt;random= l1-&gt;random-&gt;next;</span><br><span class="line">            l1= l1-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        l1= head;</span><br><span class="line">        <span class="keyword">while</span>(l1)&#123;</span><br><span class="line">            l2= l1-&gt;next;</span><br><span class="line">            l1-&gt;next= l2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2-&gt;next)</span><br><span class="line">                l2-&gt;next= l2-&gt;next-&gt;next;</span><br><span class="line">            l1= l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/bq52sh" target="_blank" rel="noopener">https://goo.gl/bq52sh</a><br><a href="https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1)-and-linear-time-complexity-O(N)/42652" target="_blank" rel="noopener">https://leetcode.com/problems/copy-list-with-random-pointer/discuss/43491/A-solution-with-constant-space-complexity-O(1)-and-linear-time-complexity-O(N)/42652</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>535. Encode and Decode TinyURL</title>
      <link href="/2018/06/06/535-Encode-and-Decode-TinyURL/"/>
      <url>/2018/06/06/535-Encode-and-Decode-TinyURL/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>TinyURL is a URL shortening service where you enter a URL such as <a href="https://leetcode.com/problems/design-tinyurl" target="_blank" rel="noopener">https://leetcode.com/problems/design-tinyurl</a> and it returns a short URL such as <a href="http://tinyurl.com/4e9iAk" target="_blank" rel="noopener">http://tinyurl.com/4e9iAk</a>.</p><p>Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>use two unordered_map to store the relation of original url and shorten url, <code>shot2long</code> and <code>long2short</code>.</li><li>The whole process can be divided into 2 parts<ol><li>encode: <ul><li>input would be original string</li><li>create a random <code>6 character string</code>, which means we need to have a dictionary to search which character to use.</li><li>after created <code>6 character string</code>, need to check whether if it’s already used.</li></ul></li><li>decode:<ul><li>the input would be shorten url string</li><li>extract 6 character string from input, search whether it is stored in the map.</li></ul></li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()&#123;</span><br><span class="line">        dist= <span class="string">"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line">        short2long.clear();</span><br><span class="line">        long2short.clear();</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">encode</span><span class="params">(<span class="built_in">string</span> longUrl)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> _return;</span><br><span class="line">        <span class="keyword">if</span>(long2short.find(longUrl) != long2short.end())</span><br><span class="line">            _return = long2short[longUrl];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> idx= <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> tmp=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">                tmp.push_back(dist[rand() % <span class="number">62</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">while</span>(short2long.count(tmp))&#123;</span><br><span class="line">                tmp[idx] = dist[rand() % <span class="number">62</span>];</span><br><span class="line">                idx = (idx +<span class="number">1</span> )%<span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            short2long[tmp] = longUrl;</span><br><span class="line">            long2short[longUrl] = tmp;</span><br><span class="line">            _return = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt; "http://tinyurl.com/"+_return&lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://tinyurl.com/"</span>+_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decode</span><span class="params">(<span class="built_in">string</span> shortUrl)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> _return;</span><br><span class="line">        </span><br><span class="line">        _return = shortUrl.substr(shortUrl.find_last_of(<span class="string">'/'</span>)+<span class="number">1</span>);</span><br><span class="line">        _return = short2long.count(_return) ? short2long[_return]: shortUrl;</span><br><span class="line">        <span class="keyword">return</span> _return;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; short2long, long2short;</span><br><span class="line">    <span class="built_in">string</span> dist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Solution solution;</span></span><br><span class="line"><span class="comment">// solution.decode(solution.encode(url));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> hash table </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>340. Longest Substring with At Most K Distinct Characters</title>
      <link href="/2018/06/06/340-Longest-Substring-with-At-Most-K-Distinct-Characters/"/>
      <url>/2018/06/06/340-Longest-Substring-with-At-Most-K-Distinct-Characters/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a string, find the length of the longest substring T that contains at most k distinct characters.</p><p>For example, Given s = “eceba” and k = 2,</p><p>T is “ece” which its length is 3.</p><p>Solution:<br>This problem is pretty similar to . Just change the checking size part to k.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++m[s[i]];</span><br><span class="line">            <span class="keyword">while</span> (m.size() &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[s[left]] == <span class="number">0</span>) m.erase(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> leetcode </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>159. Longest Substring with At Most Two Distinct Characters</title>
      <link href="/2018/06/06/159-Longest-Substring-with-At-Most-Two-Distinct-Characters/"/>
      <url>/2018/06/06/159-Longest-Substring-with-At-Most-Two-Distinct-Characters/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a string s , find the length of the longest substring t  that contains at most 2 distinct characters.</p><p>Example 1:</p><p>Input: “eceba”<br>Output: 3<br>Explanation: t is “ece” which its length is 3.<br>Example 2:</p><p>Input: “ccaabbb”<br>Output: 5<br>Explanation: t is “aabbb” which its length is 5.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>This question belong to the same category as those such as “longest substring without repeating characters”, “minimum window substring”, and “substring with concatenation of all words”. To solve this kind of question we can use two pointers and a hash table. When the key of the hash table is char, we can simply use an array as the hash table. The most important idea in solving this kind of questions is “how to update the “start” pointer” and the solution to these questions seem usually differ only in this respect.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++m[s[i]];</span><br><span class="line">            <span class="keyword">while</span> (m.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m[s[left]] == <span class="number">0</span>) m.erase(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Solution2:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">-1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">//current position character is the same as previous one</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; s[right] != s[i]) &#123;</span><br><span class="line">                res = max(res, i - left);</span><br><span class="line">                left = right + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//1. first time would be have two different character</span></span><br><span class="line">            <span class="comment">//2. after that, j means: when see different character, then move the end pointer j to previous substring</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(<span class="keyword">int</span>(s.length()) - left, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> leetcode </tag>
            
            <tag> two pointers </tag>
            
            <tag> hash table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/2018/06/06/3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2018/06/06/3-Longest-Substring-Without-Repeating-Characters/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given a string, find the length of the longest substring without repeating characters.</p><p>Examples:</p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a substring, <code>&quot;pwke&quot;</code> is a sub-sequence and not a substring.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>Keep a <code>hashmap</code> which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , meanwhile update the hashmap. If the character is <code>already in the hashmap</code>, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> maxl = <span class="number">0</span>, left= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(s[i]) != <span class="built_in">map</span>.end())&#123; </span><br><span class="line">                <span class="comment">//check whether if the character already in the map</span></span><br><span class="line">                left = max(<span class="built_in">map</span>.find(s[i])-&gt;second, left); <span class="comment">//if we can find, update the left pointer</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[s[i]] = i; <span class="comment">//update the appearance position of the character in map</span></span><br><span class="line">            maxl = max(maxl, i-left); <span class="comment">//max length would remain the same or (cur position-left pointer)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(n)</p><p>reference:<br><a href="https://goo.gl/mUhZjT" target="_blank" rel="noopener">https://goo.gl/mUhZjT</a><br><a href="https://goo.gl/8cQL7W" target="_blank" rel="noopener">https://goo.gl/8cQL7W</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> facebook </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
            <tag> hash table </tag>
            
            <tag> bloomberg </tag>
            
            <tag> adobe </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/2018/06/05/55-Jump-Game/"/>
      <url>/2018/06/05/55-Jump-Game/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>/*<br>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p>Example 1:</p><p>Input: <code>[2,3,1,1,4]</code><br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</p><p>Example 2:</p><p>Input: <code>[3,2,1,0,4]</code><br>Output: false<br>Explanation: You will always arrive at index 3 no matter what. Its maximum<br>             jump length is 0, which makes it impossible to reach the last index.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lastPos = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= lastPos) &#123; <span class="comment">//(current position + steps in this position) &gt; lastPos</span></span><br><span class="line">                lastPos = i;              <span class="comment">//if get to this slot, then we can get to last index</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastPos == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="second-time"><a href="#second-time" class="headerlink" title="second time:"></a>second time:</h1><ul><li>use a pointer <code>reach</code> to denote the farthest position can reach</li><li>use another pointer <code>i</code> to denote the current position. It should be smaller than <code>array size</code> and <code>reach</code>. Because if <code>i</code> reaches the <code>reach</code>, it means the <code>reach</code> derived from previous steps can not reach to <code>i</code>, so will never reach to position <code>i</code>.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> reach=<span class="number">0</span>; <span class="comment">//where is the farest that it can reach</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">//current location</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt; nums.size() &amp;&amp; i&lt;=reach)&#123;</span><br><span class="line">            reach=max(reach, i+nums[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> reach&gt;=nums.size()<span class="number">-1</span>; <span class="comment">//check whether reach is greater than array size</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> microsoft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>18. 4Sum</title>
      <link href="/2018/06/05/18-4Sum/"/>
      <url>/2018/06/05/18-4Sum/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that <code>a + b + c + d = target</code>? Find all unique quadruplets in the array which gives the sum of target.</p><p>Note:</p><p>The solution set must not contain duplicate quadruplets.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>This problem is pretty similar to , the key idea is to downgrade it to 2Sum problems. Other conditions is to increase performance.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; total;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">4</span>)  <span class="keyword">return</span> total;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//skip duplicate element</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt;target) <span class="keyword">break</span>; <span class="comment">//because the array is sorted, if 4 elements start from i is greater than target, no need to do the rest</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[n<span class="number">-3</span>]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>; <span class="comment">//because the array is sorted, if 4 elements start from i is smaller than target, we should keep finding upcoming sequence</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n<span class="number">-2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>; </span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>]&gt;target) <span class="keyword">break</span>; </span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>]&lt;target) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> left=j+<span class="number">1</span>,right=n<span class="number">-1</span>; <span class="comment">//two pointer to search toward right and left</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=nums[left]+nums[right]+nums[i]+nums[j];</span><br><span class="line">                    <span class="keyword">if</span>(sum&lt;target) left++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target) right--;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        total.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">do</span>&#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;<span class="keyword">while</span>(nums[left]==nums[left<span class="number">-1</span>]&amp;&amp;left&lt;right); <span class="comment">//move left at least once then check for duplicate</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">do</span>&#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;<span class="keyword">while</span>(nums[right]==nums[right+<span class="number">1</span>]&amp;&amp;left&lt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>time complexity: $O(n^3)$<br>space complexity: $O(1)$</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>162. Find Peak Element</title>
      <link href="/2018/06/05/162-Find-Peak-Element/"/>
      <url>/2018/06/05/162-Find-Peak-Element/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array nums, where <code>nums[i] ≠ nums[i+1]</code>, find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,1,3,5,6,4]</span><br><span class="line">Output: 1 or 5 </span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, </span><br><span class="line">             or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure><p>Note:<br>Your solution should be in logarithmic complexity.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><ol><li>The question is asking for peaking element, if the sequence have multiple peak, anyone of them is fine.</li><li>We can use <code>sequential find</code> or <code>binary search</code></li></ol><p>We can consider the following case:</p><ul><li><p>Sequence is decreasing<br>If we use a <code>mid</code> pointer to find, then the peak must be on the left side.<br><img src="Find_Peak_Case1.png" alt=""></p></li><li><p>Sequence is increasing<br>The peak is on the right part.<br><img src="Find_Peak_Case2.png" alt=""></p></li><li><p>Peak is in the middle<br><img src="Find_Peak_Case3.png" alt=""></p></li></ul><ul><li>sequential find<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.size(); i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] &lt; num[i<span class="number">-1</span>])</span><br><span class="line">            &#123;<span class="comment">// &lt;</span></span><br><span class="line">                <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: O(n)<br>space complexity: O(1)</p><ul><li>binary search, recursive<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid+<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">return</span> helper(nums, left, mid);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> helper(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: O(logn)<br>space complexity: O(logn). In recursion loop, the search space is reduced in half, so the depth tree is log_2(n)</p><ul><li>binary search, iterative<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt; nums[mid+<span class="number">1</span>])</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>time complexity: O(logn)<br>space complexity: O(1)</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>90. Subsets II</title>
      <link href="/2018/06/05/90-Subsets-II/"/>
      <url>/2018/06/05/90-Subsets-II/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Solution:<br>This question is very similar to <a href="/2018/06/01/39-Combination-Sum/" title="39. Combination Sum">39. Combination Sum</a> and <a href="/2018/06/05/78-Subsets/" title="78. Subsets">78. Subsets</a>. </p><ol><li>Sort the array</li><li>When recursion, we need to check for the duplicate elements, if <code>i</code> is equal to previous item then bypass it</li><li>A major difference is that we need to use <code>i</code> to do the backtrack, instead of <code>pos+1</code> in combination.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        backtrack(res, tmp, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; pos &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            tmp.push_back(nums[i]);</span><br><span class="line">            backtrack(res, tmp, nums, i+<span class="number">1</span>); <span class="comment">//this is the major difference, need to throw in i, instead of pos</span></span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>78. Subsets</title>
      <link href="/2018/06/05/78-Subsets/"/>
      <url>/2018/06/05/78-Subsets/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Solution:<br>DFS + backtracking.<br>This question is very similar to <a href="/2018/06/01/39-Combination-Sum/" title="39. Combination Sum">39. Combination Sum</a>.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        sort(nums.begin(), nums.end())</span><br><span class="line">        backtrack(res, tmp, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        res.push_back(tmp); <span class="comment">//add every set into the result</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            tmp.push_back(nums[i]); <span class="comment">//sequentially add every element in the ressult</span></span><br><span class="line">            backtrack(res, tmp, nums, i+<span class="number">1</span>);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2018/06/05/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
      <url>/2018/06/05/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">Return the following binary tree:</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure></p><p>Solution:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______7______</span><br><span class="line">    /              \</span><br><span class="line"> __10__          ___2</span><br><span class="line">/      \        /</span><br><span class="line">4       3      _8</span><br><span class="line">         \    /</span><br><span class="line">          1  11</span><br></pre></td></tr></table></figure></p><p>The preorder and inorder traversals for the binary tree above is:</p><p>preorder = <code>{7,10,4,3,1,2,8,11}</code><br>inorder = <code>{4,10,3,1,7,11,8,2}</code></p><p>First of all, we can see that preorder’s 1st element <code>7</code> is Root. The element <code>7</code> is the 4th element in inorder sequence. Since there is no duplicate in the sequence, there is no ambiguity.<br>The characteristic of inorder sequence is that it will follow this visit order <code>left-&gt;root-&gt;right</code>; therefore, we can see that the left elements of <code>7</code> is in <code>left subtree</code>. Other elements to the right must be in the <code>right subtree</code>.</p><p>Preorder traversal follows the sequence of <code>root-&gt;left-&gt;right</code>. Therefore, the left and right subtree’s postorder traversal must be {10, 4, 3, 1} and {2, 8, 11} respectively. Since the left and right subtree are binary trees in their own right, we can solve recursively!</p><p>Then how do we search the root value’s index in the inorder sequence?<br>If we use linear search, assume that the constructed binary tree is always balanced, then we can guarantee the run time complexity to be O(N log N), where N is the number of nodes. However, this is not necessarily the case and the constructed binary tree can be skewed to the left/right, which has the worst complexity of O(N^2).</p><p>A more efficient way is to eliminate the search by using an efficient look-up mechanism such as <code>hash table</code>. By hashing an element’s value to its corresponding index in the inorder sequence, we can do look-ups in constant time. Now, we need only O(N) time to construct the tree, which theoretically is the most efficient way.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++) <span class="built_in">map</span>[inorder[i]] = i;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, inorder, <span class="number">0</span>, inorder.size()<span class="number">-1</span>, <span class="built_in">map</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> m1, <span class="keyword">int</span> n1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> m2, <span class="keyword">int</span> n2, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; <span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m1 &gt; n1) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> curindex = <span class="built_in">map</span>[preorder[m1]];</span><br><span class="line">        <span class="keyword">int</span> new_right_m1 = m1 + curindex - m2 + <span class="number">1</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[m1]);</span><br><span class="line">        root-&gt;left = buildTree(preorder, m1+<span class="number">1</span>, new_right_m1<span class="number">-1</span>, inorder, m2, curindex<span class="number">-1</span>, <span class="built_in">map</span>);</span><br><span class="line">        root-&gt;right = buildTree(preorder, new_right_m1, n1, inorder, curindex+<span class="number">1</span>, n2, <span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> array </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Tree traversal</title>
      <link href="/2018/06/04/Tree-traversal/"/>
      <url>/2018/06/04/Tree-traversal/</url>
      <content type="html"><![CDATA[<p>example:<br><img src="tree.png" alt=""></p><p>DFS:<br>Inorder:  (Left, Root, Right), 4 2 5 1 3<br>Preorder: (Root, Left, Right), 1 2 4 5 3<br>Postorder:(Left, Right, Root), 4 5 2 3 1</p><p>BFS:(level order)<br>1 2 3 4 5</p><h1 id="In-Order-Traversal"><a href="#In-Order-Traversal" class="headerlink" title="In-Order Traversal"></a>In-Order Traversal</h1><ul><li>visit left branch, then current node, and finally, the right branch.</li><li><code>Left-&gt;Root-&gt;Right</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    visit(root);</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Pre-Order-Traversal"><a href="#Pre-Order-Traversal" class="headerlink" title="Pre-Order Traversal"></a>Pre-Order Traversal</h1><ul><li>visit current node before its child nodes(hence called pre-order)</li><li>In a pre-order traversal, the root is always the first node visited.</li><li><code>Root-&gt;Left-&gt;Right</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    visit(root);</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Post-Order-Traversal"><a href="#Post-Order-Traversal" class="headerlink" title="Post-Order Traversal"></a>Post-Order Traversal</h1><ul><li>visit current node after its child nodes(hence post-order)</li><li>In a post-order, the root is always the last node visited.</li><li><code>Left-&gt;Right-&gt;Root</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">    visit(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>reference:<br><a href="https://goo.gl/vCGqY8" target="_blank" rel="noopener">https://goo.gl/vCGqY8</a></p>]]></content>
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> tree traversal </tag>
            
            <tag> preorder </tag>
            
            <tag> inorder </tag>
            
            <tag> postorder </tag>
            
            <tag> binary tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>442. Find All Duplicates in an Array</title>
      <link href="/2018/06/04/442-Find-All-Duplicates-in-an-Array/"/>
      <url>/2018/06/04/442-Find-All-Duplicates-in-an-Array/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p><p>Find all the elements that appear twice in this array.</p><p>Could you do it without extra space and in O(n) runtime?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure></p><p>Solution:<br>First of all, we should notice that the number is ranged from <code>1...n</code>. So if we use the <code>value-1</code> as the index, it will not out of range. Therefore, we can use the input array to do the checking. When find a number <code>i</code>, flip the number at position <code>i-1</code> to negative. If the number at position <code>i-1</code> is already negative, <code>i</code> is the number that occurs twice.</p><p>Example:<br>input array: [1,2,2,3]<br>round 1: [-1,2,2,3]<br>round 2: [-1,-2,2,3]<br>round 3: [-1,2,2,3] –&gt; the 2nd element become positive after flipping, so add it to result<br>round 4: [-1,2,-2,3]</p><p>time complexity: O(n)<br>space complexity: O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDuplicates(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            nums[<span class="built_in">abs</span>(nums[i])<span class="number">-1</span>] = -nums[<span class="built_in">abs</span>(nums[i])<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">abs</span>(nums[i])<span class="number">-1</span>] &gt; <span class="number">0</span>) </span><br><span class="line">                res.push_back(<span class="built_in">abs</span>(nums [i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>64. Minimum Path Sum</title>
      <link href="/2018/06/04/64-Minimum-Path-Sum/"/>
      <url>/2018/06/04/64-Minimum-Path-Sum/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p><p>Note: You can only move either down or right at any point in time.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure></p><p>Solution:</p><ol><li>2D array DP<br>Use an extra matrix <code>dp</code> of the same size as the original matrix. In this matrix, <code>dp(i, j)</code> represents the minimum sum of the path from the index <code>(i, j)</code> to the bottom rightmost element. We start by initializing the bottom rightmost element of <code>dp</code> as the last element of the given matrix. Then for each element starting from the bottom right, we traverse backwards and fill in the matrix with the required minimum sums. Now, we need to note that at every element, we can move either rightwards or downwards. Therefore, for filling in the minimum sum, we use the equation:</li></ol><p><code>dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; s = grid;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m<span class="number">-1</span>; j&gt;=<span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == n<span class="number">-1</span> &amp;&amp; j != m<span class="number">-1</span>)    <span class="comment">//edge case, last row</span></span><br><span class="line">                    s[i][j] += s[i][j+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i != n<span class="number">-1</span> &amp;&amp; j == m<span class="number">-1</span>)</span><br><span class="line">                    s[i][j] += s[i+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i != n<span class="number">-1</span> &amp;&amp; j != m<span class="number">-1</span>)</span><br><span class="line">                    s[i][j] = s[i][j] + min(s[i][j+<span class="number">1</span>], s[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(mn)<br>space complexity: O(mn)</p><ol start="2"><li>1D array<br>We can do the same work using a <code>dp</code> array of the row size, since for making the current entry all we need is the dp entry for the bottom and the right element. Thus, we start by initializing only the last element of the array as the last element of the given matrix. The last entry is the bottom rightmost element of the given matrix. Then, we start moving towards the left and update the entry <code>dp(j)</code> as:</li></ol><p><code>dp(j)=grid(i,j)+min(dp(j),dp(j+1))</code></p><p>We repeat the same process for every row as we move upwards. At the end dp(0)dp(0) gives the required minimum sum.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m= grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= n<span class="number">-1</span>; i&gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m<span class="number">-1</span>; j&gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == n<span class="number">-1</span> &amp;&amp; j != m<span class="number">-1</span>) dp[j] = grid[i][j]+ dp[j+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i != n<span class="number">-1</span> &amp;&amp; j == m<span class="number">-1</span>) dp[j] = grid[i][j]+ dp[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i != n<span class="number">-1</span> &amp;&amp; j != m<span class="number">-1</span>) dp[j] = grid[i][j] + min(dp[j], dp[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span> dp[j] = grid[i][j];</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>time complexity: O(mn)<br>space complexity: O(n)</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>377. Combination Sum IV</title>
      <link href="/2018/06/04/377-Combination-Sum-IV/"/>
      <url>/2018/06/04/377-Combination-Sum-IV/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">target = 4</span><br><span class="line"></span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">Note that different sequences are counted as different combinations.</span><br><span class="line"></span><br><span class="line">Therefore the output is 7.</span><br></pre></td></tr></table></figure></p><p>Follow up:</p><ul><li>What if negative numbers are allowed in the given array?</li><li>How does it change the problem?</li><li>What limitation we need to add to the question to allow negative numbers?</li></ul><p>Solution:<br>Think about the recurrence relation first. How does the # of combinations of the target related to the # of combinations of numbers that are smaller than the target?</p><p>So we know that target is the sum of numbers in the array. Imagine we only need one more number to reach target, this number can be any one in the array, right? So the # of combinations of target, comb[target] = sum(comb[target - nums[i]]), where 0 &lt;= i &lt; nums.length, and target &gt;= nums[i].</p><p>In the example given, we can actually find the # of combinations of 4 with the # of combinations of 3(4 - 1), 2(4- 2) and 1(4 - 3). As a result, comb[4] = comb[4-1] + comb[4-2] + comb[4-3] = comb[3] + comb[2] + comb[1].</p><p>In the code, I use a dp array to represent the combination array.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(target + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n) <span class="keyword">break</span>; <span class="comment">//can not use n as i's candidate</span></span><br><span class="line">                dp[i] += dp[i - n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>216. Combination Sum III</title>
      <link href="/2018/06/04/216-Combination-Sum-III/"/>
      <url>/2018/06/04/216-Combination-Sum-III/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p><p>Note:</p><p>All numbers will be positive integers.<br>The solution set must not contain duplicate combinations.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: k = 3, n = 9</span><br><span class="line">Output: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure><p>Solution:<br>DFS + backtracking.<br>This question is very similar to <a href="/2018/06/01/39-Combination-Sum/" title="39. Combination Sum">39. Combination Sum</a> and . However, we need to create the candidates array, or you can use for loop to walk through 1~9.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidates= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        backtrack(candidates, res, tmp, k, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> k, <span class="keyword">int</span> remain, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k ==<span class="number">0</span> &amp;&amp; remain == <span class="number">0</span>) </span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//tmp.size &lt; k, n still need to fill value</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt; candidates.size() &amp;&amp; k&gt;<span class="number">0</span> &amp;&amp; remain&gt;<span class="number">0</span>; i++)&#123;</span><br><span class="line">                tmp.push_back(candidates[i]);</span><br><span class="line">                backtrack(candidates, res, tmp, k<span class="number">-1</span>, remain- candidates[i], i+<span class="number">1</span>);</span><br><span class="line">                tmp.resize(tmp.size()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>40. Combination Sum II</title>
      <link href="/2018/06/01/40-Combination-Sum-II/"/>
      <url>/2018/06/01/40-Combination-Sum-II/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p><p>Each number in candidates may only be used once in the combination.</p><p>Note:</p><p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>DFS + backtracking.<br>This question is very similar to <a href="/2018/06/01/39-Combination-Sum/" title="39. Combination Sum">39. Combination Sum</a>. The only difference is that the candidates array have duplicate elements, and we can not have same combination set in result array.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        backtrack(candidates, tmp, res, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> remain, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>) res.push_back(tmp);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt; candidates.size(); i++)&#123;</span><br><span class="line">                <span class="comment">//skip duplicate, because the question is asked for unique combination</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; pos &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>]) <span class="keyword">continue</span>; </span><br><span class="line">                </span><br><span class="line">                tmp.push_back(candidates[i]);</span><br><span class="line">                backtrack(candidates, tmp, res, remain-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">                tmp.resize(tmp.size()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>39. Combination Sum</title>
      <link href="/2018/06/01/39-Combination-Sum/"/>
      <url>/2018/06/01/39-Combination-Sum/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p><p>The same repeated number may be chosen from candidates unlimited number of times.</p><p>Note:</p><p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: candidates = [2,3,6,7], target = 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: candidates = [2,3,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>DFS + backtracking.<br>In backtrack(), I use the following 5 inputs.</p><ul><li>vector&lt;vector<int>&gt;&amp; res, store every combination here</int></li><li>vector<int>&amp; temp, this is buffer for recursive, increase/decrease element depends on depth of dfs</int></li><li>vector<int>&amp; candidates, </int></li><li>int remain, what we targeting, need to input remain-i when dfs into next level</li><li>int start, this is because we can not have duplicate sets, to record what elements we already passed or visited.</li></ul><p>Time complexity: O(n*2^n)<br>The number of recursive calls, T(n) satisfies the recurrence T(n) = T(n - 1) + T(n - 2) + … + T(1) + T(0),which solves to T(n) = O(2^n). Since we spend O(n) time within a call, the time complexity is O(n2^n);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        backtrack(res, tmp, candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//did not match the target</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) res.push_back(temp); <span class="comment">//put into the result</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt; candidates.size(); i++)&#123;</span><br><span class="line">                <span class="comment">//search candidate[i] have any combanition</span></span><br><span class="line">                temp.push_back(candidates[i]); </span><br><span class="line">                backtrack(res, temp, candidates, remain-candidates[i], i); </span><br><span class="line">                </span><br><span class="line">                temp.resize(temp.size()<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/HkoJaT" target="_blank" rel="noopener">https://goo.gl/HkoJaT</a><br><a href="https://goo.gl/XX6WAv" target="_blank" rel="noopener">https://goo.gl/XX6WAv</a><br><a href="http://www.1point3acres.com/bbs/thread-117602-1-1.html" target="_blank" rel="noopener">http://www.1point3acres.com/bbs/thread-117602-1-1.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>289. Game of Life</title>
      <link href="/2018/06/01/289-Game-of-Life/"/>
      <url>/2018/06/01/289-Game-of-Life/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p><p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p><ul><li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li><li>Any live cell with two or three live neighbors lives on to the next generation.</li><li>Any live cell with more than three live neighbors dies, as if by over-population..</li><li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.<br>Write a function to compute the next state (after one update) of the board given its current state.</li></ul><p>Follow up:<br>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.<br>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>To solve it in place, we use 2 bits to store 2 states:</p><p>[2nd bit, 1st bit] = [next state, current state]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00  dead (next) &lt;- dead (current)</span><br><span class="line">01  dead (next) &lt;- live (current)  </span><br><span class="line">10  live (next) &lt;- dead (current)  </span><br><span class="line">11  live (next) &lt;- live (current)</span><br></pre></td></tr></table></figure></p><ul><li>In the beginning, every cell is either 00 or 01.</li><li>Notice that 1st state is independent of 2nd state.</li><li>Imagine all cells are instantly changing from the 1st to the 2nd state, at the same time.</li><li>Let’s count # of neighbors from 1st state and set 2nd state bit.</li><li>Since every 2nd state is by default dead, no need to consider transition 01 -&gt; 00.</li><li>In the end, delete every cell’s 1st state by doing &gt;&gt; 1.</li></ul><p>For each cell’s 1st bit, check the 8 pixels around itself, and set the cell’s 2nd bit.</p><p>Transition 01 -&gt; 11: when board == 1 and lives &gt;= 2 &amp;&amp; lives &lt;= 3.<br>Transition 00 -&gt; 10: when board == 0 and lives == 3.<br>To get the current state, simply do</p><p>board[i][j] &amp; 1<br>To get the next state, simply do</p><p>board[i][j] &gt;&gt; 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty() || board.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n= board[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> lives = liveNeighbor(board, m,n,i,j);</span><br><span class="line">                <span class="comment">// In the beginning, every 2nd bit is 0;</span></span><br><span class="line">                <span class="comment">// So we only need to care about when will the 2nd bit become 1.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; lives &gt;= <span class="number">2</span> &amp;&amp; lives &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="number">3</span>; <span class="comment">// Make the 2nd bit 1: 01 ---&gt; 11</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span>(board[i][j] ==<span class="number">0</span> &amp;&amp; lives == <span class="number">3</span>)&#123;</span><br><span class="line">                    board[i][j]= <span class="number">2</span>; <span class="comment">// Make the 2nd bit 1: 00 ---&gt; 10</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; n; ++j)</span><br><span class="line">                board[i][j] &gt;&gt;=<span class="number">1</span>; <span class="comment">// Get the 2nd state.</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">liveNeighbor</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lives= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x= max(i<span class="number">-1</span>, <span class="number">0</span>); x&lt;= min(i+<span class="number">1</span>, m<span class="number">-1</span>); x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y= max(j<span class="number">-1</span>, <span class="number">0</span>); y &lt;= min(j+<span class="number">1</span>, n<span class="number">-1</span>); y++)&#123;</span><br><span class="line">                lives+= board[x][y] &amp;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lives -= board[i][j] &amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> lives;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>31. Next Permutation</title>
      <link href="/2018/06/01/31-Next-Permutation/"/>
      <url>/2018/06/01/31-Next-Permutation/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be in-place and use only constant extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><p>index: 0,1,2,3,4,5<br>value: 2,3,6,5,4,1</p><p><strong>1. from right to left, find the first number which not increase in a ascending order. In this case which is 3.</strong><br><strong>2. here we can have two situations:</strong></p><p>We cannot find the number, all the numbers increasing in a ascending order. This means this permutation is the last permutation, we need to rotate back to the first permutation. So we reverse the whole array, for example, 6,5,4,3,2,1 we turn it to 1,2,3,4,5,6.</p><p>We can find the number, then the next step, we will start from right most to leftward, try to find the first number which is larger than 3, in this case it is 4.<br>Then we swap 3 and 4, the list turn to 2,4,6,5,3,1.<br>Last, we reverse numbers on the right of 4, we finally get 2,4,1,3,5,6.</p><p>Time complexity: O(3*n)=O(n).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">-1</span>; <span class="comment">//for checking whether the array is in descending order</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123; <span class="comment">//From right to left, find 1st number that is not ascending order</span></span><br><span class="line">    k = i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span>) &#123; </span><br><span class="line">            <span class="comment">//can not find the number, this means the array is already the largest type, </span></span><br><span class="line">            <span class="comment">//so reverse it would have the smallest</span></span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">-1</span>; <span class="comment">//From right to left, trying to find 1st number that is greater than nums[k]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt; k; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[k]) &#123;</span><br><span class="line">    l = i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    swap(nums[k], nums[l]); </span><br><span class="line">    reverse(nums.begin() + k + <span class="number">1</span>, nums.end()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Another solution:</strong></p><p>Just for info: There’s a library function that does the job, even going from totally reverse sorted to sorted:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    next_permutation(begin(nums), end(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Another Solution</strong></p><p>Using library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of +1/-1, it all fits exactly.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = is_sorted_until(nums.rbegin(), nums.rend());</span><br><span class="line">    <span class="keyword">if</span> (i != nums.rend())</span><br><span class="line">        swap(*i, *upper_bound(nums.rbegin(), i, *i));</span><br><span class="line">    reverse(nums.rbegin(), i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> permutation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>73. Set Matrix Zeroes</title>
      <link href="/2018/05/31/73-Set-Matrix-Zeroes/"/>
      <url>/2018/05/31/73-Set-Matrix-Zeroes/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Follow up:</p><ul><li>A straight forward solution using O(mn) space is probably a bad idea.</li><li>A simple improvement uses O(m + n) space, but still not the best solution.</li><li>Could you devise a constant space solution?</li></ul><p>Solution:</p><ol><li>fr = first row, fc = first col</li><li>Use first row and first column as markers. If matrix[i][j] = 0, mark respected row and col marker = 0 indicating that later this respective row and col must be marked 0; And because you are altering first row and column, we need to have two variables to track their own status. </li><li><p>For example, if any one of the first row is 0, fr = 0, at the end need to set all first row to 0;</p><p>time complexity: O(mn)<br>space complexity: O(1)</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> fr= <span class="literal">false</span>, fc= <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; matrix.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; matrix[<span class="number">0</span>].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>) fr = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j == <span class="number">0</span>) fc = <span class="literal">true</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt; matrix.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt; matrix[<span class="number">0</span>].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>)</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fc)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; matrix.size(); ++i)</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; matrix[<span class="number">0</span>].size(); ++j)</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>79. Word Search</title>
      <link href="/2018/05/31/79-Word-Search/"/>
      <url>/2018/05/31/79-Word-Search/</url>
      <content type="html"><![CDATA[<p>#Problem description:</p><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure><p>#Solution:</p><ol><li>use DFS to find whether the word exist</li><li>create a 2D bool array to record used elements in each DFS, the range should be [rowNum][colNum]</li><li>find word with start in each slot[i][j]</li></ol><p>In auxiliary function:<br>First we check pos is equal to word.length(), return true if it’s the same.<br>Second, if anything is out of range, then return false.<br>Third, return false if (we already visited this slot) || ([i][j] is different from the word[pos])</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.empty() || !word.length()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//nothing in board || nothing in word</span></span><br><span class="line">        <span class="keyword">int</span> rowNum= board.size(), colNum= board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(rowNum, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(colNum, <span class="literal">false</span>)); <span class="comment">//create a visit array to check if visited</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; rowNum; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; colNum; ++j)&#123;</span><br><span class="line">                <span class="comment">//use [i][j] as start point, search for word</span></span><br><span class="line">                <span class="keyword">if</span>(exist(board, visited, word, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="built_in">string</span> word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( i&lt; <span class="number">0</span> || j&lt; <span class="number">0</span> || i&gt; board.size()<span class="number">-1</span> || j&gt;board[<span class="number">0</span>].size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//edge case for size</span></span><br><span class="line">        <span class="keyword">if</span>(visited[i][j] || board[i][j] != word.at(pos)) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="comment">//already came this slot || [i][j] is different from word[pos]</span></span><br><span class="line">        </span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//DFS</span></span><br><span class="line">        <span class="keyword">if</span> (exist(board, visited, word, i - <span class="number">1</span>, j, pos + <span class="number">1</span>) <span class="comment">//check toward left</span></span><br><span class="line">            || exist(board, visited, word, i + <span class="number">1</span>, j, pos + <span class="number">1</span>) <span class="comment">//check toward right</span></span><br><span class="line">            || exist(board, visited, word, i, j - <span class="number">1</span>, pos + <span class="number">1</span>) <span class="comment">//check toward top</span></span><br><span class="line">            || exist(board, visited, word, i, j + <span class="number">1</span>, pos + <span class="number">1</span>)) <span class="comment">//check toward bottom</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        </span><br><span class="line">        visited[i][j] = <span class="literal">false</span>; <span class="comment">//this slot can not make a same search word</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://goo.gl/QLs5yW" target="_blank" rel="noopener">https://goo.gl/QLs5yW</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>287. Find the Duplicate Number</title>
      <link href="/2018/05/31/287-Find-the-Duplicate-Number/"/>
      <url>/2018/05/31/287-Find-the-Duplicate-Number/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>You must not modify the array (assume the array is read only).</li><li>You must use only constant, O(1) extra space.</li><li>Your runtime complexity should be less than O(n2).</li><li>There is only one duplicate number in the array, but it could be repeated more than once.</li></ul><p>Solution:</p><h2 id="1-Floyd’s-Tortoise-and-Hare-Algorithm"><a href="#1-Floyd’s-Tortoise-and-Hare-Algorithm" class="headerlink" title="1. Floyd’s Tortoise and Hare Algorithm"></a>1. Floyd’s Tortoise and Hare Algorithm</h2><p>The first while loop ensures you goes in the correct cycle which has duplicates. For example:<br>index = [0 1 2 3 4 5 6 7]; nums = [5 2 1 3 5 7 6 4].<br>(slow)nums[slow] = (0)5 (5)7 (7)4 (4)5; fast = (0)5 (7)4 (5)7 (4)5; —-&gt; when they meets at (idx=4)(value=5), you know you have a cycle.</p><p>Take a look at the cycle by the indices and values:</p><p>idx: 0—&gt;5—&gt;7—&gt;4–&gt;(goes back to idx=5)</p><p>val: 5—&gt;7—&gt;4—&gt;5–&gt;(goes back to val=7)</p><p>The second while loop will stop when “fast=0” and “slow=4” (their values = 5, the duplicate number). The duplicate number 5 is the reason why the two pointers will meet at a same index (next number). In fact, the second loop will always stop right before they meet at the first item of the cycle. </p><p>*Proof of second step:</p><p>Distance traveled by tortoise while meeting = x + y<br>Distance traveled by hare while meeting = (x + y + z) + y = x + 2y + z<br>Since hare travels with double the speed of tortoise,<br>so 2(x+y)= x+2y+z =&gt; x+2y+z = 2x+2y =&gt; x=z</p><p>Hence by moving tortoise to start of linked list, and making both animals to move one node at a time, they both have same distance to cover .<br>They will reach at the point where the loop starts in the linked list</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">while</span> (slow != fast)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printf("slow:%d, fast:%d\n", slow, fast);</span></span><br><span class="line">                slow = nums[slow];</span><br><span class="line">                fast = nums[nums[fast]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fast = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printf("slow:%d, fast:%d\n", slow, fast);</span></span><br><span class="line">                fast = nums[fast];</span><br><span class="line">                slow = nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf("slow:%d, fast:%d\n", slow, fast);</span></span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Binary-search"><a href="#2-Binary-search" class="headerlink" title="2. Binary search"></a>2. Binary search</h2><p>This solution is based on binary search.</p><p>At first the search space is numbers between 1 to n. Each time I select a number mid (which is the one in the middle) and count all the numbers equal to or less than mid. Then if the count is more than mid, the search space will be [1 mid] otherwise [mid+1 n]. I do this until search space is only one number.</p><p>Let’s say n=10 and I select mid=5. Then I count all the numbers in the array which are less than equal mid. If the there are more than 5 numbers that are less than 5, then by Pigeonhole Principle (<a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pigeonhole_principle</a>) one of them has occurred more than once. So I shrink the search space from [1 10] to [1 5]. Otherwise the duplicate number is in the second half so for the next step the search space would be [6 10].</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high=n;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num&lt;=mid) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"low=%d, high=%d, mid=%d, count=%d\n"</span>, low, high, mid, count);</span><br><span class="line">            <span class="keyword">if</span>(count&gt;mid) high=mid;</span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
            <tag> Floyd&#39;s Tortoise and Hare Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>228. Summary Ranges</title>
      <link href="/2018/05/30/228-Summary-Ranges/"/>
      <url>/2018/05/30/228-Summary-Ranges/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>/*<br>Given a sorted integer array without duplicates, return the summary of its ranges.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:  [0,1,2,4,5,7]</span><br><span class="line">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:  [0,2,3,4,6,8,9]</span><br><span class="line">Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.</span><br></pre></td></tr></table></figure><p>Solution:<br>A range covers consecutive elements. If two adjacent elements have difference larger than 11, the two elements does not belong to the same range.</p><p>To summarize the ranges, we need to know how to separate them. The array is sorted and without duplicates. In such array, two adjacent elements have difference either 1 or larger than 1. If the difference is 1, they should be put in the same range; otherwise, separate ranges.</p><p>We also need to know the start index of a range so that we can put it in the result list. Thus, we keep two indices, representing the two boundaries of current range. For each new element, we check if it extends the current range. If not, we put the current range into the list.</p><p>Don’t forget to put the last range into the list. One can do this by either a special condition in the loop or putting the last range in to the list after the loop.</p><p>Time complexity: O(n)<br>Space complexity: O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; summaryRanges(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            res.push_back(to_string(nums[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur= nums[i];</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt; nums.size() &amp;&amp; (nums[i+<span class="number">1</span>]- nums[i]== <span class="number">1</span>))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != nums[i])</span><br><span class="line">                res.push_back(to_string(cur)+<span class="string">"-&gt;"</span>+to_string(nums[i]));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.push_back(to_string(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>229. Majority Element II</title>
      <link href="/2018/05/30/229-Majority-Element-II/"/>
      <url>/2018/05/30/229-Majority-Element-II/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p><p>Note: The algorithm should run in linear time and in O(1) space.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3,2,3]</span><br><span class="line">Output: [3]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,1,1,3,3,2,2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p>Solution:<br>The essential concepts is you keep a counter for the majority number X. If you find a number Y that is not X, the current counter should deduce 1. The reason is that if there is 5 X and 4 Y, there would be one (5-4) more X than Y. This could be explained as “4 X being paired out by 4 Y”.</p><p>And since the requirement is finding the majority for more than ceiling of [n/3], the answer would be less than or equal to two numbers.<br>So we can modify the algorithm to maintain two counters for two majorities.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; majorityElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> num0 = <span class="number">0</span>, num1 = <span class="number">1</span>, count0 = <span class="number">0</span>, count1 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">            <span class="comment">//find two majority element</span></span><br><span class="line">          <span class="keyword">if</span> (x == num0) count0++;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (x == num1) count1++;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (! count0) num0 = x, count0 = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (! count1) num1 = x, count1 = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> count0--, count1--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//set to zero is because only need to count these two element</span></span><br><span class="line">        count0 = count1 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums)</span><br><span class="line">          <span class="keyword">if</span> (x == num0) count0++;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (x == num1) count1++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (count0 &gt; nums.size()/<span class="number">3</span>) res.push_back(num0);</span><br><span class="line">        <span class="keyword">if</span> (count1 &gt; nums.size()/<span class="number">3</span>) res.push_back(num1);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html" target="_blank" rel="noopener">https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>59. Spiral Matrix II</title>
      <link href="/2018/05/30/59-Spiral-Matrix-II/"/>
      <url>/2018/05/30/59-Spiral-Matrix-II/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res( n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n) );</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( k &lt;= n * n )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">                    <span class="comment">// four steps</span></span><br><span class="line">        <span class="keyword">while</span>( j &lt; n - i )             <span class="comment">// 1. horizonal, left to right</span></span><br><span class="line">        res[i][j++] = k++;</span><br><span class="line">        j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( j &lt; n - i )             <span class="comment">// 2. vertical, top to bottom</span></span><br><span class="line">        res[j++][n-i<span class="number">-1</span>] = k++;</span><br><span class="line">        j = n - i - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>( j &gt; i )                  <span class="comment">// 3. horizonal, right to left </span></span><br><span class="line">        res[n-i<span class="number">-1</span>][j--] = k++;</span><br><span class="line">        j = n - i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( j &gt; i )                  <span class="comment">// 4. vertical, bottom to  top </span></span><br><span class="line">        res[j--][i] = k++;</span><br><span class="line">        i++;      <span class="comment">// next loop</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>54. Spiral Matrix</title>
      <link href="/2018/05/30/54-Spiral-Matrix/"/>
      <url>/2018/05/30/54-Spiral-Matrix/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p>Solution:<br>This is a very simple and easy to understand solution. I traverse right and increment rowBegin, then traverse down and decrement colEnd, then I traverse left and decrement rowEnd, and finally I traverse up and increment colBegin.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()== <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>].size()== <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rowBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowEnd = matrix.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> colBegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> colEnd = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd) &#123;</span><br><span class="line">            <span class="comment">// Traverse Right</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colBegin; j &lt;= colEnd; j ++) &#123;</span><br><span class="line">                res.push_back(matrix[rowBegin][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            rowBegin++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Traverse Down</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowBegin; j &lt;= rowEnd; j ++) &#123;</span><br><span class="line">                res.push_back(matrix[j][colEnd]);</span><br><span class="line">            &#125;</span><br><span class="line">            colEnd--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (rowBegin &lt;= rowEnd) &#123;</span><br><span class="line">                <span class="comment">// Traverse Left</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = colEnd; j &gt;= colBegin; j --) &#123;</span><br><span class="line">                    res.push_back(matrix[rowEnd][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rowEnd--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (colBegin &lt;= colEnd) &#123;</span><br><span class="line">                <span class="comment">// Traver Up</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = rowEnd; j &gt;= rowBegin; j --) &#123;</span><br><span class="line">                    res.push_back(matrix[j][colBegin]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            colBegin ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>16. 3Sum Closest</title>
      <link href="/2018/05/29/16-3Sum-Closest/"/>
      <url>/2018/05/29/16-3Sum-Closest/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></p><p>Solution:</p><p>Sort the vector and then no need to run O(N^3) algorithm as each index has a direction to move.</p><p>The code starts from this formation.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">----------------------------------------------------</span><br><span class="line">^  ^                                               ^</span><br><span class="line">|  |                                               |</span><br><span class="line">|  +- second                                     third</span><br><span class="line">+-first</span><br></pre></td></tr></table></figure></p><p>if nums[first] + nums[second] + nums[third] is smaller than the target, we know we have to increase the sum. so only choice is moving the second index forward.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------</span><br><span class="line">^    ^                                             ^</span><br><span class="line">|    |                                             |</span><br><span class="line">|    +- second                                   third</span><br><span class="line">+-first</span><br></pre></td></tr></table></figure></p><p>if the sum is bigger than the target, we know that we need to reduce the sum. so only choice is moving ‘third’ to backward. of course if the sum equals to target, we can immediately return the sum.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------</span><br><span class="line">^    ^                                          ^</span><br><span class="line">|    |                                          |</span><br><span class="line">|    +- second                                third</span><br><span class="line">+-first</span><br></pre></td></tr></table></figure></p><p>when second and third cross, the round is done so start next round by moving ‘first’ and resetting second and third.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------</span><br><span class="line">  ^    ^                                           ^</span><br><span class="line">  |    |                                           |</span><br><span class="line">  |    +- second                                 third</span><br><span class="line">  +-first</span><br></pre></td></tr></table></figure></p><p>while doing this, collect the closest sum of each stage by calculating and comparing delta. Compare abs(target-newSum) and abs(target-closest). At the end of the process the three indexes will eventually be gathered at the end of the array.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------</span><br><span class="line">                                         ^    ^    ^</span><br><span class="line">                                         |    |    `- third</span><br><span class="line">                                         |    +- second</span><br><span class="line">                                         +-first</span><br></pre></td></tr></table></figure></p><p>if no exactly matching sum has been found so far, the value in closest will be the answer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> closest = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>]; <span class="comment">//pick a sum value to compare</span></span><br><span class="line">        sort(nums.begin(), nums.end()); <span class="comment">//sort the array, takes O(log n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first = <span class="number">0</span> ; first &lt; nums.size()<span class="number">-2</span> ; ++first) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//skip the duplicate items</span></span><br><span class="line">            <span class="keyword">int</span> second = first+<span class="number">1</span>; <span class="comment">//2nd pointer go toward left</span></span><br><span class="line">            <span class="keyword">int</span> third = nums.size()<span class="number">-1</span>; <span class="comment">//3rdd pointer go toward right         </span></span><br><span class="line">            <span class="keyword">while</span>(second &lt; third) &#123; <span class="comment">//use 1st pointer as index, find the set has closest sum</span></span><br><span class="line">                <span class="keyword">int</span> curSum = nums[first]+nums[second]+nums[third];</span><br><span class="line">                <span class="keyword">if</span>(curSum == target) <span class="keyword">return</span> curSum;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(target-curSum)&lt;<span class="built_in">abs</span>(target-closest)) &#123;</span><br><span class="line">                    closest = curSum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curSum &gt; target) &#123; <span class="comment">//because the array is sorted, we can decide where the pointer should move.</span></span><br><span class="line">                    --third;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>81. Search in Rotated Sorted Array II</title>
      <link href="/2018/05/29/81-Search-in-Rotated-Sorted-Array-II/"/>
      <url>/2018/05/29/81-Search-in-Rotated-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).</p><p>You are given a target value to search. If found in the array return true, otherwise return false.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p>Follow up:</p><p>This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.<br>Would this affect the run-time complexity? How and why?</p><p>Solution:</p><p>1) everytime check if targe == nums[mid], if so, we find it.<br>2) otherwise, we check if the first half is in order (i.e. nums[left]&lt;=nums[mid])<br>  and if so, go to step 3), otherwise, the second half is in order,   go to step 4)<br>3) check if target in the range of [left, mid-1] (i.e. nums[left]&lt;=target &lt; nums[mid]), if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;<br>4)  check if target in the range of [mid+1, right] (i.e. nums[mid]&lt;target &lt;= nums[right]), if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1;</p><p>The only difference is that due to the existence of duplicates, we can have nums[left] == nums[mid] and in that case, the first half could be out of order (i.e. NOT in the ascending order, e.g. [3 1 2 3 3 3 3]) and we have to deal this case separately. In that case, it is guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]== nums[left] == nums[right] before the original logic, and if so, we can move left and right both towards the middle by 1. and repeat.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right =  nums.size()<span class="number">-1</span>, mid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// the only difference from the first one, trickly case, just updat left and right</span></span><br><span class="line">            <span class="keyword">if</span>( (nums[left] == nums[mid]) &amp;&amp; (nums[right] == nums[mid]) ) &#123;++left; --right;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left] &lt;= nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( (nums[left]&lt;=target) &amp;&amp; (nums[mid] &gt; target) ) right = mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[mid] &lt; target) &amp;&amp;  (nums[right] &gt;= target) ) left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>153. Find Minimum in Rotated Sorted Array</title>
      <link href="/2018/05/25/153-Find-Minimum-in-Rotated-Sorted-Array/"/>
      <url>/2018/05/25/153-Find-Minimum-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p><p>Find the minimum element.</p><p>You may assume no duplicate exists in the array.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3,4,5,1,2] </span><br><span class="line">Output: 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p><p>Solution:<br>Case 1. The leftmost value is less than the rightmost value in the list: This means that the list is not rotated.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1 2 3 4 5 6 7 ]</span><br></pre></td></tr></table></figure></p><p>Case 2. The value in the middle of the list is greater than the leftmost and rightmost values in the list.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 4 5 6 7 0 1 2 3 ]</span><br></pre></td></tr></table></figure></p><p>Case 3. The value in the middle of the list is less than the leftmost and rightmost values in the list.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 5 6 7 0 1 2 3 4 ]</span><br></pre></td></tr></table></figure></p><p>As you see in the examples above, if we have case 1, we just return the leftmost value in the list. If we have case 2, we just move to the right side of the list. If we have case 3 we need to move to the left side of the list.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=num.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (start&lt;end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[start]&lt;num[end])</span><br><span class="line">                <span class="keyword">return</span> num[start];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num[mid]&gt;=num[start]) &#123;</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>48. Rotate Image</title>
      <link href="/2018/05/25/48-Rotate-Image/"/>
      <url>/2018/05/25/48-Rotate-Image/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>You are given an n x n 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><p>Note:</p><p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given input matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ul><li>clockwise rotate:<br>first reverse up to down, then swap the symmetry <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     7 8 9     7 4 1</span><br><span class="line">4 5 6  =&gt; 4 5 6  =&gt; 8 5 2</span><br><span class="line">7 8 9     1 2 3     9 6 3</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    reverse(matrix.begin(), matrix.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>anticlockwise rotate:<br>first reverse left to right, then swap the symmetry<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3     3 2 1     3 6 9</span><br><span class="line">4 5 6  =&gt; 6 5 4  =&gt; 2 5 8</span><br><span class="line">7 8 9     9 8 7     1 4 7</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vi : matrix) reverse(vi.begin(), vi.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</span><br><span class="line">            swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>369. Plus One Linked List</title>
      <link href="/2018/05/21/369-Plus-One-Linked-List/"/>
      <url>/2018/05/21/369-Plus-One-Linked-List/</url>
      <content type="html"><![CDATA[<p>Problem Description:<br>Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.</p><p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p><p>The digits are stored such that the most significant digit is at the head of the list.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:</span><br><span class="line">1-&gt;2-&gt;3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">1-&gt;2-&gt;4</span><br></pre></td></tr></table></figure></p><p>Solution:<br>The key point is to find 9’s.<br>For example: 8-&gt;7-&gt;9-&gt;9<br>Add dummy: 0-&gt;8-&gt;7-&gt;9-&gt;9<br>The lastNotNine is 7.<br>7 + 1 = 8<br>9 change to 0.<br>We got 0-&gt;8-&gt;8-&gt;0-&gt;0<br>return dummy.next</p><p>For example: 9-&gt;9-&gt;9<br>Add dummy: 0-&gt;9-&gt;9-&gt;9<br>The lastNotNine is 0.<br>0 + 1 = 1<br>9 change to 0.<br>We got 1-&gt;0-&gt;0-&gt;0<br>return dummy</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">plusOne</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode* dmy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* lastNot9 = dmy;</span><br><span class="line">        dmy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* n = head; n != <span class="literal">NULL</span>; n = n-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n-&gt;val != <span class="number">9</span>) lastNot9 = n; <span class="comment">/* invariant: [lastNot9.next, tail] are all 9*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        lastNot9-&gt;val++;</span><br><span class="line">        <span class="keyword">for</span> (ListNode* n = lastNot9-&gt;next; n != <span class="literal">NULL</span>; n = n-&gt;next) &#123;</span><br><span class="line">            n-&gt;val = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dmy-&gt;val == <span class="number">1</span> ? dmy : head;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>445. Add Two Numbers II</title>
      <link href="/2018/05/19/445-Add-Two-Numbers-II/"/>
      <url>/2018/05/19/445-Add-Two-Numbers-II/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Follow up:<br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: (6 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 6 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure></p><p>Solution:<br>This question is a followup from “2. Add two number.” The different part is that the significant digit comes first. However, we need to start from least significant digit when we do calculation. Even though the question states that you can not modify the input list, we can use a stack, first in last out, to achieve the reverse order calculation.</p><p>Space: O(n)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1, s2;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s1.push(l1-&gt;val);</span><br><span class="line">            l1= l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s2.push(l2-&gt;val);</span><br><span class="line">            l2= l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum= <span class="number">0</span>;</span><br><span class="line">        ListNode* <span class="built_in">list</span>= <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() ||!s2.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!s1.empty()) &#123;</span><br><span class="line">                sum += s1.top();</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s2.empty())&#123;</span><br><span class="line">                sum += s2.top();  </span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="built_in">list</span>-&gt;val = sum %<span class="number">10</span>;</span><br><span class="line">            ListNode* head = <span class="keyword">new</span> ListNode(sum/<span class="number">10</span>);</span><br><span class="line">            head-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">            <span class="built_in">list</span> = head;</span><br><span class="line">            sum/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>-&gt;val ==<span class="number">0</span> ? <span class="built_in">list</span>-&gt;next: <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/2018/05/15/15-3Sum/"/>
      <url>/2018/05/15/15-3Sum/</url>
      <content type="html"><![CDATA[<h3 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h3><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:</p><p>The solution set must not contain duplicate triplets.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h3><ol><li>Sort the array</li><li>Pick indices from 0…n-2. To n-2 is because we need to find 3 item sequence. If we sort the array, need to at least save one spot for right element.</li><li>Bypass duplicate element</li><li>Use two pointers, one goes from i+1 toward right, the other one goes from n toward left</li><li>If the sum of two pointers can not make the sequence zero, move the point.<br>To clarify, we can only move one pointer to make the result close to zero.</li></ol><p>Example:<br>input nums<code>[-1, 0, 1, 2, -1, -4]</code><br>sort  nums<code>[-4, -1, -1, 0, 1, 2]</code></p><p>start from nums[0]= -4, pointer1= nums[1], pointer2= nums[6-1]</p><p>Solution:<br>Time: <code>O(n^2)</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span>) <span class="keyword">return</span> res; <span class="comment">//edge case check</span></span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-2</span>; ++i)&#123; <span class="comment">//-2 is because last possible 3Sum sequence could be last 3 item, </span></span><br><span class="line">                                                <span class="comment">//and the center is n-2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="comment">//pass duplicate elements</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>, k=nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span>-nums[i]; <span class="comment">//because the other two elements would make sequence zero</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(j&lt; k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]+ nums[k] == target)&#123;</span><br><span class="line">                    res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j], nums[k]&#125;);</span><br><span class="line">                    j++;</span><br><span class="line">                    k--;</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k &amp;&amp; nums[j]==nums[j<span class="number">-1</span>]) j++;<span class="comment">//skip same element</span></span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k &amp;&amp; nums[k]==nums[k+<span class="number">1</span>]) k--;<span class="comment">//skip same element</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[j]+ nums[k]&gt;target)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="second-time"><a href="#second-time" class="headerlink" title="second time"></a>second time</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        /*</span><br><span class="line">        1. sort array</span><br><span class="line">        2. totally three pointers, one pointer as a start point, other two traverse</span><br><span class="line">        3. two traverse pointer, left and right, decrease or increase beased on different conditions</span><br><span class="line">        */</span><br><span class="line">        if(nums.size()&lt; 3) return vector&lt;vector&lt;int&gt;&gt;();</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(int i= 0; i&lt; nums.size()-2; i++)&#123;</span><br><span class="line">            if(i&gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;</span><br><span class="line">            int left= i+1, right= nums.size()-1;</span><br><span class="line">            while(left&lt; right)&#123;</span><br><span class="line">                int result= nums[i]+ nums[left]+ nums[right];</span><br><span class="line">                if(result == 0) &#123;</span><br><span class="line">                    res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left++], nums[right--]&#125;);</span><br><span class="line">                    while(left&lt; right &amp;&amp; nums[left]== nums[left-1]) left++;</span><br><span class="line">                    while(left&lt; right &amp;&amp; nums[right]== nums[right+1]) right--;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(result &lt; 0) left++;</span><br><span class="line">                else right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> facebook </tag>
            
            <tag> microsoft </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> array </tag>
            
            <tag> amazon </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>413. Arithmetic Slices</title>
      <link href="/2018/05/14/413-Arithmetic-Slices/"/>
      <url>/2018/05/14/413-Arithmetic-Slices/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p><p>For example, these are arithmetic sequence:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure></p><p>The following sequence is not arithmetic.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure></p><p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p><p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p><p>The function should return the number of arithmetic slices in the array A.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.</span><br></pre></td></tr></table></figure></p><p>solution1:</p><p>use 1D dp array. When we have a arithmetic slice in 1…i, which can create total X arithmetic slice, and we got the i+1 element with same distance(slice) as before, the i+1 element can create additional X+1 arithmetic slice. And the sum of arithmetic slices create by sequence 1…i+1 elements would be X+(X+1).<br>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      1,3,5,7,9,15,20,25,28,29</span><br><span class="line">dp    0 0 1 2 3 0  0  1  0  0</span><br><span class="line">sum       1 3 6 6  6  7  7  7</span><br></pre></td></tr></table></figure></p><p>In the above example, [1,3,5] can make the first slice.<br>When we add 7 into the sequence, it creates [3,5,7] and [1,3,5,7] slices.<br>Therefore, total slices when we consider sequence [1,3,5,7] would be<br>[1,3,5]: which is created and stored in dp[2]<br>[3,5,7], [1,3,5,7]: in dp[3]<br>Total: 3 slices</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(A.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span> + dp[i - <span class="number">1</span>];</span><br><span class="line">                sum += dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Time: O(n)<br>Space: O(n)</p><p>solution2:<br>Since if we don’t have consecutive sequence, we don’t need the dp. We can use a integer to store the slices created by previous consecutive sequence. When the consecutive sequence end, A[i]-A[i-1] != A[i-1]-A[i-2], just reset the counter to zero.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp+=<span class="number">1</span>;</span><br><span class="line">                sum += dp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Time: O(n)<br>Space: O(1)</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>357. Count Numbers with Unique Digits</title>
      <link href="/2018/05/14/357-Count-Numbers-with-Unique-Digits/"/>
      <url>/2018/05/14/357-Count-Numbers-with-Unique-Digits/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n.</p><p>Example:<br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</p><p>Following the hint. Let f(n) = count of number with unique digits of length n.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f(1) = 10. (0, 1, 2, 3, ...., 9)</span><br><span class="line"></span><br><span class="line">f(2) = 9 * 9. Because for each number i from 1, ..., 9, we can pick j to form a 2-digit number ij and there are 9 numbers that are different from i for j to choose from.</span><br><span class="line"></span><br><span class="line">f(3) = f(2) * 8 = 9 * 9 * 8. Because for each number with unique digits of length 2, say ij, we can pick k to form a 3 digit number ijk and there are 8 numbers that are different from i and j for k to choose from.</span><br><span class="line"></span><br><span class="line">Similarly f(4) = f(3) * 7 = 9 * 9 * 8 * 7....</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">f(10) = 9 * 9 * 8 * 7 * 6 * ... * 1</span><br><span class="line"></span><br><span class="line">f(11) = 0 = f(12) = f(13)....</span><br></pre></td></tr></table></figure></p><p>any number with length &gt; 10 couldn’t be unique digits number.</p><p>The problem is asking for numbers from 0 to 10^n. Hence return f(1) + f(2) + .. + f(n)</p><p>As @4acreg suggests, There are only 11 different ans. You can create a lookup table for it. This problem is O(1) in essence</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">10</span>, base = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n &amp;&amp; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            base *= (<span class="number">9</span> - i + <span class="number">2</span>);</span><br><span class="line">            ans += base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">        if(n == 0) return 1;</span><br><span class="line">        int res = 10; //original case</span><br><span class="line">        int uniqueDigits = 9;</span><br><span class="line">        int available = 9;</span><br><span class="line">        </span><br><span class="line">        while(n-- &gt;1 &amp;&amp; available &gt;0)&#123;</span><br><span class="line">            uniqueDigits = uniqueDigits* available; //recursively multiply the remain digits</span><br><span class="line">            res += uniqueDigits; //The answer ask from 0&lt;=x&lt;= 10^n, so need to add the result</span><br><span class="line">            available--;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        */</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> backtracking </tag>
            
            <tag> google </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>95. Unique Binary Search Trees II</title>
      <link href="/2018/05/14/95-Unique-Binary-Search-Trees-II/"/>
      <url>/2018/05/14/95-Unique-Binary-Search-Trees-II/</url>
      <content type="html"><![CDATA[<p>Problem description:</p><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&apos;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><p>Tree can be divided into three parts<br>Picking ith element in 1…n sequence, the subtree would be<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  V       </span><br><span class="line"> / \      L: 1...i-1</span><br><span class="line">L   R     R: i+1...n</span><br></pre></td></tr></table></figure></p><p>Therefore, we need a function that could generate trees that take 2 inputs, start and end.<br>By recursively calling this subfunction, we can generate different trees.<br>One thing to notice is that, after the recursive, we should have a root node to catch these different left and right trees.<br>That is to say, if we have sequence [1,2,3,4,5] and we pick 3 as root.<br>L would be [1,2], R [4,5].<br>It’s easy to see that the Left tree could have these two shape.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1        2                                                                       3           3</span><br><span class="line">  / \      / \          ==adding the subtree to left side with 3 as root ==&gt;       /           /</span><br><span class="line">null 2    1   null                                                                1           2</span><br><span class="line">                                                                                 / \         / \</span><br><span class="line">                                                                               null 2       1  null</span><br></pre></td></tr></table></figure></p><p>The right part is the same, so I just draw left part on it.<br>Finally, push the new tree to the vector and return it to upper recursive.</p><p>time: O(catalan(n)), <a href="https://goo.gl/umK2Fl" target="_blank" rel="noopener">https://goo.gl/umK2Fl</a><br>space: O(log(n)), tree space is log(n) with total node n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">  struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">      int val;</span></span><br><span class="line"><span class="comment">      TreeNode *left;</span></span><br><span class="line"><span class="comment">      TreeNode *right;</span></span><br><span class="line"><span class="comment">      TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">return</span> genTree(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; genTree(<span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">            <span class="built_in">list</span>.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="built_in">list</span>.push_back(<span class="keyword">new</span> TreeNode(start));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; left, right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= start; i&lt;= end; ++i)&#123;</span><br><span class="line">            left = genTree(start, i<span class="number">-1</span>);</span><br><span class="line">            right = genTree(i+<span class="number">1</span>,end);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> lnode: left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> rnode: right)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = lnode;</span><br><span class="line">                    root-&gt;right = rnode;</span><br><span class="line">                    <span class="built_in">list</span>.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>96. Unique Binary Search Trees</title>
      <link href="/2018/05/13/96-Unique-Binary-Search-Trees/"/>
      <url>/2018/05/13/96-Unique-Binary-Search-Trees/</url>
      <content type="html"><![CDATA[<h1 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description:"></a>Problem description:</h1><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&apos;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h1><p>The problem can be solved in a dynamic programming way. I’ll explain the intuition and formulas in the following.</p><p>Given a sequence 1…n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1…(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)…n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique, since they have unique roots.</p><p>The problem is to calculate the number of unique BST. To do so, we need to define two functions:</p><p>G(n): the number of unique BST for a sequence of length n.</p><p>F(i, n), 1 &lt;= i &lt;= n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n.</p><p>As one can see, G(n) is the actual function we need to calculate in order to solve the problem. And G(n) can be derived from F(i, n), which at the end, would recursively refer to G(n).</p><p>First of all, given the above definitions, we can see that the total number of unique BST G(n), is the sum of BST F(i) using each number i as a root.<br>i.e.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G(n) = F(1, n) + F(2, n) + ... + F(n, n).</span><br></pre></td></tr></table></figure></p><p>Particularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree).<br>i.e.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G(0)=1, G(1)=1.</span><br></pre></td></tr></table></figure></p><p>Given a sequence 1…n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root F(i), is the cartesian product of the number of BST for its left and right subtrees. For example, F(3, 7): the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence [1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine them together (i.e. cartesian product). The tricky part is that we could consider the number of unique BST out of sequence [1,2] as G(2), and the number of of unique BST out of sequence [4, 5, 6, 7] as G(4). Therefore, F(3,7) = G(2) * G(4).</p><p>i.e.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F(i, n) = G(i-1) * G(n-i)1 &lt;= i &lt;= n</span><br></pre></td></tr></table></figure></p><p>Combining the above two formulas, we obtain the recursive formula for G(n). i.e.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)</span><br></pre></td></tr></table></figure></p><p>In terms of calculation, we need to start with the lower number, since the value of G(n) depends on the values of G(0) … G(n-1).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        G[<span class="number">0</span>] = G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; ++j) &#123;</span><br><span class="line">                G[i] += G[j<span class="number">-1</span>] * G[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Second time<br>Remembered the idea. elaborate the idea below.<br>Use [1,2,3,4,5] as example</li></ul><ol><li><p>Draw graph with each element to be root.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">  [2,3,4,5]</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line"> [1] [3,4,5]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">[1,2] [4,5]</span><br><span class="line"></span><br><span class="line">      4</span><br><span class="line">     / \</span><br><span class="line">[1,2,3] [5]</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     /  </span><br><span class="line">[1,2,3,4]</span><br></pre></td></tr></table></figure></li><li><p>number of Tree with <code>i</code> as root: <code>T(i)= T(i-1)*T(n-i)</code>, 1&lt;=i&lt;=n</p></li><li>problem description ask for total number of trees from <code>1...i</code>, so need to add it together.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]= dp[<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;= i; j++)&#123;</span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> medium </tag>
            
            <tag> snapchat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>221. Maximal Square</title>
      <link href="/2018/05/12/221-Maximal-Square/"/>
      <url>/2018/05/12/221-Maximal-Square/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p><p>solution1:<br>time: O(mn)<br>space: O(mn)<br><img src="221_Maximal_Square.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = m&gt;<span class="number">0</span> ? matrix[<span class="number">0</span>].size(): <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j<span class="number">-1</span>], min(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>])) +<span class="number">1</span>;</span><br><span class="line">                    maxlen = max(maxlen, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen*maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>solution2:<br>time: O(mn)<br>space: O(n)<br><img src="221_Maximal_Square1.png" alt=""><br>dp[j] is to store the square that can be made in this<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        int m = matrix.size(), n = m&gt;0 ? matrix[0].size(): 0;</span><br><span class="line">        </span><br><span class="line">        vector&lt;int&gt; dp(n+1, 0);</span><br><span class="line">        int maxlen = 0, prev= 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i&lt;= m; ++i)&#123;</span><br><span class="line">            for(int j= 1; j&lt;= n; ++j)&#123;</span><br><span class="line">                int temp = dp[j];</span><br><span class="line">                //cout&lt;&lt; &quot;dp[&quot;&lt;&lt;j&lt;&lt;&quot;]:&quot;&lt;&lt;dp[j]&lt;&lt;endl;</span><br><span class="line">                //cout&lt;&lt;&quot;temp:&quot;&lt;&lt; temp&lt;&lt;endl;</span><br><span class="line">                if(matrix[i-1][j-1] == &apos;1&apos;)&#123;</span><br><span class="line">                    dp[j] = min(dp[j-1], min(prev, dp[j]))+1;</span><br><span class="line">                    //+1 is because if this element is &apos;1&apos;, it at least can form a square by itself even previous is 0</span><br><span class="line">                    //cout&lt;&lt; &quot;dp[&quot;&lt;&lt;j&lt;&lt;&quot;-1]:&quot;&lt;&lt;dp[j-1];</span><br><span class="line">                    //cout&lt;&lt; &quot;, prev:&quot;&lt;&lt;prev;</span><br><span class="line">                    //cout&lt;&lt; &quot;, dp[&quot;&lt;&lt;j&lt;&lt;&quot;]:&quot;&lt;&lt;dp[j]&lt;&lt;endl;</span><br><span class="line">                    //dp[i][j] = min(dp[i][j-1], min(dp[i-1][j], dp[i-1][j-1])) +1;</span><br><span class="line">                    maxlen = max(maxlen, dp[j]);</span><br><span class="line">                    //cout&lt;&lt;&quot;max=&quot;&lt;&lt;maxlen&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    dp[j] = 0;</span><br><span class="line">                    //cout&lt;&lt; &quot;else dp[&quot;&lt;&lt;j&lt;&lt;&quot;]:&quot;&lt;&lt;dp[j]&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">                prev= temp;</span><br><span class="line">                //cout&lt;&lt;&quot;----&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto n: dp)</span><br><span class="line">            cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;endl;</span><br><span class="line">        return maxlen*maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> apple </tag>
            
            <tag> leetcode </tag>
            
            <tag> medium </tag>
            
            <tag> airbnb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>85. Maximal Rectangle</title>
      <link href="/2018/05/12/85-Maximal-Rectangle/"/>
      <url>/2018/05/12/85-Maximal-Rectangle/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(matrix.size() &lt;= <span class="number">0</span> || matrix[<span class="number">0</span>].size()&lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size() + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//take care of the size, because we need to calculate the item in stack twice</span></span><br><span class="line">        <span class="comment">//just like 84., also need to push last item to the stack</span></span><br><span class="line">        <span class="keyword">int</span> h= <span class="number">0</span>, w= <span class="number">0</span>, ret= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; height(n, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; m; ++i)&#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; n; ++j)&#123;</span><br><span class="line">                <span class="comment">//set height, </span></span><br><span class="line">                <span class="keyword">if</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//this is to check whether the j is the extra boundary case we need to calculate</span></span><br><span class="line">                    <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>) height[j]+= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> height[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//this is pretty similiar to 84</span></span><br><span class="line">                <span class="keyword">while</span>(!s.empty() &amp;&amp; height[s.top()] &gt;= height[j])&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt; s.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    h = height[s.top()];</span><br><span class="line">                    s.pop();</span><br><span class="line">                    w = s.empty() ? j: j-s.top()<span class="number">-1</span>;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt; <span class="string">"h= "</span>&lt;&lt; h&lt;&lt;<span class="string">", w= "</span>&lt;&lt;w&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">if</span>(h*w &gt; ret) ret = h*w;</span><br><span class="line">                &#125;</span><br><span class="line">                s.push(j);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt; <span class="string">"j= "</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;   </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://goo.gl/3yW7Xc" target="_blank" rel="noopener">https://goo.gl/3yW7Xc</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic programming </tag>
            
            <tag> facebook </tag>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> hash table </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>84. Largest Rectangle in Histogram</title>
      <link href="/2018/05/12/84-Largest-Rectangle-in-Histogram/"/>
      <url>/2018/05/12/84-Largest-Rectangle-in-Histogram/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>  Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br>  <img src="1.png" alt=""><br>  Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].<br>  <img src="2.png" alt=""><br>  The largest rectangle is shown in the shaded area, which has area = 10 unit.</p><p>  Example:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        height.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n: height)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt; <span class="string">"i: "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">4</span>) <span class="built_in">cout</span>&lt;&lt;index.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">while</span>(index.size() &gt; <span class="number">0</span> &amp;&amp; height[index.back()] &gt;= height[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> h = height[index.back()];</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt; <span class="string">"h:"</span> &lt;&lt;h;</span><br><span class="line">                    index.pop_back();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">int</span> sidx = index.size() &gt; <span class="number">0</span> ? index.back() : <span class="number">-1</span>;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt; <span class="string">", sidx:"</span> &lt;&lt;sidx;</span><br><span class="line">                    <span class="keyword">if</span>(h * (i-sidx<span class="number">-1</span>) &gt; ret)</span><br><span class="line">                        ret = h * (i-sidx<span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt; <span class="string">", calculate:"</span> &lt;&lt;h * (i-sidx<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt; <span class="string">"ret: "</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                index.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Second-time"><a href="#Second-time" class="headerlink" title="Second time"></a>Second time</h1><p>This is a relatively straightforward solution. Use a pointer to find toward right, if a histogram <code>i</code> is greater than <code>i+1</code>, then we find a left boundary of this histogram <code>i</code>. At this time, we traverse back toward left, find every <code>minimum height</code> and multiply with the width to get the area.<br>指針往右遍歷, 當height[i]&lt; height[i+1]: keep go right, 因如果後面比較高, 則maximum area 至少包含後面的 histogram.</p><p>example:<br><code>[2,4,6,5,3]</code></p><ol><li>reach 6, next is 5.<br> minimum height* width= area<pre><code>6*1= 64*2= 82*3= 6</code></pre></li><li>reach 5, next is 3, smaller than 5.<pre><code>5*1= 55*2= 104*3= 122*4= 8</code></pre></li><li>reach 3, end condition<pre><code>3*1= 33*2= 63*3= 93*4= 122*5= 10</code></pre></li><li>max area is 12</li></ol><p>#Solution:</p><pre><code class="c++"><span class="comment">//O(n^2)</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span><span class="keyword">public</span>:    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>{        <span class="keyword">int</span> res= <span class="number">0</span>;        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; heights.size(); i++){ <span class="comment">//go toward left</span>            <span class="keyword">if</span>(i== heights.size()<span class="number">-1</span> || heights[i]&gt; heights[i+<span class="number">1</span>]){ <span class="comment">//reached end || height[i]&gt; height[i+1]</span>                <span class="keyword">int</span> minh= heights[i];                <span class="keyword">for</span>(<span class="keyword">int</span> j= i; j&gt;=<span class="number">0</span>; j--){ <span class="comment">//go toward right, find every rectangle</span>                    minh= min(minh, heights[j]);                    <span class="keyword">int</span> area= minh* (i-j+<span class="number">1</span>);                    res= max(res, area);                }            }        }        <span class="keyword">return</span> res;    }};</code></pre><p>  Reference:<br>  <a href="https://goo.gl/JusVW4" target="_blank" rel="noopener">https://goo.gl/JusVW4</a><br>  leetcode.com/problems/maximal-rectangle/discuss/29054/Share-my-DP-solution/27983</p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> leetcode </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>72. Edit Distance</title>
      <link href="/2018/05/11/72-Edit-Distance/"/>
      <url>/2018/05/11/72-Edit-Distance/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>  Given two words word1 and word2, find the minimum number of operations required to<br>  convert word1 to word2.</p><p>  You have the following 3 operations permitted on a word:</p><p>  Insert a character<br>  Delete a character<br>  Replace a character<br>  Example 1:</p><p>  Input: word1 = “horse”, word2 = “ros”<br>  Output: 3<br>  Explanation:<br>  horse -&gt; rorse (replace ‘h’ with ‘r’)<br>  rorse -&gt; rose (remove ‘r’)<br>  rose -&gt; ros (remove ‘e’)<br>  Example 2:</p><p>  Input: word1 = “intention”, word2 = “execution”<br>  Output: 5<br>  Explanation:<br>  intention -&gt; inention (remove ‘t’)<br>  inention -&gt; enention (replace ‘i’ with ‘e’)<br>  enention -&gt; exention (replace ‘n’ with ‘x’)<br>  exention -&gt; exection (replace ‘n’ with ‘c’)<br>  exection -&gt; execution (insert ‘u’)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n= word2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//convert word2 to word1 if word2 is empty, so the operation is m times</span></span><br><span class="line">        <span class="comment">//ex: word1: "ABCDE", word2= ""  </span></span><br><span class="line">        <span class="comment">//notice: start from 1 because dp[i][j] denotes word1[0...i-1] are the same as word2[0...j-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= m; ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//convert word1 to word2 if word1 is empty, so the operation is n times</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;= n; ++i)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span>; j&lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//replace: means till the dp[i-1][j-1] is the same, add 1 operation by replacement</span></span><br><span class="line">                    <span class="comment">//  example: word1: "ABCDE", word2: "ABCDF" </span></span><br><span class="line">                    <span class="comment">//           therefore, only needs to 1 move based on dp[i-1][j-1]</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//deletion: the question is convert from word1 to word2, </span></span><br><span class="line">                    <span class="comment">//          means till the dp[i-1][j] is the same, add 1 ...</span></span><br><span class="line">                    <span class="comment">//  example: word1: "ABCDE", word2: "ABCD". i=4 j=3</span></span><br><span class="line">                    <span class="comment">//           add 1 move based on dp[i-1][j]</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//insertion: the question is convert from word1 to word2, </span></span><br><span class="line">                    <span class="comment">//          means till the dp[i][j-1] is the same, add 1 ...</span></span><br><span class="line">                    <span class="comment">//  example: word1: "ABCD", word2: "ABCDE". i=3 j=4</span></span><br><span class="line">                    <span class="comment">//           add 1 move based on dp[i][j-1]</span></span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>, min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>, dp[i][j<span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hard </tag>
            
            <tag> string </tag>
            
            <tag> dynamic programming </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>companylist</title>
      <link href="/2018/04/20/companylist/"/>
      <url>/2018/04/20/companylist/</url>
      <content type="html"><![CDATA[<p>——已推——</p><p>  Aurora Innovation 8/13, not refer<br>  <a href="https://goo.gl/14Cfq6" target="_blank" rel="noopener">https://goo.gl/14Cfq6</a></p><p>  Walmart Sam’s Club Technology 8/14, 8/29 tech interview<br>  <a href="https://goo.gl/BWxxLS" target="_blank" rel="noopener">https://goo.gl/BWxxLS</a></p><p>  FB, 8/15, 8/17 recruiter, 8/27 phone interview<br>  <a href="http://www.1point3acres.com/bbs/thread-435755-1-1.html" target="_blank" rel="noopener">http://www.1point3acres.com/bbs/thread-435755-1-1.html</a><br>  <a href="https://www.facebook.com/careers/jobs/a0I1H00000LCQMWUA5/" target="_blank" rel="noopener">https://www.facebook.com/careers/jobs/a0I1H00000LCQMWUA5/</a><br>  <a href="https://www.facebook.com/careers/jobs/a0I1H00000LBiNYUA1/" target="_blank" rel="noopener">https://www.facebook.com/careers/jobs/a0I1H00000LBiNYUA1/</a><br>  <a href="https://www.facebook.com/careers/jobs/a0I1200000JA4R2EAL/" target="_blank" rel="noopener">https://www.facebook.com/careers/jobs/a0I1200000JA4R2EAL/</a></p><p>  Amazon, 8/16, 8/17 confirm letter, 8/24 application information completed and submitted<br>  kevin lai<br>  <a href="https://www.amazon.jobs/zh/jobs/697789/2019-software-development-engineer-united-states" target="_blank" rel="noopener">https://www.amazon.jobs/zh/jobs/697789/2019-software-development-engineer-united-states</a><br>  <a href="https://www.amazon.jobs/zh/jobs/678630/software-development-engineer" target="_blank" rel="noopener">https://www.amazon.jobs/zh/jobs/678630/software-development-engineer</a><br>  <a href="https://www.amazon.jobs/zh/jobs/697755/software-development-engineer" target="_blank" rel="noopener">https://www.amazon.jobs/zh/jobs/697755/software-development-engineer</a><br>  <a href="https://www.amazonuniversity.jobs/dashboard" target="_blank" rel="noopener">https://www.amazonuniversity.jobs/dashboard</a></p><p>  airbnb, 8/19, 8/21 reply will refer later, 8/27 refer<br>  <a href="https://goo.gl/koXpJ8" target="_blank" rel="noopener">https://goo.gl/koXpJ8</a></p><p>  VMWare propel program, 8/19, 9/1 refer<br>  <a href="https://goo.gl/Xguhhv" target="_blank" rel="noopener">https://goo.gl/Xguhhv</a></p><p>  Dropbox, 8/21<br>  <a href="https://goo.gl/h4dK78" target="_blank" rel="noopener">https://goo.gl/h4dK78</a><br>  <a href="https://www.dropbox.com/jobs/listing/1234094" target="_blank" rel="noopener">https://www.dropbox.com/jobs/listing/1234094</a><br>  9/1<br>  <a href="https://goo.gl/uHtGES" target="_blank" rel="noopener">https://goo.gl/uHtGES</a></p><p>  Microsoft, 8/24<br>  <a href="https://goo.gl/HTHD7h" target="_blank" rel="noopener">https://goo.gl/HTHD7h</a></p><p>  Twitter, 8/24<br>  <a href="https://careers.twitter.com/en/university.html" target="_blank" rel="noopener">https://careers.twitter.com/en/university.html</a></p><p>  Bloomberg, 8/25, 8/28 reply and submitted application<br>  <a href="https://goo.gl/9XyYFh" target="_blank" rel="noopener">https://goo.gl/9XyYFh</a></p><p>  Linkedin, 8/27<br>  <a href="http://www.1point3acres.com/bbs/thread-439285-1-1.html" target="_blank" rel="noopener">http://www.1point3acres.com/bbs/thread-439285-1-1.html</a><br>  9/1<br>  <a href="https://goo.gl/bb75hg" target="_blank" rel="noopener">https://goo.gl/bb75hg</a></p><p>  Google, 8/28, 9/2 apply<br>  Chiawei</p><p>——未推——<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">| Tier | company   | where found                                            | email                             | job search | freeze   | remark |</span><br><span class="line">|------|-----------|--------------------------------------------------------|-----------------------------------|------------|----------|--------|</span><br><span class="line">| 1    | Google    | https://goo.gl/Wp6XDs                                  | emily.ggrefer@gmail.com           |            |          |        |</span><br><span class="line">|      |           | https://goo.gl/ihocNf                                  | lgrefer78@gmail.com               |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Facebook  | https://goo.gl/MkCvdg                                  | fancyusc@gmail.com                |            | 6/21 end |        |</span><br><span class="line">|      |           | https://goo.gl/N9CjJA                                  | facebooksde@gmail.com             |            |          |        |</span><br><span class="line">|      |           | http://www.1point3acres.com/bbs/thread-429788-1-1.html | fbreferral.anyposition@gmail.com  |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Linkedin  | https://goo.gl/5ovfPo                                  |                                   |            |          |        |</span><br><span class="line">|      |           | https://goo.gl/jsafs7                                  | lkndreferral@gmail.com            |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Microsoft | https://goo.gl/q6AzJm                                  |                                   |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Amazon    | https://goo.gl/8jBf3T,                                 | infinity.730@outlook.com          |            |          |        |</span><br><span class="line">|      |           | https://goo.gl/Kga1fu                                  | referalamazon65@gmail.com         |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Apple     |                                                        |                                   |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | VMWare    | https://goo.gl/jD8siQ                                  |                                   |            |          |        |</span><br><span class="line">|      |           |                                                        |                                   |            |          |        |</span><br><span class="line">|      | Dropbox   | https://goo.gl/vw1cQW                                  | diuhezi@gmail.com                 |            |          | -      |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| Tier | company  | where found            | email                       | job search | freeze | remark |</span><br><span class="line">|------|----------|------------------------|-----------------------------|------------|--------|--------|</span><br><span class="line">| 2    | Paypal   | https://goo.gl/3X5odc  | paypal.refer.2018@gmail.com |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Adobe    | https://goo.gl/yAVixp  |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Airbnb   | https://goo.gl/z8k4st  | referralairbnb@gmail.com    |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Uber     |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Lyft     |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Docker   |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Whatsapp |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Netflix  |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Twitter  |                        |                             |            |        |        |</span><br><span class="line">|      |          |                        |                             |            |        |        |</span><br><span class="line">|      | Snapchat |                        |                             |            |        | -      |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| Tier | company                       | where found                                            | email                       | job search                     | freeze | remark |</span><br><span class="line">|------|-------------------------------|--------------------------------------------------------|-----------------------------|--------------------------------|--------|--------|</span><br><span class="line">| 3    | Chase                         | https://goo.gl/ZEdmuV                                  | jpmc.referral815@gmail.com. | https://jobs.jpmorganchase.com |        |        |</span><br><span class="line">|      |                               |                                                        |                             |                                |        |        |</span><br><span class="line">|      | Upgrade Inc. series A funding | https://goo.gl/sGnrqF                                  | yrefer18@gmail.com          | https://jobs.lever.co/upgrade  |        | fitech |</span><br><span class="line">|      |                               |                                                        |                             |                                |        |        |</span><br><span class="line">|      | Morganstanley                 | http://www.1point3acres.com/bbs/thread-429994-1-1.html | morganrefer@gmail.com       |                                |        | -      |</span><br></pre></td></tr></table></figure></p><p>Lyft<br>Google</p><p>Apple<br>eBay<br>SAP<br>Oracle<br>Linkedin<br>cisco<br>snapchat</p><p>salesforce<br>2 sigma</p><p>zenefits<br>zulily<br>trip advisor<br>Nutanix<br>Zillow<br>yahoo(oath)<br>cloudra<br>Yelp<br>eBay<br>citadel<br>Rubrik<br>QUACOMM<br>squre<br>VMware</p><p>houzz<br>wepay<br>Akamia<br>Zillow<br>coursera<br>pocket gems</p><p>Quora<br>Pinterest<br>Wish<br>twillo</p><p>Arista<br>spotify<br>Stripe<br>Robinhood<br>Netflix<br>Slack<br>tasla<br>samsung<br>hulu<br>indeed<br>Priceline<br>OpenTable<br>looking glass<br>AppDyanmics(好像沒有ＮＥＷ＿ＧＲＡＤ)<br>box<br>citrix</p><p>go daddy<br>Nvidia<br>Palantir<br>SAP<br>3Ｍ<br>groupon<br>ＩＸＬ<br>intuit<br>Expedia<br>  <a href="https://goo.gl/u3h63v" target="_blank" rel="noopener">https://goo.gl/u3h63v</a>, <a href="mailto:expediarefer@gmail.com" target="_blank" rel="noopener">expediarefer@gmail.com</a></p><p>Chase<br>  <a href="https://goo.gl/fiYPPx" target="_blank" rel="noopener">https://goo.gl/fiYPPx</a> <a href="mailto:jpmc.referral815@gmail.com" target="_blank" rel="noopener">jpmc.referral815@gmail.com</a></p>]]></content>
      
      
        <tags>
            
            <tag> refer </tag>
            
            <tag> job </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LC24. Swap Nodes in Pairs</title>
      <link href="/2018/03/31/LC24-Swap-Nodes-in-Pairs/"/>
      <url>/2018/03/31/LC24-Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>  Given a linked list, swap every two adjacent nodes and return its head.</p><p>  For example,<br>  Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p><p>  Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode* newhead = <span class="keyword">new</span> ListNode(INT_MIN);</span><br><span class="line">        newhead-&gt;next = head;</span><br><span class="line">        ListNode* tmp = newhead;</span><br><span class="line">        </span><br><span class="line">        ListNode *one = <span class="literal">NULL</span>, *two = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next &amp;&amp; tmp-&gt;next-&gt;next)&#123;</span><br><span class="line">            one = tmp-&gt;next;</span><br><span class="line">            two = tmp-&gt;next-&gt;next;</span><br><span class="line">            </span><br><span class="line">            one-&gt;next = two-&gt;next;</span><br><span class="line">            two-&gt;next = one;</span><br><span class="line">            tmp-&gt;next = two;</span><br><span class="line">            tmp = one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11046/My-simple-JAVA-solution-for-share/11919" target="_blank" rel="noopener">https://leetcode.com/problems/swap-nodes-in-pairs/discuss/11046/My-simple-JAVA-solution-for-share/11919</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> cycle detection </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LC142. Linked List Cycle II</title>
      <link href="/2018/03/30/LC142-Linked-List-Cycle-II/"/>
      <url>/2018/03/30/LC142-Linked-List-Cycle-II/</url>
      <content type="html"><![CDATA[<p>Reference:<br><a href="https://en.wikipedia.org/wiki/Cycle_detection" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cycle_detection</a><br><a href="https://leetcode.com/problems/linked-list-cycle-ii/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/solution/</a><br><a href="https://goo.gl/SpP3Yb" target="_blank" rel="noopener">https://goo.gl/SpP3Yb</a><br><a href="https://goo.gl/UNFB98" target="_blank" rel="noopener">https://goo.gl/UNFB98</a></p>]]></content>
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> cycle detection </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LC147. Insertion Sort List</title>
      <link href="/2018/03/29/LC147-Insertion-Sort-List/"/>
      <url>/2018/03/29/LC147-Insertion-Sort-List/</url>
      <content type="html"><![CDATA[<p>Problem description:<br>Sort a linked list using insertion sort.</p><p>Analysis:<br>The insertion sort of linked list can be done in O(1) space. In this solution, I create a node, result, to contain the result. The result would be look like the following graph.</p><pre><code>-init state-Original: 1 3 2 4 5result-&gt;null-first round-Original: 3 2 4 5result-&gt;1-&gt;NULL</code></pre><p>I use the next pointer to temporally save the position in the original list. The iter already move to the position in the result list that contains value higher than head-&gt;val. Then adjust the pointer in these item to direct head node to result list and move to next item in original list.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">insertionSortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">result</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            ListNode* iter = &amp;result;</span><br><span class="line">            <span class="keyword">while</span>(iter-&gt;next &amp;&amp; (iter-&gt;next-&gt;val &lt; head-&gt;val))&#123; </span><br><span class="line">                <span class="comment">//when result list gets long, use this to find proper position in result list.</span></span><br><span class="line">                iter = iter-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            head-&gt;next = iter-&gt;next;</span><br><span class="line">            iter-&gt;next = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://goo.gl/dzL3m1" target="_blank" rel="noopener">https://goo.gl/dzL3m1</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LC148.Sort List</title>
      <link href="/2018/03/28/LC148-Sort-List/"/>
      <url>/2018/03/28/LC148-Sort-List/</url>
      <content type="html"><![CDATA[<p>Sort a linked list in O(nlogn) time using constant space complexity.</p><p>When it comes to the algorithm that can sort in O(nlogn), it should be Merge sort, Quick sort, Heap sort. The difficult part in this question is the space complexity. If you choose recursive, the program stack will exceed the requirement and might lead to stack overflow. If you use Top-down merge sort, you will use another recursive in your program.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://goo.gl/xgNMT4</span></span><br><span class="line"><span class="comment"> * Merge sort use bottom-up policy, </span></span><br><span class="line"><span class="comment"> * so Space Complexity is O(1)</span></span><br><span class="line"><span class="comment"> * Time Complexity is O(NlgN)</span></span><br><span class="line"><span class="comment"> * stable sort</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode *<span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!head || !(head-&gt;next)) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get the linked list's length</span></span><br><span class="line">ListNode* cur = head;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cur)&#123;</span><br><span class="line">length++;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">dummy.next = head;</span><br><span class="line">ListNode *left, *right, *tail;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt; length; step &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">cur = dummy.next;</span><br><span class="line">tail = &amp;dummy;</span><br><span class="line"><span class="keyword">while</span>(cur)&#123;</span><br><span class="line">left = cur;</span><br><span class="line">right = split(left, step);</span><br><span class="line">cur = split(right,step);</span><br><span class="line">tail = merge(left, right, tail);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Divide the linked list into two lists,</span></span><br><span class="line"><span class="comment">     * while the first list contains first n ndoes</span></span><br><span class="line"><span class="comment"> * return the second list's head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//if(!head) return NULL;</span></span><br><span class="line">        <span class="comment">//1. point to the position that want to spilt</span></span><br><span class="line">        <span class="comment">//2. separate two linked list, which are from start-&gt;head, second</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; head &amp;&amp; i &lt; n; i++) head = head-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">ListNode *second = head-&gt;next; </span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>; <span class="comment">//end the list</span></span><br><span class="line"><span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * merge the two sorted linked list l1 and l2,</span></span><br><span class="line"><span class="comment">  * then append the merged sorted linked list to the node head</span></span><br><span class="line"><span class="comment">  * return the tail of the merged sorted linked list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2, ListNode* head)</span></span>&#123;</span><br><span class="line">ListNode *cur = head;</span><br><span class="line"><span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line"><span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">cur-&gt;next = l2;</span><br><span class="line">cur = l2;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cur-&gt;next = l1;</span><br><span class="line">cur = l1;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur-&gt;next = (l1 ? l1 : l2);</span><br><span class="line"><span class="keyword">while</span>(cur-&gt;next) cur = cur-&gt;next;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://goo.gl/xgNMT4" target="_blank" rel="noopener">https://goo.gl/xgNMT4</a><br><a href="https://goo.gl/zgWtLT" target="_blank" rel="noopener">https://goo.gl/zgWtLT</a><br><a href="https://goo.gl/JY6o7o" target="_blank" rel="noopener">https://goo.gl/JY6o7o</a></p>]]></content>
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
            <tag> merge sort </tag>
            
            <tag> space complexity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Space complexity between recursion and iterative</title>
      <link href="/2018/03/28/Space%20complexity/"/>
      <url>/2018/03/28/Space%20complexity/</url>
      <content type="html"><![CDATA[<p>Basically, a recursive algorithm will add overhead since you store recursive calls in the execution stack.</p><p>But if the recursive function is  <strong>the last line of the call (tail recursion)</strong> then there is no additional penalty.</p><p>That is of course both algorithms are the same.</p><p><strong><em>Space complexity in Merge-sort</em></strong></p><p>Reference:<br><a href="https://www.codeproject.com/Articles/21194/Iterative-vs-Recursive-Approaches" target="_blank" rel="noopener">https://www.codeproject.com/Articles/21194/Iterative-vs-Recursive-Approaches</a><br><a href="https://stackoverflow.com/questions/10821059/space-complexity-of-recursive-algorithm" target="_blank" rel="noopener">https://stackoverflow.com/questions/10821059/space-complexity-of-recursive-algorithm</a><br><a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Tail_call</a><br><a href="https://goo.gl/JY6o7o" target="_blank" rel="noopener">https://goo.gl/JY6o7o</a></p>]]></content>
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>How to setup a webpage</title>
      <link href="/2018/03/25/how%20to%20setup%20webpage/"/>
      <url>/2018/03/25/how%20to%20setup%20webpage/</url>
      <content type="html"><![CDATA[<p>It’s not that familiar for me, who basically use c++ and python, to setup a website. So I checked some options, and decided to use Hexo.<br>Setting up website through Hexo is pretty simple, which I believe can be done in half an hour. Let’s begin.</p><p>My Environment:<br>Mac Sierra: 10.12.6<br>NodeJS: v8.10.0<br>Git: git version 2.10.1 (Apple Git-78)</p><h2 id="Download-package"><a href="#Download-package" class="headerlink" title="Download package"></a>Download package</h2><p>First of all, the Hexo is based on two packages, NodeJS and Git. For those who don’t have/don’t know if you have these two packages, you can use the following commands on your terminal to check.</p><p>I follow the original steps of these installations. </p><h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure><p>if you don’t have NodeJS installed on you machine, you can go download it through this site.<br><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git version</span><br></pre></td></tr></table></figure><p>if you don’t have Git installed on you machine, you can go download it through this site.<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><h3 id="Hexo-Installation"><a href="#Hexo-Installation" class="headerlink" title="Hexo Installation"></a>Hexo Installation</h3><p>To install hexo, we need to use node project manager to download it. I had permission error, so I use sudo to fix it. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="Create-webpage"><a href="#Create-webpage" class="headerlink" title="Create webpage"></a>Create webpage</h2><h3 id="Create-new-project"><a href="#Create-new-project" class="headerlink" title="Create new project"></a>Create new project</h3><p>After successfully install hexo, you should be able to create your own project. Here, I use “hexo_tmp” as the project name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo_tmp</span><br></pre></td></tr></table></figure><h3 id="Create-new-web-page"><a href="#Create-new-web-page" class="headerlink" title="Create new web page"></a>Create new web page</h3><p>Check the source_posts folder, add a markdown file, and you’re good to go.</p><h2 id="Publish-the-webpage-on-github"><a href="#Publish-the-webpage-on-github" class="headerlink" title="Publish the webpage on github"></a>Publish the webpage on github</h2><p>Each github account can publish a webpage use github pages. The following steps would help you setup the webpage on github. </p><ol><li>Create github repository</li><li>Change configuration in hexo</li><li>Public the data to github</li></ol><h3 id="Create-github-repository"><a href="#Create-github-repository" class="headerlink" title="Create github repository"></a>Create github repository</h3><p>Login to you github and create a new repository like this. Notice that each account only have one free github page, and the name is restricted to “username.github.io”<br>The following picture is screenshot after I created the blog, so you should be okay to create a repository like this.</p><p><img src="github1.png" alt=""></p><h3 id="Change-configuration-in-hexo"><a href="#Change-configuration-in-hexo" class="headerlink" title="Change configuration in hexo"></a>Change configuration in hexo</h3><p>The most frequently used file in hexo should be “hexofolder/_config.yml”<br>You should be able to find these two parts of code in your _config.yml. Change the “username” to your account name.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: https://username.github.io</span><br><span class="line">#root:</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/username/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="Public-the-data-to-github"><a href="#Public-the-data-to-github" class="headerlink" title="Public the data to github"></a>Public the data to github</h3><p>Finish above steps, you are on step to publish you website. Type the following command and you can see your website on <a href="https://username.github.io" target="_blank" rel="noopener">https://username.github.io</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> tutorial </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
